
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model im_exercise
 * 
 */
export type im_exercise = $Result.DefaultSelection<Prisma.$im_exercisePayload>
/**
 * Model im_exercise_history
 * 
 */
export type im_exercise_history = $Result.DefaultSelection<Prisma.$im_exercise_historyPayload>
/**
 * Model im_food
 * 
 */
export type im_food = $Result.DefaultSelection<Prisma.$im_foodPayload>
/**
 * Model im_health
 * 
 */
export type im_health = $Result.DefaultSelection<Prisma.$im_healthPayload>
/**
 * Model im_health_goal
 * 
 */
export type im_health_goal = $Result.DefaultSelection<Prisma.$im_health_goalPayload>
/**
 * Model im_health_goal_daily
 * 
 */
export type im_health_goal_daily = $Result.DefaultSelection<Prisma.$im_health_goal_dailyPayload>
/**
 * Model im_health_goal_daily_history
 * 
 */
export type im_health_goal_daily_history = $Result.DefaultSelection<Prisma.$im_health_goal_daily_historyPayload>
/**
 * Model im_meal
 * 
 */
export type im_meal = $Result.DefaultSelection<Prisma.$im_mealPayload>
/**
 * Model im_nutrition
 * 
 */
export type im_nutrition = $Result.DefaultSelection<Prisma.$im_nutritionPayload>
/**
 * Model im_recipe
 * 
 */
export type im_recipe = $Result.DefaultSelection<Prisma.$im_recipePayload>
/**
 * Model im_training
 * 
 */
export type im_training = $Result.DefaultSelection<Prisma.$im_trainingPayload>
/**
 * Model im_undesirable_food
 * 
 */
export type im_undesirable_food = $Result.DefaultSelection<Prisma.$im_undesirable_foodPayload>
/**
 * Model im_user
 * 
 */
export type im_user = $Result.DefaultSelection<Prisma.$im_userPayload>
/**
 * Model im_workout
 * 
 */
export type im_workout = $Result.DefaultSelection<Prisma.$im_workoutPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Im_exercises
 * const im_exercises = await prisma.im_exercise.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Im_exercises
   * const im_exercises = await prisma.im_exercise.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.im_exercise`: Exposes CRUD operations for the **im_exercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Im_exercises
    * const im_exercises = await prisma.im_exercise.findMany()
    * ```
    */
  get im_exercise(): Prisma.im_exerciseDelegate<ExtArgs>;

  /**
   * `prisma.im_exercise_history`: Exposes CRUD operations for the **im_exercise_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Im_exercise_histories
    * const im_exercise_histories = await prisma.im_exercise_history.findMany()
    * ```
    */
  get im_exercise_history(): Prisma.im_exercise_historyDelegate<ExtArgs>;

  /**
   * `prisma.im_food`: Exposes CRUD operations for the **im_food** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Im_foods
    * const im_foods = await prisma.im_food.findMany()
    * ```
    */
  get im_food(): Prisma.im_foodDelegate<ExtArgs>;

  /**
   * `prisma.im_health`: Exposes CRUD operations for the **im_health** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Im_healths
    * const im_healths = await prisma.im_health.findMany()
    * ```
    */
  get im_health(): Prisma.im_healthDelegate<ExtArgs>;

  /**
   * `prisma.im_health_goal`: Exposes CRUD operations for the **im_health_goal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Im_health_goals
    * const im_health_goals = await prisma.im_health_goal.findMany()
    * ```
    */
  get im_health_goal(): Prisma.im_health_goalDelegate<ExtArgs>;

  /**
   * `prisma.im_health_goal_daily`: Exposes CRUD operations for the **im_health_goal_daily** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Im_health_goal_dailies
    * const im_health_goal_dailies = await prisma.im_health_goal_daily.findMany()
    * ```
    */
  get im_health_goal_daily(): Prisma.im_health_goal_dailyDelegate<ExtArgs>;

  /**
   * `prisma.im_health_goal_daily_history`: Exposes CRUD operations for the **im_health_goal_daily_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Im_health_goal_daily_histories
    * const im_health_goal_daily_histories = await prisma.im_health_goal_daily_history.findMany()
    * ```
    */
  get im_health_goal_daily_history(): Prisma.im_health_goal_daily_historyDelegate<ExtArgs>;

  /**
   * `prisma.im_meal`: Exposes CRUD operations for the **im_meal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Im_meals
    * const im_meals = await prisma.im_meal.findMany()
    * ```
    */
  get im_meal(): Prisma.im_mealDelegate<ExtArgs>;

  /**
   * `prisma.im_nutrition`: Exposes CRUD operations for the **im_nutrition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Im_nutritions
    * const im_nutritions = await prisma.im_nutrition.findMany()
    * ```
    */
  get im_nutrition(): Prisma.im_nutritionDelegate<ExtArgs>;

  /**
   * `prisma.im_recipe`: Exposes CRUD operations for the **im_recipe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Im_recipes
    * const im_recipes = await prisma.im_recipe.findMany()
    * ```
    */
  get im_recipe(): Prisma.im_recipeDelegate<ExtArgs>;

  /**
   * `prisma.im_training`: Exposes CRUD operations for the **im_training** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Im_trainings
    * const im_trainings = await prisma.im_training.findMany()
    * ```
    */
  get im_training(): Prisma.im_trainingDelegate<ExtArgs>;

  /**
   * `prisma.im_undesirable_food`: Exposes CRUD operations for the **im_undesirable_food** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Im_undesirable_foods
    * const im_undesirable_foods = await prisma.im_undesirable_food.findMany()
    * ```
    */
  get im_undesirable_food(): Prisma.im_undesirable_foodDelegate<ExtArgs>;

  /**
   * `prisma.im_user`: Exposes CRUD operations for the **im_user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Im_users
    * const im_users = await prisma.im_user.findMany()
    * ```
    */
  get im_user(): Prisma.im_userDelegate<ExtArgs>;

  /**
   * `prisma.im_workout`: Exposes CRUD operations for the **im_workout** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Im_workouts
    * const im_workouts = await prisma.im_workout.findMany()
    * ```
    */
  get im_workout(): Prisma.im_workoutDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.12.1
   * Query Engine version: 473ed3124229e22d881cb7addf559799debae1ab
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    im_exercise: 'im_exercise',
    im_exercise_history: 'im_exercise_history',
    im_food: 'im_food',
    im_health: 'im_health',
    im_health_goal: 'im_health_goal',
    im_health_goal_daily: 'im_health_goal_daily',
    im_health_goal_daily_history: 'im_health_goal_daily_history',
    im_meal: 'im_meal',
    im_nutrition: 'im_nutrition',
    im_recipe: 'im_recipe',
    im_training: 'im_training',
    im_undesirable_food: 'im_undesirable_food',
    im_user: 'im_user',
    im_workout: 'im_workout'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'im_exercise' | 'im_exercise_history' | 'im_food' | 'im_health' | 'im_health_goal' | 'im_health_goal_daily' | 'im_health_goal_daily_history' | 'im_meal' | 'im_nutrition' | 'im_recipe' | 'im_training' | 'im_undesirable_food' | 'im_user' | 'im_workout'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      im_exercise: {
        payload: Prisma.$im_exercisePayload<ExtArgs>
        fields: Prisma.im_exerciseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.im_exerciseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_exercisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.im_exerciseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_exercisePayload>
          }
          findFirst: {
            args: Prisma.im_exerciseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_exercisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.im_exerciseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_exercisePayload>
          }
          findMany: {
            args: Prisma.im_exerciseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_exercisePayload>[]
          }
          create: {
            args: Prisma.im_exerciseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_exercisePayload>
          }
          createMany: {
            args: Prisma.im_exerciseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.im_exerciseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_exercisePayload>
          }
          update: {
            args: Prisma.im_exerciseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_exercisePayload>
          }
          deleteMany: {
            args: Prisma.im_exerciseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.im_exerciseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.im_exerciseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_exercisePayload>
          }
          aggregate: {
            args: Prisma.Im_exerciseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIm_exercise>
          }
          groupBy: {
            args: Prisma.im_exerciseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Im_exerciseGroupByOutputType>[]
          }
          count: {
            args: Prisma.im_exerciseCountArgs<ExtArgs>,
            result: $Utils.Optional<Im_exerciseCountAggregateOutputType> | number
          }
        }
      }
      im_exercise_history: {
        payload: Prisma.$im_exercise_historyPayload<ExtArgs>
        fields: Prisma.im_exercise_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.im_exercise_historyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_exercise_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.im_exercise_historyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_exercise_historyPayload>
          }
          findFirst: {
            args: Prisma.im_exercise_historyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_exercise_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.im_exercise_historyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_exercise_historyPayload>
          }
          findMany: {
            args: Prisma.im_exercise_historyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_exercise_historyPayload>[]
          }
          create: {
            args: Prisma.im_exercise_historyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_exercise_historyPayload>
          }
          createMany: {
            args: Prisma.im_exercise_historyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.im_exercise_historyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_exercise_historyPayload>
          }
          update: {
            args: Prisma.im_exercise_historyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_exercise_historyPayload>
          }
          deleteMany: {
            args: Prisma.im_exercise_historyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.im_exercise_historyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.im_exercise_historyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_exercise_historyPayload>
          }
          aggregate: {
            args: Prisma.Im_exercise_historyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIm_exercise_history>
          }
          groupBy: {
            args: Prisma.im_exercise_historyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Im_exercise_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.im_exercise_historyCountArgs<ExtArgs>,
            result: $Utils.Optional<Im_exercise_historyCountAggregateOutputType> | number
          }
        }
      }
      im_food: {
        payload: Prisma.$im_foodPayload<ExtArgs>
        fields: Prisma.im_foodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.im_foodFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_foodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.im_foodFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_foodPayload>
          }
          findFirst: {
            args: Prisma.im_foodFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_foodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.im_foodFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_foodPayload>
          }
          findMany: {
            args: Prisma.im_foodFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_foodPayload>[]
          }
          create: {
            args: Prisma.im_foodCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_foodPayload>
          }
          createMany: {
            args: Prisma.im_foodCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.im_foodDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_foodPayload>
          }
          update: {
            args: Prisma.im_foodUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_foodPayload>
          }
          deleteMany: {
            args: Prisma.im_foodDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.im_foodUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.im_foodUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_foodPayload>
          }
          aggregate: {
            args: Prisma.Im_foodAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIm_food>
          }
          groupBy: {
            args: Prisma.im_foodGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Im_foodGroupByOutputType>[]
          }
          count: {
            args: Prisma.im_foodCountArgs<ExtArgs>,
            result: $Utils.Optional<Im_foodCountAggregateOutputType> | number
          }
        }
      }
      im_health: {
        payload: Prisma.$im_healthPayload<ExtArgs>
        fields: Prisma.im_healthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.im_healthFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_healthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.im_healthFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_healthPayload>
          }
          findFirst: {
            args: Prisma.im_healthFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_healthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.im_healthFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_healthPayload>
          }
          findMany: {
            args: Prisma.im_healthFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_healthPayload>[]
          }
          create: {
            args: Prisma.im_healthCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_healthPayload>
          }
          createMany: {
            args: Prisma.im_healthCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.im_healthDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_healthPayload>
          }
          update: {
            args: Prisma.im_healthUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_healthPayload>
          }
          deleteMany: {
            args: Prisma.im_healthDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.im_healthUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.im_healthUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_healthPayload>
          }
          aggregate: {
            args: Prisma.Im_healthAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIm_health>
          }
          groupBy: {
            args: Prisma.im_healthGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Im_healthGroupByOutputType>[]
          }
          count: {
            args: Prisma.im_healthCountArgs<ExtArgs>,
            result: $Utils.Optional<Im_healthCountAggregateOutputType> | number
          }
        }
      }
      im_health_goal: {
        payload: Prisma.$im_health_goalPayload<ExtArgs>
        fields: Prisma.im_health_goalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.im_health_goalFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_health_goalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.im_health_goalFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_health_goalPayload>
          }
          findFirst: {
            args: Prisma.im_health_goalFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_health_goalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.im_health_goalFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_health_goalPayload>
          }
          findMany: {
            args: Prisma.im_health_goalFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_health_goalPayload>[]
          }
          create: {
            args: Prisma.im_health_goalCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_health_goalPayload>
          }
          createMany: {
            args: Prisma.im_health_goalCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.im_health_goalDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_health_goalPayload>
          }
          update: {
            args: Prisma.im_health_goalUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_health_goalPayload>
          }
          deleteMany: {
            args: Prisma.im_health_goalDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.im_health_goalUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.im_health_goalUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_health_goalPayload>
          }
          aggregate: {
            args: Prisma.Im_health_goalAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIm_health_goal>
          }
          groupBy: {
            args: Prisma.im_health_goalGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Im_health_goalGroupByOutputType>[]
          }
          count: {
            args: Prisma.im_health_goalCountArgs<ExtArgs>,
            result: $Utils.Optional<Im_health_goalCountAggregateOutputType> | number
          }
        }
      }
      im_health_goal_daily: {
        payload: Prisma.$im_health_goal_dailyPayload<ExtArgs>
        fields: Prisma.im_health_goal_dailyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.im_health_goal_dailyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_health_goal_dailyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.im_health_goal_dailyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_health_goal_dailyPayload>
          }
          findFirst: {
            args: Prisma.im_health_goal_dailyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_health_goal_dailyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.im_health_goal_dailyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_health_goal_dailyPayload>
          }
          findMany: {
            args: Prisma.im_health_goal_dailyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_health_goal_dailyPayload>[]
          }
          create: {
            args: Prisma.im_health_goal_dailyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_health_goal_dailyPayload>
          }
          createMany: {
            args: Prisma.im_health_goal_dailyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.im_health_goal_dailyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_health_goal_dailyPayload>
          }
          update: {
            args: Prisma.im_health_goal_dailyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_health_goal_dailyPayload>
          }
          deleteMany: {
            args: Prisma.im_health_goal_dailyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.im_health_goal_dailyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.im_health_goal_dailyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_health_goal_dailyPayload>
          }
          aggregate: {
            args: Prisma.Im_health_goal_dailyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIm_health_goal_daily>
          }
          groupBy: {
            args: Prisma.im_health_goal_dailyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Im_health_goal_dailyGroupByOutputType>[]
          }
          count: {
            args: Prisma.im_health_goal_dailyCountArgs<ExtArgs>,
            result: $Utils.Optional<Im_health_goal_dailyCountAggregateOutputType> | number
          }
        }
      }
      im_health_goal_daily_history: {
        payload: Prisma.$im_health_goal_daily_historyPayload<ExtArgs>
        fields: Prisma.im_health_goal_daily_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.im_health_goal_daily_historyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_health_goal_daily_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.im_health_goal_daily_historyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_health_goal_daily_historyPayload>
          }
          findFirst: {
            args: Prisma.im_health_goal_daily_historyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_health_goal_daily_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.im_health_goal_daily_historyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_health_goal_daily_historyPayload>
          }
          findMany: {
            args: Prisma.im_health_goal_daily_historyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_health_goal_daily_historyPayload>[]
          }
          create: {
            args: Prisma.im_health_goal_daily_historyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_health_goal_daily_historyPayload>
          }
          createMany: {
            args: Prisma.im_health_goal_daily_historyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.im_health_goal_daily_historyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_health_goal_daily_historyPayload>
          }
          update: {
            args: Prisma.im_health_goal_daily_historyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_health_goal_daily_historyPayload>
          }
          deleteMany: {
            args: Prisma.im_health_goal_daily_historyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.im_health_goal_daily_historyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.im_health_goal_daily_historyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_health_goal_daily_historyPayload>
          }
          aggregate: {
            args: Prisma.Im_health_goal_daily_historyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIm_health_goal_daily_history>
          }
          groupBy: {
            args: Prisma.im_health_goal_daily_historyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Im_health_goal_daily_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.im_health_goal_daily_historyCountArgs<ExtArgs>,
            result: $Utils.Optional<Im_health_goal_daily_historyCountAggregateOutputType> | number
          }
        }
      }
      im_meal: {
        payload: Prisma.$im_mealPayload<ExtArgs>
        fields: Prisma.im_mealFieldRefs
        operations: {
          findUnique: {
            args: Prisma.im_mealFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_mealPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.im_mealFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_mealPayload>
          }
          findFirst: {
            args: Prisma.im_mealFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_mealPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.im_mealFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_mealPayload>
          }
          findMany: {
            args: Prisma.im_mealFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_mealPayload>[]
          }
          create: {
            args: Prisma.im_mealCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_mealPayload>
          }
          createMany: {
            args: Prisma.im_mealCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.im_mealDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_mealPayload>
          }
          update: {
            args: Prisma.im_mealUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_mealPayload>
          }
          deleteMany: {
            args: Prisma.im_mealDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.im_mealUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.im_mealUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_mealPayload>
          }
          aggregate: {
            args: Prisma.Im_mealAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIm_meal>
          }
          groupBy: {
            args: Prisma.im_mealGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Im_mealGroupByOutputType>[]
          }
          count: {
            args: Prisma.im_mealCountArgs<ExtArgs>,
            result: $Utils.Optional<Im_mealCountAggregateOutputType> | number
          }
        }
      }
      im_nutrition: {
        payload: Prisma.$im_nutritionPayload<ExtArgs>
        fields: Prisma.im_nutritionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.im_nutritionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_nutritionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.im_nutritionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_nutritionPayload>
          }
          findFirst: {
            args: Prisma.im_nutritionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_nutritionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.im_nutritionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_nutritionPayload>
          }
          findMany: {
            args: Prisma.im_nutritionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_nutritionPayload>[]
          }
          create: {
            args: Prisma.im_nutritionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_nutritionPayload>
          }
          createMany: {
            args: Prisma.im_nutritionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.im_nutritionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_nutritionPayload>
          }
          update: {
            args: Prisma.im_nutritionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_nutritionPayload>
          }
          deleteMany: {
            args: Prisma.im_nutritionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.im_nutritionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.im_nutritionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_nutritionPayload>
          }
          aggregate: {
            args: Prisma.Im_nutritionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIm_nutrition>
          }
          groupBy: {
            args: Prisma.im_nutritionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Im_nutritionGroupByOutputType>[]
          }
          count: {
            args: Prisma.im_nutritionCountArgs<ExtArgs>,
            result: $Utils.Optional<Im_nutritionCountAggregateOutputType> | number
          }
        }
      }
      im_recipe: {
        payload: Prisma.$im_recipePayload<ExtArgs>
        fields: Prisma.im_recipeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.im_recipeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_recipePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.im_recipeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_recipePayload>
          }
          findFirst: {
            args: Prisma.im_recipeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_recipePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.im_recipeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_recipePayload>
          }
          findMany: {
            args: Prisma.im_recipeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_recipePayload>[]
          }
          create: {
            args: Prisma.im_recipeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_recipePayload>
          }
          createMany: {
            args: Prisma.im_recipeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.im_recipeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_recipePayload>
          }
          update: {
            args: Prisma.im_recipeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_recipePayload>
          }
          deleteMany: {
            args: Prisma.im_recipeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.im_recipeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.im_recipeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_recipePayload>
          }
          aggregate: {
            args: Prisma.Im_recipeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIm_recipe>
          }
          groupBy: {
            args: Prisma.im_recipeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Im_recipeGroupByOutputType>[]
          }
          count: {
            args: Prisma.im_recipeCountArgs<ExtArgs>,
            result: $Utils.Optional<Im_recipeCountAggregateOutputType> | number
          }
        }
      }
      im_training: {
        payload: Prisma.$im_trainingPayload<ExtArgs>
        fields: Prisma.im_trainingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.im_trainingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_trainingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.im_trainingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_trainingPayload>
          }
          findFirst: {
            args: Prisma.im_trainingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_trainingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.im_trainingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_trainingPayload>
          }
          findMany: {
            args: Prisma.im_trainingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_trainingPayload>[]
          }
          create: {
            args: Prisma.im_trainingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_trainingPayload>
          }
          createMany: {
            args: Prisma.im_trainingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.im_trainingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_trainingPayload>
          }
          update: {
            args: Prisma.im_trainingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_trainingPayload>
          }
          deleteMany: {
            args: Prisma.im_trainingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.im_trainingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.im_trainingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_trainingPayload>
          }
          aggregate: {
            args: Prisma.Im_trainingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIm_training>
          }
          groupBy: {
            args: Prisma.im_trainingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Im_trainingGroupByOutputType>[]
          }
          count: {
            args: Prisma.im_trainingCountArgs<ExtArgs>,
            result: $Utils.Optional<Im_trainingCountAggregateOutputType> | number
          }
        }
      }
      im_undesirable_food: {
        payload: Prisma.$im_undesirable_foodPayload<ExtArgs>
        fields: Prisma.im_undesirable_foodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.im_undesirable_foodFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_undesirable_foodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.im_undesirable_foodFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_undesirable_foodPayload>
          }
          findFirst: {
            args: Prisma.im_undesirable_foodFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_undesirable_foodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.im_undesirable_foodFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_undesirable_foodPayload>
          }
          findMany: {
            args: Prisma.im_undesirable_foodFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_undesirable_foodPayload>[]
          }
          create: {
            args: Prisma.im_undesirable_foodCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_undesirable_foodPayload>
          }
          createMany: {
            args: Prisma.im_undesirable_foodCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.im_undesirable_foodDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_undesirable_foodPayload>
          }
          update: {
            args: Prisma.im_undesirable_foodUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_undesirable_foodPayload>
          }
          deleteMany: {
            args: Prisma.im_undesirable_foodDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.im_undesirable_foodUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.im_undesirable_foodUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_undesirable_foodPayload>
          }
          aggregate: {
            args: Prisma.Im_undesirable_foodAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIm_undesirable_food>
          }
          groupBy: {
            args: Prisma.im_undesirable_foodGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Im_undesirable_foodGroupByOutputType>[]
          }
          count: {
            args: Prisma.im_undesirable_foodCountArgs<ExtArgs>,
            result: $Utils.Optional<Im_undesirable_foodCountAggregateOutputType> | number
          }
        }
      }
      im_user: {
        payload: Prisma.$im_userPayload<ExtArgs>
        fields: Prisma.im_userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.im_userFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.im_userFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_userPayload>
          }
          findFirst: {
            args: Prisma.im_userFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.im_userFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_userPayload>
          }
          findMany: {
            args: Prisma.im_userFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_userPayload>[]
          }
          create: {
            args: Prisma.im_userCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_userPayload>
          }
          createMany: {
            args: Prisma.im_userCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.im_userDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_userPayload>
          }
          update: {
            args: Prisma.im_userUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_userPayload>
          }
          deleteMany: {
            args: Prisma.im_userDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.im_userUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.im_userUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_userPayload>
          }
          aggregate: {
            args: Prisma.Im_userAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIm_user>
          }
          groupBy: {
            args: Prisma.im_userGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Im_userGroupByOutputType>[]
          }
          count: {
            args: Prisma.im_userCountArgs<ExtArgs>,
            result: $Utils.Optional<Im_userCountAggregateOutputType> | number
          }
        }
      }
      im_workout: {
        payload: Prisma.$im_workoutPayload<ExtArgs>
        fields: Prisma.im_workoutFieldRefs
        operations: {
          findUnique: {
            args: Prisma.im_workoutFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_workoutPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.im_workoutFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_workoutPayload>
          }
          findFirst: {
            args: Prisma.im_workoutFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_workoutPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.im_workoutFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_workoutPayload>
          }
          findMany: {
            args: Prisma.im_workoutFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_workoutPayload>[]
          }
          create: {
            args: Prisma.im_workoutCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_workoutPayload>
          }
          createMany: {
            args: Prisma.im_workoutCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.im_workoutDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_workoutPayload>
          }
          update: {
            args: Prisma.im_workoutUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_workoutPayload>
          }
          deleteMany: {
            args: Prisma.im_workoutDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.im_workoutUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.im_workoutUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$im_workoutPayload>
          }
          aggregate: {
            args: Prisma.Im_workoutAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIm_workout>
          }
          groupBy: {
            args: Prisma.im_workoutGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Im_workoutGroupByOutputType>[]
          }
          count: {
            args: Prisma.im_workoutCountArgs<ExtArgs>,
            result: $Utils.Optional<Im_workoutCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type Im_exerciseCountOutputType
   */

  export type Im_exerciseCountOutputType = {
    im_exercise_history: number
  }

  export type Im_exerciseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    im_exercise_history?: boolean | Im_exerciseCountOutputTypeCountIm_exercise_historyArgs
  }

  // Custom InputTypes

  /**
   * Im_exerciseCountOutputType without action
   */
  export type Im_exerciseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Im_exerciseCountOutputType
     */
    select?: Im_exerciseCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Im_exerciseCountOutputType without action
   */
  export type Im_exerciseCountOutputTypeCountIm_exercise_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: im_exercise_historyWhereInput
  }



  /**
   * Count Type Im_foodCountOutputType
   */

  export type Im_foodCountOutputType = {
    im_recipe: number
    im_undesirable_food: number
  }

  export type Im_foodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    im_recipe?: boolean | Im_foodCountOutputTypeCountIm_recipeArgs
    im_undesirable_food?: boolean | Im_foodCountOutputTypeCountIm_undesirable_foodArgs
  }

  // Custom InputTypes

  /**
   * Im_foodCountOutputType without action
   */
  export type Im_foodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Im_foodCountOutputType
     */
    select?: Im_foodCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Im_foodCountOutputType without action
   */
  export type Im_foodCountOutputTypeCountIm_recipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: im_recipeWhereInput
  }


  /**
   * Im_foodCountOutputType without action
   */
  export type Im_foodCountOutputTypeCountIm_undesirable_foodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: im_undesirable_foodWhereInput
  }



  /**
   * Count Type Im_healthCountOutputType
   */

  export type Im_healthCountOutputType = {
    im_health_goal: number
  }

  export type Im_healthCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    im_health_goal?: boolean | Im_healthCountOutputTypeCountIm_health_goalArgs
  }

  // Custom InputTypes

  /**
   * Im_healthCountOutputType without action
   */
  export type Im_healthCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Im_healthCountOutputType
     */
    select?: Im_healthCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Im_healthCountOutputType without action
   */
  export type Im_healthCountOutputTypeCountIm_health_goalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: im_health_goalWhereInput
  }



  /**
   * Count Type Im_health_goalCountOutputType
   */

  export type Im_health_goalCountOutputType = {
    im_health_goal_daily: number
  }

  export type Im_health_goalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    im_health_goal_daily?: boolean | Im_health_goalCountOutputTypeCountIm_health_goal_dailyArgs
  }

  // Custom InputTypes

  /**
   * Im_health_goalCountOutputType without action
   */
  export type Im_health_goalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Im_health_goalCountOutputType
     */
    select?: Im_health_goalCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Im_health_goalCountOutputType without action
   */
  export type Im_health_goalCountOutputTypeCountIm_health_goal_dailyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: im_health_goal_dailyWhereInput
  }



  /**
   * Count Type Im_health_goal_dailyCountOutputType
   */

  export type Im_health_goal_dailyCountOutputType = {
    im_health_goal_daily_history: number
  }

  export type Im_health_goal_dailyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    im_health_goal_daily_history?: boolean | Im_health_goal_dailyCountOutputTypeCountIm_health_goal_daily_historyArgs
  }

  // Custom InputTypes

  /**
   * Im_health_goal_dailyCountOutputType without action
   */
  export type Im_health_goal_dailyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Im_health_goal_dailyCountOutputType
     */
    select?: Im_health_goal_dailyCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Im_health_goal_dailyCountOutputType without action
   */
  export type Im_health_goal_dailyCountOutputTypeCountIm_health_goal_daily_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: im_health_goal_daily_historyWhereInput
  }



  /**
   * Count Type Im_mealCountOutputType
   */

  export type Im_mealCountOutputType = {
    im_recipe: number
  }

  export type Im_mealCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    im_recipe?: boolean | Im_mealCountOutputTypeCountIm_recipeArgs
  }

  // Custom InputTypes

  /**
   * Im_mealCountOutputType without action
   */
  export type Im_mealCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Im_mealCountOutputType
     */
    select?: Im_mealCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Im_mealCountOutputType without action
   */
  export type Im_mealCountOutputTypeCountIm_recipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: im_recipeWhereInput
  }



  /**
   * Count Type Im_nutritionCountOutputType
   */

  export type Im_nutritionCountOutputType = {
    im_meal: number
  }

  export type Im_nutritionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    im_meal?: boolean | Im_nutritionCountOutputTypeCountIm_mealArgs
  }

  // Custom InputTypes

  /**
   * Im_nutritionCountOutputType without action
   */
  export type Im_nutritionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Im_nutritionCountOutputType
     */
    select?: Im_nutritionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Im_nutritionCountOutputType without action
   */
  export type Im_nutritionCountOutputTypeCountIm_mealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: im_mealWhereInput
  }



  /**
   * Count Type Im_trainingCountOutputType
   */

  export type Im_trainingCountOutputType = {
    im_workout: number
  }

  export type Im_trainingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    im_workout?: boolean | Im_trainingCountOutputTypeCountIm_workoutArgs
  }

  // Custom InputTypes

  /**
   * Im_trainingCountOutputType without action
   */
  export type Im_trainingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Im_trainingCountOutputType
     */
    select?: Im_trainingCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Im_trainingCountOutputType without action
   */
  export type Im_trainingCountOutputTypeCountIm_workoutArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: im_workoutWhereInput
  }



  /**
   * Count Type Im_userCountOutputType
   */

  export type Im_userCountOutputType = {
    im_health: number
    im_nutrition: number
    im_training: number
    im_undesirable_food: number
  }

  export type Im_userCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    im_health?: boolean | Im_userCountOutputTypeCountIm_healthArgs
    im_nutrition?: boolean | Im_userCountOutputTypeCountIm_nutritionArgs
    im_training?: boolean | Im_userCountOutputTypeCountIm_trainingArgs
    im_undesirable_food?: boolean | Im_userCountOutputTypeCountIm_undesirable_foodArgs
  }

  // Custom InputTypes

  /**
   * Im_userCountOutputType without action
   */
  export type Im_userCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Im_userCountOutputType
     */
    select?: Im_userCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Im_userCountOutputType without action
   */
  export type Im_userCountOutputTypeCountIm_healthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: im_healthWhereInput
  }


  /**
   * Im_userCountOutputType without action
   */
  export type Im_userCountOutputTypeCountIm_nutritionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: im_nutritionWhereInput
  }


  /**
   * Im_userCountOutputType without action
   */
  export type Im_userCountOutputTypeCountIm_trainingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: im_trainingWhereInput
  }


  /**
   * Im_userCountOutputType without action
   */
  export type Im_userCountOutputTypeCountIm_undesirable_foodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: im_undesirable_foodWhereInput
  }



  /**
   * Count Type Im_workoutCountOutputType
   */

  export type Im_workoutCountOutputType = {
    im_exercise: number
  }

  export type Im_workoutCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    im_exercise?: boolean | Im_workoutCountOutputTypeCountIm_exerciseArgs
  }

  // Custom InputTypes

  /**
   * Im_workoutCountOutputType without action
   */
  export type Im_workoutCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Im_workoutCountOutputType
     */
    select?: Im_workoutCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Im_workoutCountOutputType without action
   */
  export type Im_workoutCountOutputTypeCountIm_exerciseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: im_exerciseWhereInput
  }



  /**
   * Models
   */

  /**
   * Model im_exercise
   */

  export type AggregateIm_exercise = {
    _count: Im_exerciseCountAggregateOutputType | null
    _avg: Im_exerciseAvgAggregateOutputType | null
    _sum: Im_exerciseSumAggregateOutputType | null
    _min: Im_exerciseMinAggregateOutputType | null
    _max: Im_exerciseMaxAggregateOutputType | null
  }

  export type Im_exerciseAvgAggregateOutputType = {
    id_exercise: number | null
    exercise_rest_time: number | null
    exercise_reps: number | null
    exercise_series: number | null
    id_workout: number | null
  }

  export type Im_exerciseSumAggregateOutputType = {
    id_exercise: number | null
    exercise_rest_time: number | null
    exercise_reps: number | null
    exercise_series: number | null
    id_workout: number | null
  }

  export type Im_exerciseMinAggregateOutputType = {
    id_exercise: number | null
    exercise_name: string | null
    exercise_type: string | null
    exercise_rest_time: number | null
    exercise_reps: number | null
    exercise_series: number | null
    exercise_description: string | null
    id_workout: number | null
  }

  export type Im_exerciseMaxAggregateOutputType = {
    id_exercise: number | null
    exercise_name: string | null
    exercise_type: string | null
    exercise_rest_time: number | null
    exercise_reps: number | null
    exercise_series: number | null
    exercise_description: string | null
    id_workout: number | null
  }

  export type Im_exerciseCountAggregateOutputType = {
    id_exercise: number
    exercise_name: number
    exercise_type: number
    exercise_rest_time: number
    exercise_reps: number
    exercise_series: number
    exercise_description: number
    id_workout: number
    _all: number
  }


  export type Im_exerciseAvgAggregateInputType = {
    id_exercise?: true
    exercise_rest_time?: true
    exercise_reps?: true
    exercise_series?: true
    id_workout?: true
  }

  export type Im_exerciseSumAggregateInputType = {
    id_exercise?: true
    exercise_rest_time?: true
    exercise_reps?: true
    exercise_series?: true
    id_workout?: true
  }

  export type Im_exerciseMinAggregateInputType = {
    id_exercise?: true
    exercise_name?: true
    exercise_type?: true
    exercise_rest_time?: true
    exercise_reps?: true
    exercise_series?: true
    exercise_description?: true
    id_workout?: true
  }

  export type Im_exerciseMaxAggregateInputType = {
    id_exercise?: true
    exercise_name?: true
    exercise_type?: true
    exercise_rest_time?: true
    exercise_reps?: true
    exercise_series?: true
    exercise_description?: true
    id_workout?: true
  }

  export type Im_exerciseCountAggregateInputType = {
    id_exercise?: true
    exercise_name?: true
    exercise_type?: true
    exercise_rest_time?: true
    exercise_reps?: true
    exercise_series?: true
    exercise_description?: true
    id_workout?: true
    _all?: true
  }

  export type Im_exerciseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which im_exercise to aggregate.
     */
    where?: im_exerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_exercises to fetch.
     */
    orderBy?: im_exerciseOrderByWithRelationInput | im_exerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: im_exerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned im_exercises
    **/
    _count?: true | Im_exerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Im_exerciseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Im_exerciseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Im_exerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Im_exerciseMaxAggregateInputType
  }

  export type GetIm_exerciseAggregateType<T extends Im_exerciseAggregateArgs> = {
        [P in keyof T & keyof AggregateIm_exercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIm_exercise[P]>
      : GetScalarType<T[P], AggregateIm_exercise[P]>
  }




  export type im_exerciseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: im_exerciseWhereInput
    orderBy?: im_exerciseOrderByWithAggregationInput | im_exerciseOrderByWithAggregationInput[]
    by: Im_exerciseScalarFieldEnum[] | Im_exerciseScalarFieldEnum
    having?: im_exerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Im_exerciseCountAggregateInputType | true
    _avg?: Im_exerciseAvgAggregateInputType
    _sum?: Im_exerciseSumAggregateInputType
    _min?: Im_exerciseMinAggregateInputType
    _max?: Im_exerciseMaxAggregateInputType
  }

  export type Im_exerciseGroupByOutputType = {
    id_exercise: number
    exercise_name: string
    exercise_type: string
    exercise_rest_time: number
    exercise_reps: number
    exercise_series: number
    exercise_description: string
    id_workout: number
    _count: Im_exerciseCountAggregateOutputType | null
    _avg: Im_exerciseAvgAggregateOutputType | null
    _sum: Im_exerciseSumAggregateOutputType | null
    _min: Im_exerciseMinAggregateOutputType | null
    _max: Im_exerciseMaxAggregateOutputType | null
  }

  type GetIm_exerciseGroupByPayload<T extends im_exerciseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Im_exerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Im_exerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Im_exerciseGroupByOutputType[P]>
            : GetScalarType<T[P], Im_exerciseGroupByOutputType[P]>
        }
      >
    >


  export type im_exerciseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_exercise?: boolean
    exercise_name?: boolean
    exercise_type?: boolean
    exercise_rest_time?: boolean
    exercise_reps?: boolean
    exercise_series?: boolean
    exercise_description?: boolean
    id_workout?: boolean
    im_workout?: boolean | im_workoutDefaultArgs<ExtArgs>
    im_exercise_history?: boolean | im_exercise$im_exercise_historyArgs<ExtArgs>
    _count?: boolean | Im_exerciseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["im_exercise"]>

  export type im_exerciseSelectScalar = {
    id_exercise?: boolean
    exercise_name?: boolean
    exercise_type?: boolean
    exercise_rest_time?: boolean
    exercise_reps?: boolean
    exercise_series?: boolean
    exercise_description?: boolean
    id_workout?: boolean
  }

  export type im_exerciseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    im_workout?: boolean | im_workoutDefaultArgs<ExtArgs>
    im_exercise_history?: boolean | im_exercise$im_exercise_historyArgs<ExtArgs>
    _count?: boolean | Im_exerciseCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $im_exercisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "im_exercise"
    objects: {
      im_workout: Prisma.$im_workoutPayload<ExtArgs>
      im_exercise_history: Prisma.$im_exercise_historyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_exercise: number
      exercise_name: string
      exercise_type: string
      exercise_rest_time: number
      exercise_reps: number
      exercise_series: number
      exercise_description: string
      id_workout: number
    }, ExtArgs["result"]["im_exercise"]>
    composites: {}
  }


  type im_exerciseGetPayload<S extends boolean | null | undefined | im_exerciseDefaultArgs> = $Result.GetResult<Prisma.$im_exercisePayload, S>

  type im_exerciseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<im_exerciseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Im_exerciseCountAggregateInputType | true
    }

  export interface im_exerciseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['im_exercise'], meta: { name: 'im_exercise' } }
    /**
     * Find zero or one Im_exercise that matches the filter.
     * @param {im_exerciseFindUniqueArgs} args - Arguments to find a Im_exercise
     * @example
     * // Get one Im_exercise
     * const im_exercise = await prisma.im_exercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends im_exerciseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, im_exerciseFindUniqueArgs<ExtArgs>>
    ): Prisma__im_exerciseClient<$Result.GetResult<Prisma.$im_exercisePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Im_exercise that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {im_exerciseFindUniqueOrThrowArgs} args - Arguments to find a Im_exercise
     * @example
     * // Get one Im_exercise
     * const im_exercise = await prisma.im_exercise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends im_exerciseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, im_exerciseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__im_exerciseClient<$Result.GetResult<Prisma.$im_exercisePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Im_exercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_exerciseFindFirstArgs} args - Arguments to find a Im_exercise
     * @example
     * // Get one Im_exercise
     * const im_exercise = await prisma.im_exercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends im_exerciseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, im_exerciseFindFirstArgs<ExtArgs>>
    ): Prisma__im_exerciseClient<$Result.GetResult<Prisma.$im_exercisePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Im_exercise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_exerciseFindFirstOrThrowArgs} args - Arguments to find a Im_exercise
     * @example
     * // Get one Im_exercise
     * const im_exercise = await prisma.im_exercise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends im_exerciseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, im_exerciseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__im_exerciseClient<$Result.GetResult<Prisma.$im_exercisePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Im_exercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_exerciseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Im_exercises
     * const im_exercises = await prisma.im_exercise.findMany()
     * 
     * // Get first 10 Im_exercises
     * const im_exercises = await prisma.im_exercise.findMany({ take: 10 })
     * 
     * // Only select the `id_exercise`
     * const im_exerciseWithId_exerciseOnly = await prisma.im_exercise.findMany({ select: { id_exercise: true } })
     * 
    **/
    findMany<T extends im_exerciseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_exerciseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$im_exercisePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Im_exercise.
     * @param {im_exerciseCreateArgs} args - Arguments to create a Im_exercise.
     * @example
     * // Create one Im_exercise
     * const Im_exercise = await prisma.im_exercise.create({
     *   data: {
     *     // ... data to create a Im_exercise
     *   }
     * })
     * 
    **/
    create<T extends im_exerciseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, im_exerciseCreateArgs<ExtArgs>>
    ): Prisma__im_exerciseClient<$Result.GetResult<Prisma.$im_exercisePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Im_exercises.
     *     @param {im_exerciseCreateManyArgs} args - Arguments to create many Im_exercises.
     *     @example
     *     // Create many Im_exercises
     *     const im_exercise = await prisma.im_exercise.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends im_exerciseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_exerciseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Im_exercise.
     * @param {im_exerciseDeleteArgs} args - Arguments to delete one Im_exercise.
     * @example
     * // Delete one Im_exercise
     * const Im_exercise = await prisma.im_exercise.delete({
     *   where: {
     *     // ... filter to delete one Im_exercise
     *   }
     * })
     * 
    **/
    delete<T extends im_exerciseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, im_exerciseDeleteArgs<ExtArgs>>
    ): Prisma__im_exerciseClient<$Result.GetResult<Prisma.$im_exercisePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Im_exercise.
     * @param {im_exerciseUpdateArgs} args - Arguments to update one Im_exercise.
     * @example
     * // Update one Im_exercise
     * const im_exercise = await prisma.im_exercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends im_exerciseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, im_exerciseUpdateArgs<ExtArgs>>
    ): Prisma__im_exerciseClient<$Result.GetResult<Prisma.$im_exercisePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Im_exercises.
     * @param {im_exerciseDeleteManyArgs} args - Arguments to filter Im_exercises to delete.
     * @example
     * // Delete a few Im_exercises
     * const { count } = await prisma.im_exercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends im_exerciseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_exerciseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Im_exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_exerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Im_exercises
     * const im_exercise = await prisma.im_exercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends im_exerciseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, im_exerciseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Im_exercise.
     * @param {im_exerciseUpsertArgs} args - Arguments to update or create a Im_exercise.
     * @example
     * // Update or create a Im_exercise
     * const im_exercise = await prisma.im_exercise.upsert({
     *   create: {
     *     // ... data to create a Im_exercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Im_exercise we want to update
     *   }
     * })
    **/
    upsert<T extends im_exerciseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, im_exerciseUpsertArgs<ExtArgs>>
    ): Prisma__im_exerciseClient<$Result.GetResult<Prisma.$im_exercisePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Im_exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_exerciseCountArgs} args - Arguments to filter Im_exercises to count.
     * @example
     * // Count the number of Im_exercises
     * const count = await prisma.im_exercise.count({
     *   where: {
     *     // ... the filter for the Im_exercises we want to count
     *   }
     * })
    **/
    count<T extends im_exerciseCountArgs>(
      args?: Subset<T, im_exerciseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Im_exerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Im_exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Im_exerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Im_exerciseAggregateArgs>(args: Subset<T, Im_exerciseAggregateArgs>): Prisma.PrismaPromise<GetIm_exerciseAggregateType<T>>

    /**
     * Group by Im_exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_exerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends im_exerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: im_exerciseGroupByArgs['orderBy'] }
        : { orderBy?: im_exerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, im_exerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIm_exerciseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the im_exercise model
   */
  readonly fields: im_exerciseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for im_exercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__im_exerciseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    im_workout<T extends im_workoutDefaultArgs<ExtArgs> = {}>(args?: Subset<T, im_workoutDefaultArgs<ExtArgs>>): Prisma__im_workoutClient<$Result.GetResult<Prisma.$im_workoutPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    im_exercise_history<T extends im_exercise$im_exercise_historyArgs<ExtArgs> = {}>(args?: Subset<T, im_exercise$im_exercise_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$im_exercise_historyPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the im_exercise model
   */ 
  interface im_exerciseFieldRefs {
    readonly id_exercise: FieldRef<"im_exercise", 'Int'>
    readonly exercise_name: FieldRef<"im_exercise", 'String'>
    readonly exercise_type: FieldRef<"im_exercise", 'String'>
    readonly exercise_rest_time: FieldRef<"im_exercise", 'Int'>
    readonly exercise_reps: FieldRef<"im_exercise", 'Int'>
    readonly exercise_series: FieldRef<"im_exercise", 'Int'>
    readonly exercise_description: FieldRef<"im_exercise", 'String'>
    readonly id_workout: FieldRef<"im_exercise", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * im_exercise findUnique
   */
  export type im_exerciseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_exercise
     */
    select?: im_exerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_exerciseInclude<ExtArgs> | null
    /**
     * Filter, which im_exercise to fetch.
     */
    where: im_exerciseWhereUniqueInput
  }


  /**
   * im_exercise findUniqueOrThrow
   */
  export type im_exerciseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_exercise
     */
    select?: im_exerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_exerciseInclude<ExtArgs> | null
    /**
     * Filter, which im_exercise to fetch.
     */
    where: im_exerciseWhereUniqueInput
  }


  /**
   * im_exercise findFirst
   */
  export type im_exerciseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_exercise
     */
    select?: im_exerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_exerciseInclude<ExtArgs> | null
    /**
     * Filter, which im_exercise to fetch.
     */
    where?: im_exerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_exercises to fetch.
     */
    orderBy?: im_exerciseOrderByWithRelationInput | im_exerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for im_exercises.
     */
    cursor?: im_exerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of im_exercises.
     */
    distinct?: Im_exerciseScalarFieldEnum | Im_exerciseScalarFieldEnum[]
  }


  /**
   * im_exercise findFirstOrThrow
   */
  export type im_exerciseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_exercise
     */
    select?: im_exerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_exerciseInclude<ExtArgs> | null
    /**
     * Filter, which im_exercise to fetch.
     */
    where?: im_exerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_exercises to fetch.
     */
    orderBy?: im_exerciseOrderByWithRelationInput | im_exerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for im_exercises.
     */
    cursor?: im_exerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of im_exercises.
     */
    distinct?: Im_exerciseScalarFieldEnum | Im_exerciseScalarFieldEnum[]
  }


  /**
   * im_exercise findMany
   */
  export type im_exerciseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_exercise
     */
    select?: im_exerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_exerciseInclude<ExtArgs> | null
    /**
     * Filter, which im_exercises to fetch.
     */
    where?: im_exerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_exercises to fetch.
     */
    orderBy?: im_exerciseOrderByWithRelationInput | im_exerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing im_exercises.
     */
    cursor?: im_exerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_exercises.
     */
    skip?: number
    distinct?: Im_exerciseScalarFieldEnum | Im_exerciseScalarFieldEnum[]
  }


  /**
   * im_exercise create
   */
  export type im_exerciseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_exercise
     */
    select?: im_exerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_exerciseInclude<ExtArgs> | null
    /**
     * The data needed to create a im_exercise.
     */
    data: XOR<im_exerciseCreateInput, im_exerciseUncheckedCreateInput>
  }


  /**
   * im_exercise createMany
   */
  export type im_exerciseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many im_exercises.
     */
    data: im_exerciseCreateManyInput | im_exerciseCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * im_exercise update
   */
  export type im_exerciseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_exercise
     */
    select?: im_exerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_exerciseInclude<ExtArgs> | null
    /**
     * The data needed to update a im_exercise.
     */
    data: XOR<im_exerciseUpdateInput, im_exerciseUncheckedUpdateInput>
    /**
     * Choose, which im_exercise to update.
     */
    where: im_exerciseWhereUniqueInput
  }


  /**
   * im_exercise updateMany
   */
  export type im_exerciseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update im_exercises.
     */
    data: XOR<im_exerciseUpdateManyMutationInput, im_exerciseUncheckedUpdateManyInput>
    /**
     * Filter which im_exercises to update
     */
    where?: im_exerciseWhereInput
  }


  /**
   * im_exercise upsert
   */
  export type im_exerciseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_exercise
     */
    select?: im_exerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_exerciseInclude<ExtArgs> | null
    /**
     * The filter to search for the im_exercise to update in case it exists.
     */
    where: im_exerciseWhereUniqueInput
    /**
     * In case the im_exercise found by the `where` argument doesn't exist, create a new im_exercise with this data.
     */
    create: XOR<im_exerciseCreateInput, im_exerciseUncheckedCreateInput>
    /**
     * In case the im_exercise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<im_exerciseUpdateInput, im_exerciseUncheckedUpdateInput>
  }


  /**
   * im_exercise delete
   */
  export type im_exerciseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_exercise
     */
    select?: im_exerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_exerciseInclude<ExtArgs> | null
    /**
     * Filter which im_exercise to delete.
     */
    where: im_exerciseWhereUniqueInput
  }


  /**
   * im_exercise deleteMany
   */
  export type im_exerciseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which im_exercises to delete
     */
    where?: im_exerciseWhereInput
  }


  /**
   * im_exercise.im_exercise_history
   */
  export type im_exercise$im_exercise_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_exercise_history
     */
    select?: im_exercise_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_exercise_historyInclude<ExtArgs> | null
    where?: im_exercise_historyWhereInput
    orderBy?: im_exercise_historyOrderByWithRelationInput | im_exercise_historyOrderByWithRelationInput[]
    cursor?: im_exercise_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Im_exercise_historyScalarFieldEnum | Im_exercise_historyScalarFieldEnum[]
  }


  /**
   * im_exercise without action
   */
  export type im_exerciseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_exercise
     */
    select?: im_exerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_exerciseInclude<ExtArgs> | null
  }



  /**
   * Model im_exercise_history
   */

  export type AggregateIm_exercise_history = {
    _count: Im_exercise_historyCountAggregateOutputType | null
    _avg: Im_exercise_historyAvgAggregateOutputType | null
    _sum: Im_exercise_historySumAggregateOutputType | null
    _min: Im_exercise_historyMinAggregateOutputType | null
    _max: Im_exercise_historyMaxAggregateOutputType | null
  }

  export type Im_exercise_historyAvgAggregateOutputType = {
    id_exercise_history: number | null
    id_exercise: number | null
  }

  export type Im_exercise_historySumAggregateOutputType = {
    id_exercise_history: number | null
    id_exercise: number | null
  }

  export type Im_exercise_historyMinAggregateOutputType = {
    id_exercise_history: number | null
    exercise_history_date: Date | null
    id_exercise: number | null
  }

  export type Im_exercise_historyMaxAggregateOutputType = {
    id_exercise_history: number | null
    exercise_history_date: Date | null
    id_exercise: number | null
  }

  export type Im_exercise_historyCountAggregateOutputType = {
    id_exercise_history: number
    exercise_history_date: number
    id_exercise: number
    _all: number
  }


  export type Im_exercise_historyAvgAggregateInputType = {
    id_exercise_history?: true
    id_exercise?: true
  }

  export type Im_exercise_historySumAggregateInputType = {
    id_exercise_history?: true
    id_exercise?: true
  }

  export type Im_exercise_historyMinAggregateInputType = {
    id_exercise_history?: true
    exercise_history_date?: true
    id_exercise?: true
  }

  export type Im_exercise_historyMaxAggregateInputType = {
    id_exercise_history?: true
    exercise_history_date?: true
    id_exercise?: true
  }

  export type Im_exercise_historyCountAggregateInputType = {
    id_exercise_history?: true
    exercise_history_date?: true
    id_exercise?: true
    _all?: true
  }

  export type Im_exercise_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which im_exercise_history to aggregate.
     */
    where?: im_exercise_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_exercise_histories to fetch.
     */
    orderBy?: im_exercise_historyOrderByWithRelationInput | im_exercise_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: im_exercise_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_exercise_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_exercise_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned im_exercise_histories
    **/
    _count?: true | Im_exercise_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Im_exercise_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Im_exercise_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Im_exercise_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Im_exercise_historyMaxAggregateInputType
  }

  export type GetIm_exercise_historyAggregateType<T extends Im_exercise_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateIm_exercise_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIm_exercise_history[P]>
      : GetScalarType<T[P], AggregateIm_exercise_history[P]>
  }




  export type im_exercise_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: im_exercise_historyWhereInput
    orderBy?: im_exercise_historyOrderByWithAggregationInput | im_exercise_historyOrderByWithAggregationInput[]
    by: Im_exercise_historyScalarFieldEnum[] | Im_exercise_historyScalarFieldEnum
    having?: im_exercise_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Im_exercise_historyCountAggregateInputType | true
    _avg?: Im_exercise_historyAvgAggregateInputType
    _sum?: Im_exercise_historySumAggregateInputType
    _min?: Im_exercise_historyMinAggregateInputType
    _max?: Im_exercise_historyMaxAggregateInputType
  }

  export type Im_exercise_historyGroupByOutputType = {
    id_exercise_history: number
    exercise_history_date: Date
    id_exercise: number
    _count: Im_exercise_historyCountAggregateOutputType | null
    _avg: Im_exercise_historyAvgAggregateOutputType | null
    _sum: Im_exercise_historySumAggregateOutputType | null
    _min: Im_exercise_historyMinAggregateOutputType | null
    _max: Im_exercise_historyMaxAggregateOutputType | null
  }

  type GetIm_exercise_historyGroupByPayload<T extends im_exercise_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Im_exercise_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Im_exercise_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Im_exercise_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Im_exercise_historyGroupByOutputType[P]>
        }
      >
    >


  export type im_exercise_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_exercise_history?: boolean
    exercise_history_date?: boolean
    id_exercise?: boolean
    im_exercise?: boolean | im_exerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["im_exercise_history"]>

  export type im_exercise_historySelectScalar = {
    id_exercise_history?: boolean
    exercise_history_date?: boolean
    id_exercise?: boolean
  }

  export type im_exercise_historyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    im_exercise?: boolean | im_exerciseDefaultArgs<ExtArgs>
  }


  export type $im_exercise_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "im_exercise_history"
    objects: {
      im_exercise: Prisma.$im_exercisePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_exercise_history: number
      exercise_history_date: Date
      id_exercise: number
    }, ExtArgs["result"]["im_exercise_history"]>
    composites: {}
  }


  type im_exercise_historyGetPayload<S extends boolean | null | undefined | im_exercise_historyDefaultArgs> = $Result.GetResult<Prisma.$im_exercise_historyPayload, S>

  type im_exercise_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<im_exercise_historyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Im_exercise_historyCountAggregateInputType | true
    }

  export interface im_exercise_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['im_exercise_history'], meta: { name: 'im_exercise_history' } }
    /**
     * Find zero or one Im_exercise_history that matches the filter.
     * @param {im_exercise_historyFindUniqueArgs} args - Arguments to find a Im_exercise_history
     * @example
     * // Get one Im_exercise_history
     * const im_exercise_history = await prisma.im_exercise_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends im_exercise_historyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, im_exercise_historyFindUniqueArgs<ExtArgs>>
    ): Prisma__im_exercise_historyClient<$Result.GetResult<Prisma.$im_exercise_historyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Im_exercise_history that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {im_exercise_historyFindUniqueOrThrowArgs} args - Arguments to find a Im_exercise_history
     * @example
     * // Get one Im_exercise_history
     * const im_exercise_history = await prisma.im_exercise_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends im_exercise_historyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, im_exercise_historyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__im_exercise_historyClient<$Result.GetResult<Prisma.$im_exercise_historyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Im_exercise_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_exercise_historyFindFirstArgs} args - Arguments to find a Im_exercise_history
     * @example
     * // Get one Im_exercise_history
     * const im_exercise_history = await prisma.im_exercise_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends im_exercise_historyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, im_exercise_historyFindFirstArgs<ExtArgs>>
    ): Prisma__im_exercise_historyClient<$Result.GetResult<Prisma.$im_exercise_historyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Im_exercise_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_exercise_historyFindFirstOrThrowArgs} args - Arguments to find a Im_exercise_history
     * @example
     * // Get one Im_exercise_history
     * const im_exercise_history = await prisma.im_exercise_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends im_exercise_historyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, im_exercise_historyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__im_exercise_historyClient<$Result.GetResult<Prisma.$im_exercise_historyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Im_exercise_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_exercise_historyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Im_exercise_histories
     * const im_exercise_histories = await prisma.im_exercise_history.findMany()
     * 
     * // Get first 10 Im_exercise_histories
     * const im_exercise_histories = await prisma.im_exercise_history.findMany({ take: 10 })
     * 
     * // Only select the `id_exercise_history`
     * const im_exercise_historyWithId_exercise_historyOnly = await prisma.im_exercise_history.findMany({ select: { id_exercise_history: true } })
     * 
    **/
    findMany<T extends im_exercise_historyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_exercise_historyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$im_exercise_historyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Im_exercise_history.
     * @param {im_exercise_historyCreateArgs} args - Arguments to create a Im_exercise_history.
     * @example
     * // Create one Im_exercise_history
     * const Im_exercise_history = await prisma.im_exercise_history.create({
     *   data: {
     *     // ... data to create a Im_exercise_history
     *   }
     * })
     * 
    **/
    create<T extends im_exercise_historyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, im_exercise_historyCreateArgs<ExtArgs>>
    ): Prisma__im_exercise_historyClient<$Result.GetResult<Prisma.$im_exercise_historyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Im_exercise_histories.
     *     @param {im_exercise_historyCreateManyArgs} args - Arguments to create many Im_exercise_histories.
     *     @example
     *     // Create many Im_exercise_histories
     *     const im_exercise_history = await prisma.im_exercise_history.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends im_exercise_historyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_exercise_historyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Im_exercise_history.
     * @param {im_exercise_historyDeleteArgs} args - Arguments to delete one Im_exercise_history.
     * @example
     * // Delete one Im_exercise_history
     * const Im_exercise_history = await prisma.im_exercise_history.delete({
     *   where: {
     *     // ... filter to delete one Im_exercise_history
     *   }
     * })
     * 
    **/
    delete<T extends im_exercise_historyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, im_exercise_historyDeleteArgs<ExtArgs>>
    ): Prisma__im_exercise_historyClient<$Result.GetResult<Prisma.$im_exercise_historyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Im_exercise_history.
     * @param {im_exercise_historyUpdateArgs} args - Arguments to update one Im_exercise_history.
     * @example
     * // Update one Im_exercise_history
     * const im_exercise_history = await prisma.im_exercise_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends im_exercise_historyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, im_exercise_historyUpdateArgs<ExtArgs>>
    ): Prisma__im_exercise_historyClient<$Result.GetResult<Prisma.$im_exercise_historyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Im_exercise_histories.
     * @param {im_exercise_historyDeleteManyArgs} args - Arguments to filter Im_exercise_histories to delete.
     * @example
     * // Delete a few Im_exercise_histories
     * const { count } = await prisma.im_exercise_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends im_exercise_historyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_exercise_historyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Im_exercise_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_exercise_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Im_exercise_histories
     * const im_exercise_history = await prisma.im_exercise_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends im_exercise_historyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, im_exercise_historyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Im_exercise_history.
     * @param {im_exercise_historyUpsertArgs} args - Arguments to update or create a Im_exercise_history.
     * @example
     * // Update or create a Im_exercise_history
     * const im_exercise_history = await prisma.im_exercise_history.upsert({
     *   create: {
     *     // ... data to create a Im_exercise_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Im_exercise_history we want to update
     *   }
     * })
    **/
    upsert<T extends im_exercise_historyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, im_exercise_historyUpsertArgs<ExtArgs>>
    ): Prisma__im_exercise_historyClient<$Result.GetResult<Prisma.$im_exercise_historyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Im_exercise_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_exercise_historyCountArgs} args - Arguments to filter Im_exercise_histories to count.
     * @example
     * // Count the number of Im_exercise_histories
     * const count = await prisma.im_exercise_history.count({
     *   where: {
     *     // ... the filter for the Im_exercise_histories we want to count
     *   }
     * })
    **/
    count<T extends im_exercise_historyCountArgs>(
      args?: Subset<T, im_exercise_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Im_exercise_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Im_exercise_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Im_exercise_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Im_exercise_historyAggregateArgs>(args: Subset<T, Im_exercise_historyAggregateArgs>): Prisma.PrismaPromise<GetIm_exercise_historyAggregateType<T>>

    /**
     * Group by Im_exercise_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_exercise_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends im_exercise_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: im_exercise_historyGroupByArgs['orderBy'] }
        : { orderBy?: im_exercise_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, im_exercise_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIm_exercise_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the im_exercise_history model
   */
  readonly fields: im_exercise_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for im_exercise_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__im_exercise_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    im_exercise<T extends im_exerciseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, im_exerciseDefaultArgs<ExtArgs>>): Prisma__im_exerciseClient<$Result.GetResult<Prisma.$im_exercisePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the im_exercise_history model
   */ 
  interface im_exercise_historyFieldRefs {
    readonly id_exercise_history: FieldRef<"im_exercise_history", 'Int'>
    readonly exercise_history_date: FieldRef<"im_exercise_history", 'DateTime'>
    readonly id_exercise: FieldRef<"im_exercise_history", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * im_exercise_history findUnique
   */
  export type im_exercise_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_exercise_history
     */
    select?: im_exercise_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_exercise_historyInclude<ExtArgs> | null
    /**
     * Filter, which im_exercise_history to fetch.
     */
    where: im_exercise_historyWhereUniqueInput
  }


  /**
   * im_exercise_history findUniqueOrThrow
   */
  export type im_exercise_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_exercise_history
     */
    select?: im_exercise_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_exercise_historyInclude<ExtArgs> | null
    /**
     * Filter, which im_exercise_history to fetch.
     */
    where: im_exercise_historyWhereUniqueInput
  }


  /**
   * im_exercise_history findFirst
   */
  export type im_exercise_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_exercise_history
     */
    select?: im_exercise_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_exercise_historyInclude<ExtArgs> | null
    /**
     * Filter, which im_exercise_history to fetch.
     */
    where?: im_exercise_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_exercise_histories to fetch.
     */
    orderBy?: im_exercise_historyOrderByWithRelationInput | im_exercise_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for im_exercise_histories.
     */
    cursor?: im_exercise_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_exercise_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_exercise_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of im_exercise_histories.
     */
    distinct?: Im_exercise_historyScalarFieldEnum | Im_exercise_historyScalarFieldEnum[]
  }


  /**
   * im_exercise_history findFirstOrThrow
   */
  export type im_exercise_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_exercise_history
     */
    select?: im_exercise_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_exercise_historyInclude<ExtArgs> | null
    /**
     * Filter, which im_exercise_history to fetch.
     */
    where?: im_exercise_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_exercise_histories to fetch.
     */
    orderBy?: im_exercise_historyOrderByWithRelationInput | im_exercise_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for im_exercise_histories.
     */
    cursor?: im_exercise_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_exercise_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_exercise_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of im_exercise_histories.
     */
    distinct?: Im_exercise_historyScalarFieldEnum | Im_exercise_historyScalarFieldEnum[]
  }


  /**
   * im_exercise_history findMany
   */
  export type im_exercise_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_exercise_history
     */
    select?: im_exercise_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_exercise_historyInclude<ExtArgs> | null
    /**
     * Filter, which im_exercise_histories to fetch.
     */
    where?: im_exercise_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_exercise_histories to fetch.
     */
    orderBy?: im_exercise_historyOrderByWithRelationInput | im_exercise_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing im_exercise_histories.
     */
    cursor?: im_exercise_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_exercise_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_exercise_histories.
     */
    skip?: number
    distinct?: Im_exercise_historyScalarFieldEnum | Im_exercise_historyScalarFieldEnum[]
  }


  /**
   * im_exercise_history create
   */
  export type im_exercise_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_exercise_history
     */
    select?: im_exercise_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_exercise_historyInclude<ExtArgs> | null
    /**
     * The data needed to create a im_exercise_history.
     */
    data: XOR<im_exercise_historyCreateInput, im_exercise_historyUncheckedCreateInput>
  }


  /**
   * im_exercise_history createMany
   */
  export type im_exercise_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many im_exercise_histories.
     */
    data: im_exercise_historyCreateManyInput | im_exercise_historyCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * im_exercise_history update
   */
  export type im_exercise_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_exercise_history
     */
    select?: im_exercise_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_exercise_historyInclude<ExtArgs> | null
    /**
     * The data needed to update a im_exercise_history.
     */
    data: XOR<im_exercise_historyUpdateInput, im_exercise_historyUncheckedUpdateInput>
    /**
     * Choose, which im_exercise_history to update.
     */
    where: im_exercise_historyWhereUniqueInput
  }


  /**
   * im_exercise_history updateMany
   */
  export type im_exercise_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update im_exercise_histories.
     */
    data: XOR<im_exercise_historyUpdateManyMutationInput, im_exercise_historyUncheckedUpdateManyInput>
    /**
     * Filter which im_exercise_histories to update
     */
    where?: im_exercise_historyWhereInput
  }


  /**
   * im_exercise_history upsert
   */
  export type im_exercise_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_exercise_history
     */
    select?: im_exercise_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_exercise_historyInclude<ExtArgs> | null
    /**
     * The filter to search for the im_exercise_history to update in case it exists.
     */
    where: im_exercise_historyWhereUniqueInput
    /**
     * In case the im_exercise_history found by the `where` argument doesn't exist, create a new im_exercise_history with this data.
     */
    create: XOR<im_exercise_historyCreateInput, im_exercise_historyUncheckedCreateInput>
    /**
     * In case the im_exercise_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<im_exercise_historyUpdateInput, im_exercise_historyUncheckedUpdateInput>
  }


  /**
   * im_exercise_history delete
   */
  export type im_exercise_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_exercise_history
     */
    select?: im_exercise_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_exercise_historyInclude<ExtArgs> | null
    /**
     * Filter which im_exercise_history to delete.
     */
    where: im_exercise_historyWhereUniqueInput
  }


  /**
   * im_exercise_history deleteMany
   */
  export type im_exercise_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which im_exercise_histories to delete
     */
    where?: im_exercise_historyWhereInput
  }


  /**
   * im_exercise_history without action
   */
  export type im_exercise_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_exercise_history
     */
    select?: im_exercise_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_exercise_historyInclude<ExtArgs> | null
  }



  /**
   * Model im_food
   */

  export type AggregateIm_food = {
    _count: Im_foodCountAggregateOutputType | null
    _avg: Im_foodAvgAggregateOutputType | null
    _sum: Im_foodSumAggregateOutputType | null
    _min: Im_foodMinAggregateOutputType | null
    _max: Im_foodMaxAggregateOutputType | null
  }

  export type Im_foodAvgAggregateOutputType = {
    id_food: number | null
    food_calories: number | null
    food_carbs: number | null
    food_prots: number | null
    food_fats: number | null
  }

  export type Im_foodSumAggregateOutputType = {
    id_food: number | null
    food_calories: number | null
    food_carbs: number | null
    food_prots: number | null
    food_fats: number | null
  }

  export type Im_foodMinAggregateOutputType = {
    id_food: number | null
    food_name: string | null
    food_type: string | null
    food_calories: number | null
    food_carbs: number | null
    food_prots: number | null
    food_fats: number | null
  }

  export type Im_foodMaxAggregateOutputType = {
    id_food: number | null
    food_name: string | null
    food_type: string | null
    food_calories: number | null
    food_carbs: number | null
    food_prots: number | null
    food_fats: number | null
  }

  export type Im_foodCountAggregateOutputType = {
    id_food: number
    food_name: number
    food_type: number
    food_calories: number
    food_carbs: number
    food_prots: number
    food_fats: number
    _all: number
  }


  export type Im_foodAvgAggregateInputType = {
    id_food?: true
    food_calories?: true
    food_carbs?: true
    food_prots?: true
    food_fats?: true
  }

  export type Im_foodSumAggregateInputType = {
    id_food?: true
    food_calories?: true
    food_carbs?: true
    food_prots?: true
    food_fats?: true
  }

  export type Im_foodMinAggregateInputType = {
    id_food?: true
    food_name?: true
    food_type?: true
    food_calories?: true
    food_carbs?: true
    food_prots?: true
    food_fats?: true
  }

  export type Im_foodMaxAggregateInputType = {
    id_food?: true
    food_name?: true
    food_type?: true
    food_calories?: true
    food_carbs?: true
    food_prots?: true
    food_fats?: true
  }

  export type Im_foodCountAggregateInputType = {
    id_food?: true
    food_name?: true
    food_type?: true
    food_calories?: true
    food_carbs?: true
    food_prots?: true
    food_fats?: true
    _all?: true
  }

  export type Im_foodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which im_food to aggregate.
     */
    where?: im_foodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_foods to fetch.
     */
    orderBy?: im_foodOrderByWithRelationInput | im_foodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: im_foodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_foods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned im_foods
    **/
    _count?: true | Im_foodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Im_foodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Im_foodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Im_foodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Im_foodMaxAggregateInputType
  }

  export type GetIm_foodAggregateType<T extends Im_foodAggregateArgs> = {
        [P in keyof T & keyof AggregateIm_food]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIm_food[P]>
      : GetScalarType<T[P], AggregateIm_food[P]>
  }




  export type im_foodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: im_foodWhereInput
    orderBy?: im_foodOrderByWithAggregationInput | im_foodOrderByWithAggregationInput[]
    by: Im_foodScalarFieldEnum[] | Im_foodScalarFieldEnum
    having?: im_foodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Im_foodCountAggregateInputType | true
    _avg?: Im_foodAvgAggregateInputType
    _sum?: Im_foodSumAggregateInputType
    _min?: Im_foodMinAggregateInputType
    _max?: Im_foodMaxAggregateInputType
  }

  export type Im_foodGroupByOutputType = {
    id_food: number
    food_name: string
    food_type: string
    food_calories: number
    food_carbs: number
    food_prots: number
    food_fats: number
    _count: Im_foodCountAggregateOutputType | null
    _avg: Im_foodAvgAggregateOutputType | null
    _sum: Im_foodSumAggregateOutputType | null
    _min: Im_foodMinAggregateOutputType | null
    _max: Im_foodMaxAggregateOutputType | null
  }

  type GetIm_foodGroupByPayload<T extends im_foodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Im_foodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Im_foodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Im_foodGroupByOutputType[P]>
            : GetScalarType<T[P], Im_foodGroupByOutputType[P]>
        }
      >
    >


  export type im_foodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_food?: boolean
    food_name?: boolean
    food_type?: boolean
    food_calories?: boolean
    food_carbs?: boolean
    food_prots?: boolean
    food_fats?: boolean
    im_recipe?: boolean | im_food$im_recipeArgs<ExtArgs>
    im_undesirable_food?: boolean | im_food$im_undesirable_foodArgs<ExtArgs>
    _count?: boolean | Im_foodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["im_food"]>

  export type im_foodSelectScalar = {
    id_food?: boolean
    food_name?: boolean
    food_type?: boolean
    food_calories?: boolean
    food_carbs?: boolean
    food_prots?: boolean
    food_fats?: boolean
  }

  export type im_foodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    im_recipe?: boolean | im_food$im_recipeArgs<ExtArgs>
    im_undesirable_food?: boolean | im_food$im_undesirable_foodArgs<ExtArgs>
    _count?: boolean | Im_foodCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $im_foodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "im_food"
    objects: {
      im_recipe: Prisma.$im_recipePayload<ExtArgs>[]
      im_undesirable_food: Prisma.$im_undesirable_foodPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_food: number
      food_name: string
      food_type: string
      food_calories: number
      food_carbs: number
      food_prots: number
      food_fats: number
    }, ExtArgs["result"]["im_food"]>
    composites: {}
  }


  type im_foodGetPayload<S extends boolean | null | undefined | im_foodDefaultArgs> = $Result.GetResult<Prisma.$im_foodPayload, S>

  type im_foodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<im_foodFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Im_foodCountAggregateInputType | true
    }

  export interface im_foodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['im_food'], meta: { name: 'im_food' } }
    /**
     * Find zero or one Im_food that matches the filter.
     * @param {im_foodFindUniqueArgs} args - Arguments to find a Im_food
     * @example
     * // Get one Im_food
     * const im_food = await prisma.im_food.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends im_foodFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, im_foodFindUniqueArgs<ExtArgs>>
    ): Prisma__im_foodClient<$Result.GetResult<Prisma.$im_foodPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Im_food that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {im_foodFindUniqueOrThrowArgs} args - Arguments to find a Im_food
     * @example
     * // Get one Im_food
     * const im_food = await prisma.im_food.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends im_foodFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, im_foodFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__im_foodClient<$Result.GetResult<Prisma.$im_foodPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Im_food that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_foodFindFirstArgs} args - Arguments to find a Im_food
     * @example
     * // Get one Im_food
     * const im_food = await prisma.im_food.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends im_foodFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, im_foodFindFirstArgs<ExtArgs>>
    ): Prisma__im_foodClient<$Result.GetResult<Prisma.$im_foodPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Im_food that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_foodFindFirstOrThrowArgs} args - Arguments to find a Im_food
     * @example
     * // Get one Im_food
     * const im_food = await prisma.im_food.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends im_foodFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, im_foodFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__im_foodClient<$Result.GetResult<Prisma.$im_foodPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Im_foods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_foodFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Im_foods
     * const im_foods = await prisma.im_food.findMany()
     * 
     * // Get first 10 Im_foods
     * const im_foods = await prisma.im_food.findMany({ take: 10 })
     * 
     * // Only select the `id_food`
     * const im_foodWithId_foodOnly = await prisma.im_food.findMany({ select: { id_food: true } })
     * 
    **/
    findMany<T extends im_foodFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_foodFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$im_foodPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Im_food.
     * @param {im_foodCreateArgs} args - Arguments to create a Im_food.
     * @example
     * // Create one Im_food
     * const Im_food = await prisma.im_food.create({
     *   data: {
     *     // ... data to create a Im_food
     *   }
     * })
     * 
    **/
    create<T extends im_foodCreateArgs<ExtArgs>>(
      args: SelectSubset<T, im_foodCreateArgs<ExtArgs>>
    ): Prisma__im_foodClient<$Result.GetResult<Prisma.$im_foodPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Im_foods.
     *     @param {im_foodCreateManyArgs} args - Arguments to create many Im_foods.
     *     @example
     *     // Create many Im_foods
     *     const im_food = await prisma.im_food.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends im_foodCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_foodCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Im_food.
     * @param {im_foodDeleteArgs} args - Arguments to delete one Im_food.
     * @example
     * // Delete one Im_food
     * const Im_food = await prisma.im_food.delete({
     *   where: {
     *     // ... filter to delete one Im_food
     *   }
     * })
     * 
    **/
    delete<T extends im_foodDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, im_foodDeleteArgs<ExtArgs>>
    ): Prisma__im_foodClient<$Result.GetResult<Prisma.$im_foodPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Im_food.
     * @param {im_foodUpdateArgs} args - Arguments to update one Im_food.
     * @example
     * // Update one Im_food
     * const im_food = await prisma.im_food.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends im_foodUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, im_foodUpdateArgs<ExtArgs>>
    ): Prisma__im_foodClient<$Result.GetResult<Prisma.$im_foodPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Im_foods.
     * @param {im_foodDeleteManyArgs} args - Arguments to filter Im_foods to delete.
     * @example
     * // Delete a few Im_foods
     * const { count } = await prisma.im_food.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends im_foodDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_foodDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Im_foods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_foodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Im_foods
     * const im_food = await prisma.im_food.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends im_foodUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, im_foodUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Im_food.
     * @param {im_foodUpsertArgs} args - Arguments to update or create a Im_food.
     * @example
     * // Update or create a Im_food
     * const im_food = await prisma.im_food.upsert({
     *   create: {
     *     // ... data to create a Im_food
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Im_food we want to update
     *   }
     * })
    **/
    upsert<T extends im_foodUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, im_foodUpsertArgs<ExtArgs>>
    ): Prisma__im_foodClient<$Result.GetResult<Prisma.$im_foodPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Im_foods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_foodCountArgs} args - Arguments to filter Im_foods to count.
     * @example
     * // Count the number of Im_foods
     * const count = await prisma.im_food.count({
     *   where: {
     *     // ... the filter for the Im_foods we want to count
     *   }
     * })
    **/
    count<T extends im_foodCountArgs>(
      args?: Subset<T, im_foodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Im_foodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Im_food.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Im_foodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Im_foodAggregateArgs>(args: Subset<T, Im_foodAggregateArgs>): Prisma.PrismaPromise<GetIm_foodAggregateType<T>>

    /**
     * Group by Im_food.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_foodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends im_foodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: im_foodGroupByArgs['orderBy'] }
        : { orderBy?: im_foodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, im_foodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIm_foodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the im_food model
   */
  readonly fields: im_foodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for im_food.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__im_foodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    im_recipe<T extends im_food$im_recipeArgs<ExtArgs> = {}>(args?: Subset<T, im_food$im_recipeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$im_recipePayload<ExtArgs>, T, 'findMany'> | Null>;

    im_undesirable_food<T extends im_food$im_undesirable_foodArgs<ExtArgs> = {}>(args?: Subset<T, im_food$im_undesirable_foodArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$im_undesirable_foodPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the im_food model
   */ 
  interface im_foodFieldRefs {
    readonly id_food: FieldRef<"im_food", 'Int'>
    readonly food_name: FieldRef<"im_food", 'String'>
    readonly food_type: FieldRef<"im_food", 'String'>
    readonly food_calories: FieldRef<"im_food", 'Int'>
    readonly food_carbs: FieldRef<"im_food", 'Int'>
    readonly food_prots: FieldRef<"im_food", 'Int'>
    readonly food_fats: FieldRef<"im_food", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * im_food findUnique
   */
  export type im_foodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_food
     */
    select?: im_foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_foodInclude<ExtArgs> | null
    /**
     * Filter, which im_food to fetch.
     */
    where: im_foodWhereUniqueInput
  }


  /**
   * im_food findUniqueOrThrow
   */
  export type im_foodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_food
     */
    select?: im_foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_foodInclude<ExtArgs> | null
    /**
     * Filter, which im_food to fetch.
     */
    where: im_foodWhereUniqueInput
  }


  /**
   * im_food findFirst
   */
  export type im_foodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_food
     */
    select?: im_foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_foodInclude<ExtArgs> | null
    /**
     * Filter, which im_food to fetch.
     */
    where?: im_foodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_foods to fetch.
     */
    orderBy?: im_foodOrderByWithRelationInput | im_foodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for im_foods.
     */
    cursor?: im_foodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_foods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of im_foods.
     */
    distinct?: Im_foodScalarFieldEnum | Im_foodScalarFieldEnum[]
  }


  /**
   * im_food findFirstOrThrow
   */
  export type im_foodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_food
     */
    select?: im_foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_foodInclude<ExtArgs> | null
    /**
     * Filter, which im_food to fetch.
     */
    where?: im_foodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_foods to fetch.
     */
    orderBy?: im_foodOrderByWithRelationInput | im_foodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for im_foods.
     */
    cursor?: im_foodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_foods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of im_foods.
     */
    distinct?: Im_foodScalarFieldEnum | Im_foodScalarFieldEnum[]
  }


  /**
   * im_food findMany
   */
  export type im_foodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_food
     */
    select?: im_foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_foodInclude<ExtArgs> | null
    /**
     * Filter, which im_foods to fetch.
     */
    where?: im_foodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_foods to fetch.
     */
    orderBy?: im_foodOrderByWithRelationInput | im_foodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing im_foods.
     */
    cursor?: im_foodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_foods.
     */
    skip?: number
    distinct?: Im_foodScalarFieldEnum | Im_foodScalarFieldEnum[]
  }


  /**
   * im_food create
   */
  export type im_foodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_food
     */
    select?: im_foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_foodInclude<ExtArgs> | null
    /**
     * The data needed to create a im_food.
     */
    data: XOR<im_foodCreateInput, im_foodUncheckedCreateInput>
  }


  /**
   * im_food createMany
   */
  export type im_foodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many im_foods.
     */
    data: im_foodCreateManyInput | im_foodCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * im_food update
   */
  export type im_foodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_food
     */
    select?: im_foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_foodInclude<ExtArgs> | null
    /**
     * The data needed to update a im_food.
     */
    data: XOR<im_foodUpdateInput, im_foodUncheckedUpdateInput>
    /**
     * Choose, which im_food to update.
     */
    where: im_foodWhereUniqueInput
  }


  /**
   * im_food updateMany
   */
  export type im_foodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update im_foods.
     */
    data: XOR<im_foodUpdateManyMutationInput, im_foodUncheckedUpdateManyInput>
    /**
     * Filter which im_foods to update
     */
    where?: im_foodWhereInput
  }


  /**
   * im_food upsert
   */
  export type im_foodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_food
     */
    select?: im_foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_foodInclude<ExtArgs> | null
    /**
     * The filter to search for the im_food to update in case it exists.
     */
    where: im_foodWhereUniqueInput
    /**
     * In case the im_food found by the `where` argument doesn't exist, create a new im_food with this data.
     */
    create: XOR<im_foodCreateInput, im_foodUncheckedCreateInput>
    /**
     * In case the im_food was found with the provided `where` argument, update it with this data.
     */
    update: XOR<im_foodUpdateInput, im_foodUncheckedUpdateInput>
  }


  /**
   * im_food delete
   */
  export type im_foodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_food
     */
    select?: im_foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_foodInclude<ExtArgs> | null
    /**
     * Filter which im_food to delete.
     */
    where: im_foodWhereUniqueInput
  }


  /**
   * im_food deleteMany
   */
  export type im_foodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which im_foods to delete
     */
    where?: im_foodWhereInput
  }


  /**
   * im_food.im_recipe
   */
  export type im_food$im_recipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_recipe
     */
    select?: im_recipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_recipeInclude<ExtArgs> | null
    where?: im_recipeWhereInput
    orderBy?: im_recipeOrderByWithRelationInput | im_recipeOrderByWithRelationInput[]
    cursor?: im_recipeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Im_recipeScalarFieldEnum | Im_recipeScalarFieldEnum[]
  }


  /**
   * im_food.im_undesirable_food
   */
  export type im_food$im_undesirable_foodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_undesirable_food
     */
    select?: im_undesirable_foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_undesirable_foodInclude<ExtArgs> | null
    where?: im_undesirable_foodWhereInput
    orderBy?: im_undesirable_foodOrderByWithRelationInput | im_undesirable_foodOrderByWithRelationInput[]
    cursor?: im_undesirable_foodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Im_undesirable_foodScalarFieldEnum | Im_undesirable_foodScalarFieldEnum[]
  }


  /**
   * im_food without action
   */
  export type im_foodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_food
     */
    select?: im_foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_foodInclude<ExtArgs> | null
  }



  /**
   * Model im_health
   */

  export type AggregateIm_health = {
    _count: Im_healthCountAggregateOutputType | null
    _avg: Im_healthAvgAggregateOutputType | null
    _sum: Im_healthSumAggregateOutputType | null
    _min: Im_healthMinAggregateOutputType | null
    _max: Im_healthMaxAggregateOutputType | null
  }

  export type Im_healthAvgAggregateOutputType = {
    id_health: number | null
    id_user: number | null
  }

  export type Im_healthSumAggregateOutputType = {
    id_health: number | null
    id_user: number | null
  }

  export type Im_healthMinAggregateOutputType = {
    id_health: number | null
    id_user: number | null
  }

  export type Im_healthMaxAggregateOutputType = {
    id_health: number | null
    id_user: number | null
  }

  export type Im_healthCountAggregateOutputType = {
    id_health: number
    id_user: number
    _all: number
  }


  export type Im_healthAvgAggregateInputType = {
    id_health?: true
    id_user?: true
  }

  export type Im_healthSumAggregateInputType = {
    id_health?: true
    id_user?: true
  }

  export type Im_healthMinAggregateInputType = {
    id_health?: true
    id_user?: true
  }

  export type Im_healthMaxAggregateInputType = {
    id_health?: true
    id_user?: true
  }

  export type Im_healthCountAggregateInputType = {
    id_health?: true
    id_user?: true
    _all?: true
  }

  export type Im_healthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which im_health to aggregate.
     */
    where?: im_healthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_healths to fetch.
     */
    orderBy?: im_healthOrderByWithRelationInput | im_healthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: im_healthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_healths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_healths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned im_healths
    **/
    _count?: true | Im_healthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Im_healthAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Im_healthSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Im_healthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Im_healthMaxAggregateInputType
  }

  export type GetIm_healthAggregateType<T extends Im_healthAggregateArgs> = {
        [P in keyof T & keyof AggregateIm_health]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIm_health[P]>
      : GetScalarType<T[P], AggregateIm_health[P]>
  }




  export type im_healthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: im_healthWhereInput
    orderBy?: im_healthOrderByWithAggregationInput | im_healthOrderByWithAggregationInput[]
    by: Im_healthScalarFieldEnum[] | Im_healthScalarFieldEnum
    having?: im_healthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Im_healthCountAggregateInputType | true
    _avg?: Im_healthAvgAggregateInputType
    _sum?: Im_healthSumAggregateInputType
    _min?: Im_healthMinAggregateInputType
    _max?: Im_healthMaxAggregateInputType
  }

  export type Im_healthGroupByOutputType = {
    id_health: number
    id_user: number
    _count: Im_healthCountAggregateOutputType | null
    _avg: Im_healthAvgAggregateOutputType | null
    _sum: Im_healthSumAggregateOutputType | null
    _min: Im_healthMinAggregateOutputType | null
    _max: Im_healthMaxAggregateOutputType | null
  }

  type GetIm_healthGroupByPayload<T extends im_healthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Im_healthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Im_healthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Im_healthGroupByOutputType[P]>
            : GetScalarType<T[P], Im_healthGroupByOutputType[P]>
        }
      >
    >


  export type im_healthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_health?: boolean
    id_user?: boolean
    im_user?: boolean | im_userDefaultArgs<ExtArgs>
    im_health_goal?: boolean | im_health$im_health_goalArgs<ExtArgs>
    _count?: boolean | Im_healthCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["im_health"]>

  export type im_healthSelectScalar = {
    id_health?: boolean
    id_user?: boolean
  }

  export type im_healthInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    im_user?: boolean | im_userDefaultArgs<ExtArgs>
    im_health_goal?: boolean | im_health$im_health_goalArgs<ExtArgs>
    _count?: boolean | Im_healthCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $im_healthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "im_health"
    objects: {
      im_user: Prisma.$im_userPayload<ExtArgs>
      im_health_goal: Prisma.$im_health_goalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_health: number
      id_user: number
    }, ExtArgs["result"]["im_health"]>
    composites: {}
  }


  type im_healthGetPayload<S extends boolean | null | undefined | im_healthDefaultArgs> = $Result.GetResult<Prisma.$im_healthPayload, S>

  type im_healthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<im_healthFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Im_healthCountAggregateInputType | true
    }

  export interface im_healthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['im_health'], meta: { name: 'im_health' } }
    /**
     * Find zero or one Im_health that matches the filter.
     * @param {im_healthFindUniqueArgs} args - Arguments to find a Im_health
     * @example
     * // Get one Im_health
     * const im_health = await prisma.im_health.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends im_healthFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, im_healthFindUniqueArgs<ExtArgs>>
    ): Prisma__im_healthClient<$Result.GetResult<Prisma.$im_healthPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Im_health that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {im_healthFindUniqueOrThrowArgs} args - Arguments to find a Im_health
     * @example
     * // Get one Im_health
     * const im_health = await prisma.im_health.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends im_healthFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, im_healthFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__im_healthClient<$Result.GetResult<Prisma.$im_healthPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Im_health that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_healthFindFirstArgs} args - Arguments to find a Im_health
     * @example
     * // Get one Im_health
     * const im_health = await prisma.im_health.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends im_healthFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, im_healthFindFirstArgs<ExtArgs>>
    ): Prisma__im_healthClient<$Result.GetResult<Prisma.$im_healthPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Im_health that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_healthFindFirstOrThrowArgs} args - Arguments to find a Im_health
     * @example
     * // Get one Im_health
     * const im_health = await prisma.im_health.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends im_healthFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, im_healthFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__im_healthClient<$Result.GetResult<Prisma.$im_healthPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Im_healths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_healthFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Im_healths
     * const im_healths = await prisma.im_health.findMany()
     * 
     * // Get first 10 Im_healths
     * const im_healths = await prisma.im_health.findMany({ take: 10 })
     * 
     * // Only select the `id_health`
     * const im_healthWithId_healthOnly = await prisma.im_health.findMany({ select: { id_health: true } })
     * 
    **/
    findMany<T extends im_healthFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_healthFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$im_healthPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Im_health.
     * @param {im_healthCreateArgs} args - Arguments to create a Im_health.
     * @example
     * // Create one Im_health
     * const Im_health = await prisma.im_health.create({
     *   data: {
     *     // ... data to create a Im_health
     *   }
     * })
     * 
    **/
    create<T extends im_healthCreateArgs<ExtArgs>>(
      args: SelectSubset<T, im_healthCreateArgs<ExtArgs>>
    ): Prisma__im_healthClient<$Result.GetResult<Prisma.$im_healthPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Im_healths.
     *     @param {im_healthCreateManyArgs} args - Arguments to create many Im_healths.
     *     @example
     *     // Create many Im_healths
     *     const im_health = await prisma.im_health.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends im_healthCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_healthCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Im_health.
     * @param {im_healthDeleteArgs} args - Arguments to delete one Im_health.
     * @example
     * // Delete one Im_health
     * const Im_health = await prisma.im_health.delete({
     *   where: {
     *     // ... filter to delete one Im_health
     *   }
     * })
     * 
    **/
    delete<T extends im_healthDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, im_healthDeleteArgs<ExtArgs>>
    ): Prisma__im_healthClient<$Result.GetResult<Prisma.$im_healthPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Im_health.
     * @param {im_healthUpdateArgs} args - Arguments to update one Im_health.
     * @example
     * // Update one Im_health
     * const im_health = await prisma.im_health.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends im_healthUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, im_healthUpdateArgs<ExtArgs>>
    ): Prisma__im_healthClient<$Result.GetResult<Prisma.$im_healthPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Im_healths.
     * @param {im_healthDeleteManyArgs} args - Arguments to filter Im_healths to delete.
     * @example
     * // Delete a few Im_healths
     * const { count } = await prisma.im_health.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends im_healthDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_healthDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Im_healths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_healthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Im_healths
     * const im_health = await prisma.im_health.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends im_healthUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, im_healthUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Im_health.
     * @param {im_healthUpsertArgs} args - Arguments to update or create a Im_health.
     * @example
     * // Update or create a Im_health
     * const im_health = await prisma.im_health.upsert({
     *   create: {
     *     // ... data to create a Im_health
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Im_health we want to update
     *   }
     * })
    **/
    upsert<T extends im_healthUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, im_healthUpsertArgs<ExtArgs>>
    ): Prisma__im_healthClient<$Result.GetResult<Prisma.$im_healthPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Im_healths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_healthCountArgs} args - Arguments to filter Im_healths to count.
     * @example
     * // Count the number of Im_healths
     * const count = await prisma.im_health.count({
     *   where: {
     *     // ... the filter for the Im_healths we want to count
     *   }
     * })
    **/
    count<T extends im_healthCountArgs>(
      args?: Subset<T, im_healthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Im_healthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Im_health.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Im_healthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Im_healthAggregateArgs>(args: Subset<T, Im_healthAggregateArgs>): Prisma.PrismaPromise<GetIm_healthAggregateType<T>>

    /**
     * Group by Im_health.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_healthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends im_healthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: im_healthGroupByArgs['orderBy'] }
        : { orderBy?: im_healthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, im_healthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIm_healthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the im_health model
   */
  readonly fields: im_healthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for im_health.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__im_healthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    im_user<T extends im_userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, im_userDefaultArgs<ExtArgs>>): Prisma__im_userClient<$Result.GetResult<Prisma.$im_userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    im_health_goal<T extends im_health$im_health_goalArgs<ExtArgs> = {}>(args?: Subset<T, im_health$im_health_goalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$im_health_goalPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the im_health model
   */ 
  interface im_healthFieldRefs {
    readonly id_health: FieldRef<"im_health", 'Int'>
    readonly id_user: FieldRef<"im_health", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * im_health findUnique
   */
  export type im_healthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health
     */
    select?: im_healthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_healthInclude<ExtArgs> | null
    /**
     * Filter, which im_health to fetch.
     */
    where: im_healthWhereUniqueInput
  }


  /**
   * im_health findUniqueOrThrow
   */
  export type im_healthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health
     */
    select?: im_healthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_healthInclude<ExtArgs> | null
    /**
     * Filter, which im_health to fetch.
     */
    where: im_healthWhereUniqueInput
  }


  /**
   * im_health findFirst
   */
  export type im_healthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health
     */
    select?: im_healthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_healthInclude<ExtArgs> | null
    /**
     * Filter, which im_health to fetch.
     */
    where?: im_healthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_healths to fetch.
     */
    orderBy?: im_healthOrderByWithRelationInput | im_healthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for im_healths.
     */
    cursor?: im_healthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_healths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_healths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of im_healths.
     */
    distinct?: Im_healthScalarFieldEnum | Im_healthScalarFieldEnum[]
  }


  /**
   * im_health findFirstOrThrow
   */
  export type im_healthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health
     */
    select?: im_healthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_healthInclude<ExtArgs> | null
    /**
     * Filter, which im_health to fetch.
     */
    where?: im_healthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_healths to fetch.
     */
    orderBy?: im_healthOrderByWithRelationInput | im_healthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for im_healths.
     */
    cursor?: im_healthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_healths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_healths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of im_healths.
     */
    distinct?: Im_healthScalarFieldEnum | Im_healthScalarFieldEnum[]
  }


  /**
   * im_health findMany
   */
  export type im_healthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health
     */
    select?: im_healthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_healthInclude<ExtArgs> | null
    /**
     * Filter, which im_healths to fetch.
     */
    where?: im_healthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_healths to fetch.
     */
    orderBy?: im_healthOrderByWithRelationInput | im_healthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing im_healths.
     */
    cursor?: im_healthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_healths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_healths.
     */
    skip?: number
    distinct?: Im_healthScalarFieldEnum | Im_healthScalarFieldEnum[]
  }


  /**
   * im_health create
   */
  export type im_healthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health
     */
    select?: im_healthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_healthInclude<ExtArgs> | null
    /**
     * The data needed to create a im_health.
     */
    data: XOR<im_healthCreateInput, im_healthUncheckedCreateInput>
  }


  /**
   * im_health createMany
   */
  export type im_healthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many im_healths.
     */
    data: im_healthCreateManyInput | im_healthCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * im_health update
   */
  export type im_healthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health
     */
    select?: im_healthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_healthInclude<ExtArgs> | null
    /**
     * The data needed to update a im_health.
     */
    data: XOR<im_healthUpdateInput, im_healthUncheckedUpdateInput>
    /**
     * Choose, which im_health to update.
     */
    where: im_healthWhereUniqueInput
  }


  /**
   * im_health updateMany
   */
  export type im_healthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update im_healths.
     */
    data: XOR<im_healthUpdateManyMutationInput, im_healthUncheckedUpdateManyInput>
    /**
     * Filter which im_healths to update
     */
    where?: im_healthWhereInput
  }


  /**
   * im_health upsert
   */
  export type im_healthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health
     */
    select?: im_healthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_healthInclude<ExtArgs> | null
    /**
     * The filter to search for the im_health to update in case it exists.
     */
    where: im_healthWhereUniqueInput
    /**
     * In case the im_health found by the `where` argument doesn't exist, create a new im_health with this data.
     */
    create: XOR<im_healthCreateInput, im_healthUncheckedCreateInput>
    /**
     * In case the im_health was found with the provided `where` argument, update it with this data.
     */
    update: XOR<im_healthUpdateInput, im_healthUncheckedUpdateInput>
  }


  /**
   * im_health delete
   */
  export type im_healthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health
     */
    select?: im_healthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_healthInclude<ExtArgs> | null
    /**
     * Filter which im_health to delete.
     */
    where: im_healthWhereUniqueInput
  }


  /**
   * im_health deleteMany
   */
  export type im_healthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which im_healths to delete
     */
    where?: im_healthWhereInput
  }


  /**
   * im_health.im_health_goal
   */
  export type im_health$im_health_goalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal
     */
    select?: im_health_goalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goalInclude<ExtArgs> | null
    where?: im_health_goalWhereInput
    orderBy?: im_health_goalOrderByWithRelationInput | im_health_goalOrderByWithRelationInput[]
    cursor?: im_health_goalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Im_health_goalScalarFieldEnum | Im_health_goalScalarFieldEnum[]
  }


  /**
   * im_health without action
   */
  export type im_healthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health
     */
    select?: im_healthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_healthInclude<ExtArgs> | null
  }



  /**
   * Model im_health_goal
   */

  export type AggregateIm_health_goal = {
    _count: Im_health_goalCountAggregateOutputType | null
    _avg: Im_health_goalAvgAggregateOutputType | null
    _sum: Im_health_goalSumAggregateOutputType | null
    _min: Im_health_goalMinAggregateOutputType | null
    _max: Im_health_goalMaxAggregateOutputType | null
  }

  export type Im_health_goalAvgAggregateOutputType = {
    id_health_goal: number | null
    health_goal_steps: number | null
    health_goal_weight: number | null
    health_goal_sleep: number | null
    health_goal_water: number | null
    id_health: number | null
  }

  export type Im_health_goalSumAggregateOutputType = {
    id_health_goal: number | null
    health_goal_steps: number | null
    health_goal_weight: number | null
    health_goal_sleep: number | null
    health_goal_water: number | null
    id_health: number | null
  }

  export type Im_health_goalMinAggregateOutputType = {
    id_health_goal: number | null
    health_goal_steps: number | null
    health_goal_weight: number | null
    health_goal_sleep: number | null
    health_goal_water: number | null
    id_health: number | null
  }

  export type Im_health_goalMaxAggregateOutputType = {
    id_health_goal: number | null
    health_goal_steps: number | null
    health_goal_weight: number | null
    health_goal_sleep: number | null
    health_goal_water: number | null
    id_health: number | null
  }

  export type Im_health_goalCountAggregateOutputType = {
    id_health_goal: number
    health_goal_steps: number
    health_goal_weight: number
    health_goal_sleep: number
    health_goal_water: number
    id_health: number
    _all: number
  }


  export type Im_health_goalAvgAggregateInputType = {
    id_health_goal?: true
    health_goal_steps?: true
    health_goal_weight?: true
    health_goal_sleep?: true
    health_goal_water?: true
    id_health?: true
  }

  export type Im_health_goalSumAggregateInputType = {
    id_health_goal?: true
    health_goal_steps?: true
    health_goal_weight?: true
    health_goal_sleep?: true
    health_goal_water?: true
    id_health?: true
  }

  export type Im_health_goalMinAggregateInputType = {
    id_health_goal?: true
    health_goal_steps?: true
    health_goal_weight?: true
    health_goal_sleep?: true
    health_goal_water?: true
    id_health?: true
  }

  export type Im_health_goalMaxAggregateInputType = {
    id_health_goal?: true
    health_goal_steps?: true
    health_goal_weight?: true
    health_goal_sleep?: true
    health_goal_water?: true
    id_health?: true
  }

  export type Im_health_goalCountAggregateInputType = {
    id_health_goal?: true
    health_goal_steps?: true
    health_goal_weight?: true
    health_goal_sleep?: true
    health_goal_water?: true
    id_health?: true
    _all?: true
  }

  export type Im_health_goalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which im_health_goal to aggregate.
     */
    where?: im_health_goalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_health_goals to fetch.
     */
    orderBy?: im_health_goalOrderByWithRelationInput | im_health_goalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: im_health_goalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_health_goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_health_goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned im_health_goals
    **/
    _count?: true | Im_health_goalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Im_health_goalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Im_health_goalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Im_health_goalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Im_health_goalMaxAggregateInputType
  }

  export type GetIm_health_goalAggregateType<T extends Im_health_goalAggregateArgs> = {
        [P in keyof T & keyof AggregateIm_health_goal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIm_health_goal[P]>
      : GetScalarType<T[P], AggregateIm_health_goal[P]>
  }




  export type im_health_goalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: im_health_goalWhereInput
    orderBy?: im_health_goalOrderByWithAggregationInput | im_health_goalOrderByWithAggregationInput[]
    by: Im_health_goalScalarFieldEnum[] | Im_health_goalScalarFieldEnum
    having?: im_health_goalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Im_health_goalCountAggregateInputType | true
    _avg?: Im_health_goalAvgAggregateInputType
    _sum?: Im_health_goalSumAggregateInputType
    _min?: Im_health_goalMinAggregateInputType
    _max?: Im_health_goalMaxAggregateInputType
  }

  export type Im_health_goalGroupByOutputType = {
    id_health_goal: number
    health_goal_steps: number
    health_goal_weight: number
    health_goal_sleep: number
    health_goal_water: number
    id_health: number
    _count: Im_health_goalCountAggregateOutputType | null
    _avg: Im_health_goalAvgAggregateOutputType | null
    _sum: Im_health_goalSumAggregateOutputType | null
    _min: Im_health_goalMinAggregateOutputType | null
    _max: Im_health_goalMaxAggregateOutputType | null
  }

  type GetIm_health_goalGroupByPayload<T extends im_health_goalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Im_health_goalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Im_health_goalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Im_health_goalGroupByOutputType[P]>
            : GetScalarType<T[P], Im_health_goalGroupByOutputType[P]>
        }
      >
    >


  export type im_health_goalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_health_goal?: boolean
    health_goal_steps?: boolean
    health_goal_weight?: boolean
    health_goal_sleep?: boolean
    health_goal_water?: boolean
    id_health?: boolean
    im_health?: boolean | im_healthDefaultArgs<ExtArgs>
    im_health_goal_daily?: boolean | im_health_goal$im_health_goal_dailyArgs<ExtArgs>
    _count?: boolean | Im_health_goalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["im_health_goal"]>

  export type im_health_goalSelectScalar = {
    id_health_goal?: boolean
    health_goal_steps?: boolean
    health_goal_weight?: boolean
    health_goal_sleep?: boolean
    health_goal_water?: boolean
    id_health?: boolean
  }

  export type im_health_goalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    im_health?: boolean | im_healthDefaultArgs<ExtArgs>
    im_health_goal_daily?: boolean | im_health_goal$im_health_goal_dailyArgs<ExtArgs>
    _count?: boolean | Im_health_goalCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $im_health_goalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "im_health_goal"
    objects: {
      im_health: Prisma.$im_healthPayload<ExtArgs>
      im_health_goal_daily: Prisma.$im_health_goal_dailyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_health_goal: number
      health_goal_steps: number
      health_goal_weight: number
      health_goal_sleep: number
      health_goal_water: number
      id_health: number
    }, ExtArgs["result"]["im_health_goal"]>
    composites: {}
  }


  type im_health_goalGetPayload<S extends boolean | null | undefined | im_health_goalDefaultArgs> = $Result.GetResult<Prisma.$im_health_goalPayload, S>

  type im_health_goalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<im_health_goalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Im_health_goalCountAggregateInputType | true
    }

  export interface im_health_goalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['im_health_goal'], meta: { name: 'im_health_goal' } }
    /**
     * Find zero or one Im_health_goal that matches the filter.
     * @param {im_health_goalFindUniqueArgs} args - Arguments to find a Im_health_goal
     * @example
     * // Get one Im_health_goal
     * const im_health_goal = await prisma.im_health_goal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends im_health_goalFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, im_health_goalFindUniqueArgs<ExtArgs>>
    ): Prisma__im_health_goalClient<$Result.GetResult<Prisma.$im_health_goalPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Im_health_goal that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {im_health_goalFindUniqueOrThrowArgs} args - Arguments to find a Im_health_goal
     * @example
     * // Get one Im_health_goal
     * const im_health_goal = await prisma.im_health_goal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends im_health_goalFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, im_health_goalFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__im_health_goalClient<$Result.GetResult<Prisma.$im_health_goalPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Im_health_goal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_health_goalFindFirstArgs} args - Arguments to find a Im_health_goal
     * @example
     * // Get one Im_health_goal
     * const im_health_goal = await prisma.im_health_goal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends im_health_goalFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, im_health_goalFindFirstArgs<ExtArgs>>
    ): Prisma__im_health_goalClient<$Result.GetResult<Prisma.$im_health_goalPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Im_health_goal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_health_goalFindFirstOrThrowArgs} args - Arguments to find a Im_health_goal
     * @example
     * // Get one Im_health_goal
     * const im_health_goal = await prisma.im_health_goal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends im_health_goalFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, im_health_goalFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__im_health_goalClient<$Result.GetResult<Prisma.$im_health_goalPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Im_health_goals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_health_goalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Im_health_goals
     * const im_health_goals = await prisma.im_health_goal.findMany()
     * 
     * // Get first 10 Im_health_goals
     * const im_health_goals = await prisma.im_health_goal.findMany({ take: 10 })
     * 
     * // Only select the `id_health_goal`
     * const im_health_goalWithId_health_goalOnly = await prisma.im_health_goal.findMany({ select: { id_health_goal: true } })
     * 
    **/
    findMany<T extends im_health_goalFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_health_goalFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$im_health_goalPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Im_health_goal.
     * @param {im_health_goalCreateArgs} args - Arguments to create a Im_health_goal.
     * @example
     * // Create one Im_health_goal
     * const Im_health_goal = await prisma.im_health_goal.create({
     *   data: {
     *     // ... data to create a Im_health_goal
     *   }
     * })
     * 
    **/
    create<T extends im_health_goalCreateArgs<ExtArgs>>(
      args: SelectSubset<T, im_health_goalCreateArgs<ExtArgs>>
    ): Prisma__im_health_goalClient<$Result.GetResult<Prisma.$im_health_goalPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Im_health_goals.
     *     @param {im_health_goalCreateManyArgs} args - Arguments to create many Im_health_goals.
     *     @example
     *     // Create many Im_health_goals
     *     const im_health_goal = await prisma.im_health_goal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends im_health_goalCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_health_goalCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Im_health_goal.
     * @param {im_health_goalDeleteArgs} args - Arguments to delete one Im_health_goal.
     * @example
     * // Delete one Im_health_goal
     * const Im_health_goal = await prisma.im_health_goal.delete({
     *   where: {
     *     // ... filter to delete one Im_health_goal
     *   }
     * })
     * 
    **/
    delete<T extends im_health_goalDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, im_health_goalDeleteArgs<ExtArgs>>
    ): Prisma__im_health_goalClient<$Result.GetResult<Prisma.$im_health_goalPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Im_health_goal.
     * @param {im_health_goalUpdateArgs} args - Arguments to update one Im_health_goal.
     * @example
     * // Update one Im_health_goal
     * const im_health_goal = await prisma.im_health_goal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends im_health_goalUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, im_health_goalUpdateArgs<ExtArgs>>
    ): Prisma__im_health_goalClient<$Result.GetResult<Prisma.$im_health_goalPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Im_health_goals.
     * @param {im_health_goalDeleteManyArgs} args - Arguments to filter Im_health_goals to delete.
     * @example
     * // Delete a few Im_health_goals
     * const { count } = await prisma.im_health_goal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends im_health_goalDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_health_goalDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Im_health_goals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_health_goalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Im_health_goals
     * const im_health_goal = await prisma.im_health_goal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends im_health_goalUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, im_health_goalUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Im_health_goal.
     * @param {im_health_goalUpsertArgs} args - Arguments to update or create a Im_health_goal.
     * @example
     * // Update or create a Im_health_goal
     * const im_health_goal = await prisma.im_health_goal.upsert({
     *   create: {
     *     // ... data to create a Im_health_goal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Im_health_goal we want to update
     *   }
     * })
    **/
    upsert<T extends im_health_goalUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, im_health_goalUpsertArgs<ExtArgs>>
    ): Prisma__im_health_goalClient<$Result.GetResult<Prisma.$im_health_goalPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Im_health_goals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_health_goalCountArgs} args - Arguments to filter Im_health_goals to count.
     * @example
     * // Count the number of Im_health_goals
     * const count = await prisma.im_health_goal.count({
     *   where: {
     *     // ... the filter for the Im_health_goals we want to count
     *   }
     * })
    **/
    count<T extends im_health_goalCountArgs>(
      args?: Subset<T, im_health_goalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Im_health_goalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Im_health_goal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Im_health_goalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Im_health_goalAggregateArgs>(args: Subset<T, Im_health_goalAggregateArgs>): Prisma.PrismaPromise<GetIm_health_goalAggregateType<T>>

    /**
     * Group by Im_health_goal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_health_goalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends im_health_goalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: im_health_goalGroupByArgs['orderBy'] }
        : { orderBy?: im_health_goalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, im_health_goalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIm_health_goalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the im_health_goal model
   */
  readonly fields: im_health_goalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for im_health_goal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__im_health_goalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    im_health<T extends im_healthDefaultArgs<ExtArgs> = {}>(args?: Subset<T, im_healthDefaultArgs<ExtArgs>>): Prisma__im_healthClient<$Result.GetResult<Prisma.$im_healthPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    im_health_goal_daily<T extends im_health_goal$im_health_goal_dailyArgs<ExtArgs> = {}>(args?: Subset<T, im_health_goal$im_health_goal_dailyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$im_health_goal_dailyPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the im_health_goal model
   */ 
  interface im_health_goalFieldRefs {
    readonly id_health_goal: FieldRef<"im_health_goal", 'Int'>
    readonly health_goal_steps: FieldRef<"im_health_goal", 'Int'>
    readonly health_goal_weight: FieldRef<"im_health_goal", 'Int'>
    readonly health_goal_sleep: FieldRef<"im_health_goal", 'Int'>
    readonly health_goal_water: FieldRef<"im_health_goal", 'Int'>
    readonly id_health: FieldRef<"im_health_goal", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * im_health_goal findUnique
   */
  export type im_health_goalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal
     */
    select?: im_health_goalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goalInclude<ExtArgs> | null
    /**
     * Filter, which im_health_goal to fetch.
     */
    where: im_health_goalWhereUniqueInput
  }


  /**
   * im_health_goal findUniqueOrThrow
   */
  export type im_health_goalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal
     */
    select?: im_health_goalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goalInclude<ExtArgs> | null
    /**
     * Filter, which im_health_goal to fetch.
     */
    where: im_health_goalWhereUniqueInput
  }


  /**
   * im_health_goal findFirst
   */
  export type im_health_goalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal
     */
    select?: im_health_goalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goalInclude<ExtArgs> | null
    /**
     * Filter, which im_health_goal to fetch.
     */
    where?: im_health_goalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_health_goals to fetch.
     */
    orderBy?: im_health_goalOrderByWithRelationInput | im_health_goalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for im_health_goals.
     */
    cursor?: im_health_goalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_health_goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_health_goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of im_health_goals.
     */
    distinct?: Im_health_goalScalarFieldEnum | Im_health_goalScalarFieldEnum[]
  }


  /**
   * im_health_goal findFirstOrThrow
   */
  export type im_health_goalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal
     */
    select?: im_health_goalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goalInclude<ExtArgs> | null
    /**
     * Filter, which im_health_goal to fetch.
     */
    where?: im_health_goalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_health_goals to fetch.
     */
    orderBy?: im_health_goalOrderByWithRelationInput | im_health_goalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for im_health_goals.
     */
    cursor?: im_health_goalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_health_goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_health_goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of im_health_goals.
     */
    distinct?: Im_health_goalScalarFieldEnum | Im_health_goalScalarFieldEnum[]
  }


  /**
   * im_health_goal findMany
   */
  export type im_health_goalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal
     */
    select?: im_health_goalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goalInclude<ExtArgs> | null
    /**
     * Filter, which im_health_goals to fetch.
     */
    where?: im_health_goalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_health_goals to fetch.
     */
    orderBy?: im_health_goalOrderByWithRelationInput | im_health_goalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing im_health_goals.
     */
    cursor?: im_health_goalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_health_goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_health_goals.
     */
    skip?: number
    distinct?: Im_health_goalScalarFieldEnum | Im_health_goalScalarFieldEnum[]
  }


  /**
   * im_health_goal create
   */
  export type im_health_goalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal
     */
    select?: im_health_goalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goalInclude<ExtArgs> | null
    /**
     * The data needed to create a im_health_goal.
     */
    data: XOR<im_health_goalCreateInput, im_health_goalUncheckedCreateInput>
  }


  /**
   * im_health_goal createMany
   */
  export type im_health_goalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many im_health_goals.
     */
    data: im_health_goalCreateManyInput | im_health_goalCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * im_health_goal update
   */
  export type im_health_goalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal
     */
    select?: im_health_goalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goalInclude<ExtArgs> | null
    /**
     * The data needed to update a im_health_goal.
     */
    data: XOR<im_health_goalUpdateInput, im_health_goalUncheckedUpdateInput>
    /**
     * Choose, which im_health_goal to update.
     */
    where: im_health_goalWhereUniqueInput
  }


  /**
   * im_health_goal updateMany
   */
  export type im_health_goalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update im_health_goals.
     */
    data: XOR<im_health_goalUpdateManyMutationInput, im_health_goalUncheckedUpdateManyInput>
    /**
     * Filter which im_health_goals to update
     */
    where?: im_health_goalWhereInput
  }


  /**
   * im_health_goal upsert
   */
  export type im_health_goalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal
     */
    select?: im_health_goalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goalInclude<ExtArgs> | null
    /**
     * The filter to search for the im_health_goal to update in case it exists.
     */
    where: im_health_goalWhereUniqueInput
    /**
     * In case the im_health_goal found by the `where` argument doesn't exist, create a new im_health_goal with this data.
     */
    create: XOR<im_health_goalCreateInput, im_health_goalUncheckedCreateInput>
    /**
     * In case the im_health_goal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<im_health_goalUpdateInput, im_health_goalUncheckedUpdateInput>
  }


  /**
   * im_health_goal delete
   */
  export type im_health_goalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal
     */
    select?: im_health_goalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goalInclude<ExtArgs> | null
    /**
     * Filter which im_health_goal to delete.
     */
    where: im_health_goalWhereUniqueInput
  }


  /**
   * im_health_goal deleteMany
   */
  export type im_health_goalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which im_health_goals to delete
     */
    where?: im_health_goalWhereInput
  }


  /**
   * im_health_goal.im_health_goal_daily
   */
  export type im_health_goal$im_health_goal_dailyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal_daily
     */
    select?: im_health_goal_dailySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goal_dailyInclude<ExtArgs> | null
    where?: im_health_goal_dailyWhereInput
    orderBy?: im_health_goal_dailyOrderByWithRelationInput | im_health_goal_dailyOrderByWithRelationInput[]
    cursor?: im_health_goal_dailyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Im_health_goal_dailyScalarFieldEnum | Im_health_goal_dailyScalarFieldEnum[]
  }


  /**
   * im_health_goal without action
   */
  export type im_health_goalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal
     */
    select?: im_health_goalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goalInclude<ExtArgs> | null
  }



  /**
   * Model im_health_goal_daily
   */

  export type AggregateIm_health_goal_daily = {
    _count: Im_health_goal_dailyCountAggregateOutputType | null
    _avg: Im_health_goal_dailyAvgAggregateOutputType | null
    _sum: Im_health_goal_dailySumAggregateOutputType | null
    _min: Im_health_goal_dailyMinAggregateOutputType | null
    _max: Im_health_goal_dailyMaxAggregateOutputType | null
  }

  export type Im_health_goal_dailyAvgAggregateOutputType = {
    id_health_goal_daily: number | null
    health_goal_daily_steps: number | null
    health_goal_daily_weight: number | null
    health_goal_daily_sleep: number | null
    health_goal_daily_water: number | null
    id_health_goal: number | null
  }

  export type Im_health_goal_dailySumAggregateOutputType = {
    id_health_goal_daily: number | null
    health_goal_daily_steps: number | null
    health_goal_daily_weight: number | null
    health_goal_daily_sleep: number | null
    health_goal_daily_water: number | null
    id_health_goal: number | null
  }

  export type Im_health_goal_dailyMinAggregateOutputType = {
    id_health_goal_daily: number | null
    health_goal_daily_date: Date | null
    health_goal_daily_steps: number | null
    health_goal_daily_weight: number | null
    health_goal_daily_sleep: number | null
    health_goal_daily_water: number | null
    id_health_goal: number | null
  }

  export type Im_health_goal_dailyMaxAggregateOutputType = {
    id_health_goal_daily: number | null
    health_goal_daily_date: Date | null
    health_goal_daily_steps: number | null
    health_goal_daily_weight: number | null
    health_goal_daily_sleep: number | null
    health_goal_daily_water: number | null
    id_health_goal: number | null
  }

  export type Im_health_goal_dailyCountAggregateOutputType = {
    id_health_goal_daily: number
    health_goal_daily_date: number
    health_goal_daily_steps: number
    health_goal_daily_weight: number
    health_goal_daily_sleep: number
    health_goal_daily_water: number
    id_health_goal: number
    _all: number
  }


  export type Im_health_goal_dailyAvgAggregateInputType = {
    id_health_goal_daily?: true
    health_goal_daily_steps?: true
    health_goal_daily_weight?: true
    health_goal_daily_sleep?: true
    health_goal_daily_water?: true
    id_health_goal?: true
  }

  export type Im_health_goal_dailySumAggregateInputType = {
    id_health_goal_daily?: true
    health_goal_daily_steps?: true
    health_goal_daily_weight?: true
    health_goal_daily_sleep?: true
    health_goal_daily_water?: true
    id_health_goal?: true
  }

  export type Im_health_goal_dailyMinAggregateInputType = {
    id_health_goal_daily?: true
    health_goal_daily_date?: true
    health_goal_daily_steps?: true
    health_goal_daily_weight?: true
    health_goal_daily_sleep?: true
    health_goal_daily_water?: true
    id_health_goal?: true
  }

  export type Im_health_goal_dailyMaxAggregateInputType = {
    id_health_goal_daily?: true
    health_goal_daily_date?: true
    health_goal_daily_steps?: true
    health_goal_daily_weight?: true
    health_goal_daily_sleep?: true
    health_goal_daily_water?: true
    id_health_goal?: true
  }

  export type Im_health_goal_dailyCountAggregateInputType = {
    id_health_goal_daily?: true
    health_goal_daily_date?: true
    health_goal_daily_steps?: true
    health_goal_daily_weight?: true
    health_goal_daily_sleep?: true
    health_goal_daily_water?: true
    id_health_goal?: true
    _all?: true
  }

  export type Im_health_goal_dailyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which im_health_goal_daily to aggregate.
     */
    where?: im_health_goal_dailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_health_goal_dailies to fetch.
     */
    orderBy?: im_health_goal_dailyOrderByWithRelationInput | im_health_goal_dailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: im_health_goal_dailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_health_goal_dailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_health_goal_dailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned im_health_goal_dailies
    **/
    _count?: true | Im_health_goal_dailyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Im_health_goal_dailyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Im_health_goal_dailySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Im_health_goal_dailyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Im_health_goal_dailyMaxAggregateInputType
  }

  export type GetIm_health_goal_dailyAggregateType<T extends Im_health_goal_dailyAggregateArgs> = {
        [P in keyof T & keyof AggregateIm_health_goal_daily]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIm_health_goal_daily[P]>
      : GetScalarType<T[P], AggregateIm_health_goal_daily[P]>
  }




  export type im_health_goal_dailyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: im_health_goal_dailyWhereInput
    orderBy?: im_health_goal_dailyOrderByWithAggregationInput | im_health_goal_dailyOrderByWithAggregationInput[]
    by: Im_health_goal_dailyScalarFieldEnum[] | Im_health_goal_dailyScalarFieldEnum
    having?: im_health_goal_dailyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Im_health_goal_dailyCountAggregateInputType | true
    _avg?: Im_health_goal_dailyAvgAggregateInputType
    _sum?: Im_health_goal_dailySumAggregateInputType
    _min?: Im_health_goal_dailyMinAggregateInputType
    _max?: Im_health_goal_dailyMaxAggregateInputType
  }

  export type Im_health_goal_dailyGroupByOutputType = {
    id_health_goal_daily: number
    health_goal_daily_date: Date
    health_goal_daily_steps: number
    health_goal_daily_weight: number
    health_goal_daily_sleep: number
    health_goal_daily_water: number
    id_health_goal: number
    _count: Im_health_goal_dailyCountAggregateOutputType | null
    _avg: Im_health_goal_dailyAvgAggregateOutputType | null
    _sum: Im_health_goal_dailySumAggregateOutputType | null
    _min: Im_health_goal_dailyMinAggregateOutputType | null
    _max: Im_health_goal_dailyMaxAggregateOutputType | null
  }

  type GetIm_health_goal_dailyGroupByPayload<T extends im_health_goal_dailyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Im_health_goal_dailyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Im_health_goal_dailyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Im_health_goal_dailyGroupByOutputType[P]>
            : GetScalarType<T[P], Im_health_goal_dailyGroupByOutputType[P]>
        }
      >
    >


  export type im_health_goal_dailySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_health_goal_daily?: boolean
    health_goal_daily_date?: boolean
    health_goal_daily_steps?: boolean
    health_goal_daily_weight?: boolean
    health_goal_daily_sleep?: boolean
    health_goal_daily_water?: boolean
    id_health_goal?: boolean
    im_health_goal?: boolean | im_health_goalDefaultArgs<ExtArgs>
    im_health_goal_daily_history?: boolean | im_health_goal_daily$im_health_goal_daily_historyArgs<ExtArgs>
    _count?: boolean | Im_health_goal_dailyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["im_health_goal_daily"]>

  export type im_health_goal_dailySelectScalar = {
    id_health_goal_daily?: boolean
    health_goal_daily_date?: boolean
    health_goal_daily_steps?: boolean
    health_goal_daily_weight?: boolean
    health_goal_daily_sleep?: boolean
    health_goal_daily_water?: boolean
    id_health_goal?: boolean
  }

  export type im_health_goal_dailyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    im_health_goal?: boolean | im_health_goalDefaultArgs<ExtArgs>
    im_health_goal_daily_history?: boolean | im_health_goal_daily$im_health_goal_daily_historyArgs<ExtArgs>
    _count?: boolean | Im_health_goal_dailyCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $im_health_goal_dailyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "im_health_goal_daily"
    objects: {
      im_health_goal: Prisma.$im_health_goalPayload<ExtArgs>
      im_health_goal_daily_history: Prisma.$im_health_goal_daily_historyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_health_goal_daily: number
      health_goal_daily_date: Date
      health_goal_daily_steps: number
      health_goal_daily_weight: number
      health_goal_daily_sleep: number
      health_goal_daily_water: number
      id_health_goal: number
    }, ExtArgs["result"]["im_health_goal_daily"]>
    composites: {}
  }


  type im_health_goal_dailyGetPayload<S extends boolean | null | undefined | im_health_goal_dailyDefaultArgs> = $Result.GetResult<Prisma.$im_health_goal_dailyPayload, S>

  type im_health_goal_dailyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<im_health_goal_dailyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Im_health_goal_dailyCountAggregateInputType | true
    }

  export interface im_health_goal_dailyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['im_health_goal_daily'], meta: { name: 'im_health_goal_daily' } }
    /**
     * Find zero or one Im_health_goal_daily that matches the filter.
     * @param {im_health_goal_dailyFindUniqueArgs} args - Arguments to find a Im_health_goal_daily
     * @example
     * // Get one Im_health_goal_daily
     * const im_health_goal_daily = await prisma.im_health_goal_daily.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends im_health_goal_dailyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, im_health_goal_dailyFindUniqueArgs<ExtArgs>>
    ): Prisma__im_health_goal_dailyClient<$Result.GetResult<Prisma.$im_health_goal_dailyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Im_health_goal_daily that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {im_health_goal_dailyFindUniqueOrThrowArgs} args - Arguments to find a Im_health_goal_daily
     * @example
     * // Get one Im_health_goal_daily
     * const im_health_goal_daily = await prisma.im_health_goal_daily.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends im_health_goal_dailyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, im_health_goal_dailyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__im_health_goal_dailyClient<$Result.GetResult<Prisma.$im_health_goal_dailyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Im_health_goal_daily that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_health_goal_dailyFindFirstArgs} args - Arguments to find a Im_health_goal_daily
     * @example
     * // Get one Im_health_goal_daily
     * const im_health_goal_daily = await prisma.im_health_goal_daily.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends im_health_goal_dailyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, im_health_goal_dailyFindFirstArgs<ExtArgs>>
    ): Prisma__im_health_goal_dailyClient<$Result.GetResult<Prisma.$im_health_goal_dailyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Im_health_goal_daily that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_health_goal_dailyFindFirstOrThrowArgs} args - Arguments to find a Im_health_goal_daily
     * @example
     * // Get one Im_health_goal_daily
     * const im_health_goal_daily = await prisma.im_health_goal_daily.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends im_health_goal_dailyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, im_health_goal_dailyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__im_health_goal_dailyClient<$Result.GetResult<Prisma.$im_health_goal_dailyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Im_health_goal_dailies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_health_goal_dailyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Im_health_goal_dailies
     * const im_health_goal_dailies = await prisma.im_health_goal_daily.findMany()
     * 
     * // Get first 10 Im_health_goal_dailies
     * const im_health_goal_dailies = await prisma.im_health_goal_daily.findMany({ take: 10 })
     * 
     * // Only select the `id_health_goal_daily`
     * const im_health_goal_dailyWithId_health_goal_dailyOnly = await prisma.im_health_goal_daily.findMany({ select: { id_health_goal_daily: true } })
     * 
    **/
    findMany<T extends im_health_goal_dailyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_health_goal_dailyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$im_health_goal_dailyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Im_health_goal_daily.
     * @param {im_health_goal_dailyCreateArgs} args - Arguments to create a Im_health_goal_daily.
     * @example
     * // Create one Im_health_goal_daily
     * const Im_health_goal_daily = await prisma.im_health_goal_daily.create({
     *   data: {
     *     // ... data to create a Im_health_goal_daily
     *   }
     * })
     * 
    **/
    create<T extends im_health_goal_dailyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, im_health_goal_dailyCreateArgs<ExtArgs>>
    ): Prisma__im_health_goal_dailyClient<$Result.GetResult<Prisma.$im_health_goal_dailyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Im_health_goal_dailies.
     *     @param {im_health_goal_dailyCreateManyArgs} args - Arguments to create many Im_health_goal_dailies.
     *     @example
     *     // Create many Im_health_goal_dailies
     *     const im_health_goal_daily = await prisma.im_health_goal_daily.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends im_health_goal_dailyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_health_goal_dailyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Im_health_goal_daily.
     * @param {im_health_goal_dailyDeleteArgs} args - Arguments to delete one Im_health_goal_daily.
     * @example
     * // Delete one Im_health_goal_daily
     * const Im_health_goal_daily = await prisma.im_health_goal_daily.delete({
     *   where: {
     *     // ... filter to delete one Im_health_goal_daily
     *   }
     * })
     * 
    **/
    delete<T extends im_health_goal_dailyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, im_health_goal_dailyDeleteArgs<ExtArgs>>
    ): Prisma__im_health_goal_dailyClient<$Result.GetResult<Prisma.$im_health_goal_dailyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Im_health_goal_daily.
     * @param {im_health_goal_dailyUpdateArgs} args - Arguments to update one Im_health_goal_daily.
     * @example
     * // Update one Im_health_goal_daily
     * const im_health_goal_daily = await prisma.im_health_goal_daily.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends im_health_goal_dailyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, im_health_goal_dailyUpdateArgs<ExtArgs>>
    ): Prisma__im_health_goal_dailyClient<$Result.GetResult<Prisma.$im_health_goal_dailyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Im_health_goal_dailies.
     * @param {im_health_goal_dailyDeleteManyArgs} args - Arguments to filter Im_health_goal_dailies to delete.
     * @example
     * // Delete a few Im_health_goal_dailies
     * const { count } = await prisma.im_health_goal_daily.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends im_health_goal_dailyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_health_goal_dailyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Im_health_goal_dailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_health_goal_dailyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Im_health_goal_dailies
     * const im_health_goal_daily = await prisma.im_health_goal_daily.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends im_health_goal_dailyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, im_health_goal_dailyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Im_health_goal_daily.
     * @param {im_health_goal_dailyUpsertArgs} args - Arguments to update or create a Im_health_goal_daily.
     * @example
     * // Update or create a Im_health_goal_daily
     * const im_health_goal_daily = await prisma.im_health_goal_daily.upsert({
     *   create: {
     *     // ... data to create a Im_health_goal_daily
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Im_health_goal_daily we want to update
     *   }
     * })
    **/
    upsert<T extends im_health_goal_dailyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, im_health_goal_dailyUpsertArgs<ExtArgs>>
    ): Prisma__im_health_goal_dailyClient<$Result.GetResult<Prisma.$im_health_goal_dailyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Im_health_goal_dailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_health_goal_dailyCountArgs} args - Arguments to filter Im_health_goal_dailies to count.
     * @example
     * // Count the number of Im_health_goal_dailies
     * const count = await prisma.im_health_goal_daily.count({
     *   where: {
     *     // ... the filter for the Im_health_goal_dailies we want to count
     *   }
     * })
    **/
    count<T extends im_health_goal_dailyCountArgs>(
      args?: Subset<T, im_health_goal_dailyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Im_health_goal_dailyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Im_health_goal_daily.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Im_health_goal_dailyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Im_health_goal_dailyAggregateArgs>(args: Subset<T, Im_health_goal_dailyAggregateArgs>): Prisma.PrismaPromise<GetIm_health_goal_dailyAggregateType<T>>

    /**
     * Group by Im_health_goal_daily.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_health_goal_dailyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends im_health_goal_dailyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: im_health_goal_dailyGroupByArgs['orderBy'] }
        : { orderBy?: im_health_goal_dailyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, im_health_goal_dailyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIm_health_goal_dailyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the im_health_goal_daily model
   */
  readonly fields: im_health_goal_dailyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for im_health_goal_daily.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__im_health_goal_dailyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    im_health_goal<T extends im_health_goalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, im_health_goalDefaultArgs<ExtArgs>>): Prisma__im_health_goalClient<$Result.GetResult<Prisma.$im_health_goalPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    im_health_goal_daily_history<T extends im_health_goal_daily$im_health_goal_daily_historyArgs<ExtArgs> = {}>(args?: Subset<T, im_health_goal_daily$im_health_goal_daily_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$im_health_goal_daily_historyPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the im_health_goal_daily model
   */ 
  interface im_health_goal_dailyFieldRefs {
    readonly id_health_goal_daily: FieldRef<"im_health_goal_daily", 'Int'>
    readonly health_goal_daily_date: FieldRef<"im_health_goal_daily", 'DateTime'>
    readonly health_goal_daily_steps: FieldRef<"im_health_goal_daily", 'Int'>
    readonly health_goal_daily_weight: FieldRef<"im_health_goal_daily", 'Int'>
    readonly health_goal_daily_sleep: FieldRef<"im_health_goal_daily", 'Int'>
    readonly health_goal_daily_water: FieldRef<"im_health_goal_daily", 'Int'>
    readonly id_health_goal: FieldRef<"im_health_goal_daily", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * im_health_goal_daily findUnique
   */
  export type im_health_goal_dailyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal_daily
     */
    select?: im_health_goal_dailySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goal_dailyInclude<ExtArgs> | null
    /**
     * Filter, which im_health_goal_daily to fetch.
     */
    where: im_health_goal_dailyWhereUniqueInput
  }


  /**
   * im_health_goal_daily findUniqueOrThrow
   */
  export type im_health_goal_dailyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal_daily
     */
    select?: im_health_goal_dailySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goal_dailyInclude<ExtArgs> | null
    /**
     * Filter, which im_health_goal_daily to fetch.
     */
    where: im_health_goal_dailyWhereUniqueInput
  }


  /**
   * im_health_goal_daily findFirst
   */
  export type im_health_goal_dailyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal_daily
     */
    select?: im_health_goal_dailySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goal_dailyInclude<ExtArgs> | null
    /**
     * Filter, which im_health_goal_daily to fetch.
     */
    where?: im_health_goal_dailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_health_goal_dailies to fetch.
     */
    orderBy?: im_health_goal_dailyOrderByWithRelationInput | im_health_goal_dailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for im_health_goal_dailies.
     */
    cursor?: im_health_goal_dailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_health_goal_dailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_health_goal_dailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of im_health_goal_dailies.
     */
    distinct?: Im_health_goal_dailyScalarFieldEnum | Im_health_goal_dailyScalarFieldEnum[]
  }


  /**
   * im_health_goal_daily findFirstOrThrow
   */
  export type im_health_goal_dailyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal_daily
     */
    select?: im_health_goal_dailySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goal_dailyInclude<ExtArgs> | null
    /**
     * Filter, which im_health_goal_daily to fetch.
     */
    where?: im_health_goal_dailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_health_goal_dailies to fetch.
     */
    orderBy?: im_health_goal_dailyOrderByWithRelationInput | im_health_goal_dailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for im_health_goal_dailies.
     */
    cursor?: im_health_goal_dailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_health_goal_dailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_health_goal_dailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of im_health_goal_dailies.
     */
    distinct?: Im_health_goal_dailyScalarFieldEnum | Im_health_goal_dailyScalarFieldEnum[]
  }


  /**
   * im_health_goal_daily findMany
   */
  export type im_health_goal_dailyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal_daily
     */
    select?: im_health_goal_dailySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goal_dailyInclude<ExtArgs> | null
    /**
     * Filter, which im_health_goal_dailies to fetch.
     */
    where?: im_health_goal_dailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_health_goal_dailies to fetch.
     */
    orderBy?: im_health_goal_dailyOrderByWithRelationInput | im_health_goal_dailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing im_health_goal_dailies.
     */
    cursor?: im_health_goal_dailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_health_goal_dailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_health_goal_dailies.
     */
    skip?: number
    distinct?: Im_health_goal_dailyScalarFieldEnum | Im_health_goal_dailyScalarFieldEnum[]
  }


  /**
   * im_health_goal_daily create
   */
  export type im_health_goal_dailyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal_daily
     */
    select?: im_health_goal_dailySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goal_dailyInclude<ExtArgs> | null
    /**
     * The data needed to create a im_health_goal_daily.
     */
    data: XOR<im_health_goal_dailyCreateInput, im_health_goal_dailyUncheckedCreateInput>
  }


  /**
   * im_health_goal_daily createMany
   */
  export type im_health_goal_dailyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many im_health_goal_dailies.
     */
    data: im_health_goal_dailyCreateManyInput | im_health_goal_dailyCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * im_health_goal_daily update
   */
  export type im_health_goal_dailyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal_daily
     */
    select?: im_health_goal_dailySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goal_dailyInclude<ExtArgs> | null
    /**
     * The data needed to update a im_health_goal_daily.
     */
    data: XOR<im_health_goal_dailyUpdateInput, im_health_goal_dailyUncheckedUpdateInput>
    /**
     * Choose, which im_health_goal_daily to update.
     */
    where: im_health_goal_dailyWhereUniqueInput
  }


  /**
   * im_health_goal_daily updateMany
   */
  export type im_health_goal_dailyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update im_health_goal_dailies.
     */
    data: XOR<im_health_goal_dailyUpdateManyMutationInput, im_health_goal_dailyUncheckedUpdateManyInput>
    /**
     * Filter which im_health_goal_dailies to update
     */
    where?: im_health_goal_dailyWhereInput
  }


  /**
   * im_health_goal_daily upsert
   */
  export type im_health_goal_dailyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal_daily
     */
    select?: im_health_goal_dailySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goal_dailyInclude<ExtArgs> | null
    /**
     * The filter to search for the im_health_goal_daily to update in case it exists.
     */
    where: im_health_goal_dailyWhereUniqueInput
    /**
     * In case the im_health_goal_daily found by the `where` argument doesn't exist, create a new im_health_goal_daily with this data.
     */
    create: XOR<im_health_goal_dailyCreateInput, im_health_goal_dailyUncheckedCreateInput>
    /**
     * In case the im_health_goal_daily was found with the provided `where` argument, update it with this data.
     */
    update: XOR<im_health_goal_dailyUpdateInput, im_health_goal_dailyUncheckedUpdateInput>
  }


  /**
   * im_health_goal_daily delete
   */
  export type im_health_goal_dailyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal_daily
     */
    select?: im_health_goal_dailySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goal_dailyInclude<ExtArgs> | null
    /**
     * Filter which im_health_goal_daily to delete.
     */
    where: im_health_goal_dailyWhereUniqueInput
  }


  /**
   * im_health_goal_daily deleteMany
   */
  export type im_health_goal_dailyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which im_health_goal_dailies to delete
     */
    where?: im_health_goal_dailyWhereInput
  }


  /**
   * im_health_goal_daily.im_health_goal_daily_history
   */
  export type im_health_goal_daily$im_health_goal_daily_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal_daily_history
     */
    select?: im_health_goal_daily_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goal_daily_historyInclude<ExtArgs> | null
    where?: im_health_goal_daily_historyWhereInput
    orderBy?: im_health_goal_daily_historyOrderByWithRelationInput | im_health_goal_daily_historyOrderByWithRelationInput[]
    cursor?: im_health_goal_daily_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Im_health_goal_daily_historyScalarFieldEnum | Im_health_goal_daily_historyScalarFieldEnum[]
  }


  /**
   * im_health_goal_daily without action
   */
  export type im_health_goal_dailyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal_daily
     */
    select?: im_health_goal_dailySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goal_dailyInclude<ExtArgs> | null
  }



  /**
   * Model im_health_goal_daily_history
   */

  export type AggregateIm_health_goal_daily_history = {
    _count: Im_health_goal_daily_historyCountAggregateOutputType | null
    _avg: Im_health_goal_daily_historyAvgAggregateOutputType | null
    _sum: Im_health_goal_daily_historySumAggregateOutputType | null
    _min: Im_health_goal_daily_historyMinAggregateOutputType | null
    _max: Im_health_goal_daily_historyMaxAggregateOutputType | null
  }

  export type Im_health_goal_daily_historyAvgAggregateOutputType = {
    id_health_goal_daily_history: number | null
    id_health_goal_daily: number | null
  }

  export type Im_health_goal_daily_historySumAggregateOutputType = {
    id_health_goal_daily_history: number | null
    id_health_goal_daily: number | null
  }

  export type Im_health_goal_daily_historyMinAggregateOutputType = {
    id_health_goal_daily_history: number | null
    health_goal_daily_history_date: Date | null
    id_health_goal_daily: number | null
  }

  export type Im_health_goal_daily_historyMaxAggregateOutputType = {
    id_health_goal_daily_history: number | null
    health_goal_daily_history_date: Date | null
    id_health_goal_daily: number | null
  }

  export type Im_health_goal_daily_historyCountAggregateOutputType = {
    id_health_goal_daily_history: number
    health_goal_daily_history_date: number
    id_health_goal_daily: number
    _all: number
  }


  export type Im_health_goal_daily_historyAvgAggregateInputType = {
    id_health_goal_daily_history?: true
    id_health_goal_daily?: true
  }

  export type Im_health_goal_daily_historySumAggregateInputType = {
    id_health_goal_daily_history?: true
    id_health_goal_daily?: true
  }

  export type Im_health_goal_daily_historyMinAggregateInputType = {
    id_health_goal_daily_history?: true
    health_goal_daily_history_date?: true
    id_health_goal_daily?: true
  }

  export type Im_health_goal_daily_historyMaxAggregateInputType = {
    id_health_goal_daily_history?: true
    health_goal_daily_history_date?: true
    id_health_goal_daily?: true
  }

  export type Im_health_goal_daily_historyCountAggregateInputType = {
    id_health_goal_daily_history?: true
    health_goal_daily_history_date?: true
    id_health_goal_daily?: true
    _all?: true
  }

  export type Im_health_goal_daily_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which im_health_goal_daily_history to aggregate.
     */
    where?: im_health_goal_daily_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_health_goal_daily_histories to fetch.
     */
    orderBy?: im_health_goal_daily_historyOrderByWithRelationInput | im_health_goal_daily_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: im_health_goal_daily_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_health_goal_daily_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_health_goal_daily_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned im_health_goal_daily_histories
    **/
    _count?: true | Im_health_goal_daily_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Im_health_goal_daily_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Im_health_goal_daily_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Im_health_goal_daily_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Im_health_goal_daily_historyMaxAggregateInputType
  }

  export type GetIm_health_goal_daily_historyAggregateType<T extends Im_health_goal_daily_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateIm_health_goal_daily_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIm_health_goal_daily_history[P]>
      : GetScalarType<T[P], AggregateIm_health_goal_daily_history[P]>
  }




  export type im_health_goal_daily_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: im_health_goal_daily_historyWhereInput
    orderBy?: im_health_goal_daily_historyOrderByWithAggregationInput | im_health_goal_daily_historyOrderByWithAggregationInput[]
    by: Im_health_goal_daily_historyScalarFieldEnum[] | Im_health_goal_daily_historyScalarFieldEnum
    having?: im_health_goal_daily_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Im_health_goal_daily_historyCountAggregateInputType | true
    _avg?: Im_health_goal_daily_historyAvgAggregateInputType
    _sum?: Im_health_goal_daily_historySumAggregateInputType
    _min?: Im_health_goal_daily_historyMinAggregateInputType
    _max?: Im_health_goal_daily_historyMaxAggregateInputType
  }

  export type Im_health_goal_daily_historyGroupByOutputType = {
    id_health_goal_daily_history: number
    health_goal_daily_history_date: Date
    id_health_goal_daily: number
    _count: Im_health_goal_daily_historyCountAggregateOutputType | null
    _avg: Im_health_goal_daily_historyAvgAggregateOutputType | null
    _sum: Im_health_goal_daily_historySumAggregateOutputType | null
    _min: Im_health_goal_daily_historyMinAggregateOutputType | null
    _max: Im_health_goal_daily_historyMaxAggregateOutputType | null
  }

  type GetIm_health_goal_daily_historyGroupByPayload<T extends im_health_goal_daily_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Im_health_goal_daily_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Im_health_goal_daily_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Im_health_goal_daily_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Im_health_goal_daily_historyGroupByOutputType[P]>
        }
      >
    >


  export type im_health_goal_daily_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_health_goal_daily_history?: boolean
    health_goal_daily_history_date?: boolean
    id_health_goal_daily?: boolean
    im_health_goal_daily?: boolean | im_health_goal_dailyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["im_health_goal_daily_history"]>

  export type im_health_goal_daily_historySelectScalar = {
    id_health_goal_daily_history?: boolean
    health_goal_daily_history_date?: boolean
    id_health_goal_daily?: boolean
  }

  export type im_health_goal_daily_historyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    im_health_goal_daily?: boolean | im_health_goal_dailyDefaultArgs<ExtArgs>
  }


  export type $im_health_goal_daily_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "im_health_goal_daily_history"
    objects: {
      im_health_goal_daily: Prisma.$im_health_goal_dailyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_health_goal_daily_history: number
      health_goal_daily_history_date: Date
      id_health_goal_daily: number
    }, ExtArgs["result"]["im_health_goal_daily_history"]>
    composites: {}
  }


  type im_health_goal_daily_historyGetPayload<S extends boolean | null | undefined | im_health_goal_daily_historyDefaultArgs> = $Result.GetResult<Prisma.$im_health_goal_daily_historyPayload, S>

  type im_health_goal_daily_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<im_health_goal_daily_historyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Im_health_goal_daily_historyCountAggregateInputType | true
    }

  export interface im_health_goal_daily_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['im_health_goal_daily_history'], meta: { name: 'im_health_goal_daily_history' } }
    /**
     * Find zero or one Im_health_goal_daily_history that matches the filter.
     * @param {im_health_goal_daily_historyFindUniqueArgs} args - Arguments to find a Im_health_goal_daily_history
     * @example
     * // Get one Im_health_goal_daily_history
     * const im_health_goal_daily_history = await prisma.im_health_goal_daily_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends im_health_goal_daily_historyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, im_health_goal_daily_historyFindUniqueArgs<ExtArgs>>
    ): Prisma__im_health_goal_daily_historyClient<$Result.GetResult<Prisma.$im_health_goal_daily_historyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Im_health_goal_daily_history that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {im_health_goal_daily_historyFindUniqueOrThrowArgs} args - Arguments to find a Im_health_goal_daily_history
     * @example
     * // Get one Im_health_goal_daily_history
     * const im_health_goal_daily_history = await prisma.im_health_goal_daily_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends im_health_goal_daily_historyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, im_health_goal_daily_historyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__im_health_goal_daily_historyClient<$Result.GetResult<Prisma.$im_health_goal_daily_historyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Im_health_goal_daily_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_health_goal_daily_historyFindFirstArgs} args - Arguments to find a Im_health_goal_daily_history
     * @example
     * // Get one Im_health_goal_daily_history
     * const im_health_goal_daily_history = await prisma.im_health_goal_daily_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends im_health_goal_daily_historyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, im_health_goal_daily_historyFindFirstArgs<ExtArgs>>
    ): Prisma__im_health_goal_daily_historyClient<$Result.GetResult<Prisma.$im_health_goal_daily_historyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Im_health_goal_daily_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_health_goal_daily_historyFindFirstOrThrowArgs} args - Arguments to find a Im_health_goal_daily_history
     * @example
     * // Get one Im_health_goal_daily_history
     * const im_health_goal_daily_history = await prisma.im_health_goal_daily_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends im_health_goal_daily_historyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, im_health_goal_daily_historyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__im_health_goal_daily_historyClient<$Result.GetResult<Prisma.$im_health_goal_daily_historyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Im_health_goal_daily_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_health_goal_daily_historyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Im_health_goal_daily_histories
     * const im_health_goal_daily_histories = await prisma.im_health_goal_daily_history.findMany()
     * 
     * // Get first 10 Im_health_goal_daily_histories
     * const im_health_goal_daily_histories = await prisma.im_health_goal_daily_history.findMany({ take: 10 })
     * 
     * // Only select the `id_health_goal_daily_history`
     * const im_health_goal_daily_historyWithId_health_goal_daily_historyOnly = await prisma.im_health_goal_daily_history.findMany({ select: { id_health_goal_daily_history: true } })
     * 
    **/
    findMany<T extends im_health_goal_daily_historyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_health_goal_daily_historyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$im_health_goal_daily_historyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Im_health_goal_daily_history.
     * @param {im_health_goal_daily_historyCreateArgs} args - Arguments to create a Im_health_goal_daily_history.
     * @example
     * // Create one Im_health_goal_daily_history
     * const Im_health_goal_daily_history = await prisma.im_health_goal_daily_history.create({
     *   data: {
     *     // ... data to create a Im_health_goal_daily_history
     *   }
     * })
     * 
    **/
    create<T extends im_health_goal_daily_historyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, im_health_goal_daily_historyCreateArgs<ExtArgs>>
    ): Prisma__im_health_goal_daily_historyClient<$Result.GetResult<Prisma.$im_health_goal_daily_historyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Im_health_goal_daily_histories.
     *     @param {im_health_goal_daily_historyCreateManyArgs} args - Arguments to create many Im_health_goal_daily_histories.
     *     @example
     *     // Create many Im_health_goal_daily_histories
     *     const im_health_goal_daily_history = await prisma.im_health_goal_daily_history.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends im_health_goal_daily_historyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_health_goal_daily_historyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Im_health_goal_daily_history.
     * @param {im_health_goal_daily_historyDeleteArgs} args - Arguments to delete one Im_health_goal_daily_history.
     * @example
     * // Delete one Im_health_goal_daily_history
     * const Im_health_goal_daily_history = await prisma.im_health_goal_daily_history.delete({
     *   where: {
     *     // ... filter to delete one Im_health_goal_daily_history
     *   }
     * })
     * 
    **/
    delete<T extends im_health_goal_daily_historyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, im_health_goal_daily_historyDeleteArgs<ExtArgs>>
    ): Prisma__im_health_goal_daily_historyClient<$Result.GetResult<Prisma.$im_health_goal_daily_historyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Im_health_goal_daily_history.
     * @param {im_health_goal_daily_historyUpdateArgs} args - Arguments to update one Im_health_goal_daily_history.
     * @example
     * // Update one Im_health_goal_daily_history
     * const im_health_goal_daily_history = await prisma.im_health_goal_daily_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends im_health_goal_daily_historyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, im_health_goal_daily_historyUpdateArgs<ExtArgs>>
    ): Prisma__im_health_goal_daily_historyClient<$Result.GetResult<Prisma.$im_health_goal_daily_historyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Im_health_goal_daily_histories.
     * @param {im_health_goal_daily_historyDeleteManyArgs} args - Arguments to filter Im_health_goal_daily_histories to delete.
     * @example
     * // Delete a few Im_health_goal_daily_histories
     * const { count } = await prisma.im_health_goal_daily_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends im_health_goal_daily_historyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_health_goal_daily_historyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Im_health_goal_daily_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_health_goal_daily_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Im_health_goal_daily_histories
     * const im_health_goal_daily_history = await prisma.im_health_goal_daily_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends im_health_goal_daily_historyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, im_health_goal_daily_historyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Im_health_goal_daily_history.
     * @param {im_health_goal_daily_historyUpsertArgs} args - Arguments to update or create a Im_health_goal_daily_history.
     * @example
     * // Update or create a Im_health_goal_daily_history
     * const im_health_goal_daily_history = await prisma.im_health_goal_daily_history.upsert({
     *   create: {
     *     // ... data to create a Im_health_goal_daily_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Im_health_goal_daily_history we want to update
     *   }
     * })
    **/
    upsert<T extends im_health_goal_daily_historyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, im_health_goal_daily_historyUpsertArgs<ExtArgs>>
    ): Prisma__im_health_goal_daily_historyClient<$Result.GetResult<Prisma.$im_health_goal_daily_historyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Im_health_goal_daily_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_health_goal_daily_historyCountArgs} args - Arguments to filter Im_health_goal_daily_histories to count.
     * @example
     * // Count the number of Im_health_goal_daily_histories
     * const count = await prisma.im_health_goal_daily_history.count({
     *   where: {
     *     // ... the filter for the Im_health_goal_daily_histories we want to count
     *   }
     * })
    **/
    count<T extends im_health_goal_daily_historyCountArgs>(
      args?: Subset<T, im_health_goal_daily_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Im_health_goal_daily_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Im_health_goal_daily_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Im_health_goal_daily_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Im_health_goal_daily_historyAggregateArgs>(args: Subset<T, Im_health_goal_daily_historyAggregateArgs>): Prisma.PrismaPromise<GetIm_health_goal_daily_historyAggregateType<T>>

    /**
     * Group by Im_health_goal_daily_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_health_goal_daily_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends im_health_goal_daily_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: im_health_goal_daily_historyGroupByArgs['orderBy'] }
        : { orderBy?: im_health_goal_daily_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, im_health_goal_daily_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIm_health_goal_daily_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the im_health_goal_daily_history model
   */
  readonly fields: im_health_goal_daily_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for im_health_goal_daily_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__im_health_goal_daily_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    im_health_goal_daily<T extends im_health_goal_dailyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, im_health_goal_dailyDefaultArgs<ExtArgs>>): Prisma__im_health_goal_dailyClient<$Result.GetResult<Prisma.$im_health_goal_dailyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the im_health_goal_daily_history model
   */ 
  interface im_health_goal_daily_historyFieldRefs {
    readonly id_health_goal_daily_history: FieldRef<"im_health_goal_daily_history", 'Int'>
    readonly health_goal_daily_history_date: FieldRef<"im_health_goal_daily_history", 'DateTime'>
    readonly id_health_goal_daily: FieldRef<"im_health_goal_daily_history", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * im_health_goal_daily_history findUnique
   */
  export type im_health_goal_daily_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal_daily_history
     */
    select?: im_health_goal_daily_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goal_daily_historyInclude<ExtArgs> | null
    /**
     * Filter, which im_health_goal_daily_history to fetch.
     */
    where: im_health_goal_daily_historyWhereUniqueInput
  }


  /**
   * im_health_goal_daily_history findUniqueOrThrow
   */
  export type im_health_goal_daily_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal_daily_history
     */
    select?: im_health_goal_daily_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goal_daily_historyInclude<ExtArgs> | null
    /**
     * Filter, which im_health_goal_daily_history to fetch.
     */
    where: im_health_goal_daily_historyWhereUniqueInput
  }


  /**
   * im_health_goal_daily_history findFirst
   */
  export type im_health_goal_daily_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal_daily_history
     */
    select?: im_health_goal_daily_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goal_daily_historyInclude<ExtArgs> | null
    /**
     * Filter, which im_health_goal_daily_history to fetch.
     */
    where?: im_health_goal_daily_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_health_goal_daily_histories to fetch.
     */
    orderBy?: im_health_goal_daily_historyOrderByWithRelationInput | im_health_goal_daily_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for im_health_goal_daily_histories.
     */
    cursor?: im_health_goal_daily_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_health_goal_daily_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_health_goal_daily_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of im_health_goal_daily_histories.
     */
    distinct?: Im_health_goal_daily_historyScalarFieldEnum | Im_health_goal_daily_historyScalarFieldEnum[]
  }


  /**
   * im_health_goal_daily_history findFirstOrThrow
   */
  export type im_health_goal_daily_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal_daily_history
     */
    select?: im_health_goal_daily_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goal_daily_historyInclude<ExtArgs> | null
    /**
     * Filter, which im_health_goal_daily_history to fetch.
     */
    where?: im_health_goal_daily_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_health_goal_daily_histories to fetch.
     */
    orderBy?: im_health_goal_daily_historyOrderByWithRelationInput | im_health_goal_daily_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for im_health_goal_daily_histories.
     */
    cursor?: im_health_goal_daily_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_health_goal_daily_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_health_goal_daily_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of im_health_goal_daily_histories.
     */
    distinct?: Im_health_goal_daily_historyScalarFieldEnum | Im_health_goal_daily_historyScalarFieldEnum[]
  }


  /**
   * im_health_goal_daily_history findMany
   */
  export type im_health_goal_daily_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal_daily_history
     */
    select?: im_health_goal_daily_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goal_daily_historyInclude<ExtArgs> | null
    /**
     * Filter, which im_health_goal_daily_histories to fetch.
     */
    where?: im_health_goal_daily_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_health_goal_daily_histories to fetch.
     */
    orderBy?: im_health_goal_daily_historyOrderByWithRelationInput | im_health_goal_daily_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing im_health_goal_daily_histories.
     */
    cursor?: im_health_goal_daily_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_health_goal_daily_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_health_goal_daily_histories.
     */
    skip?: number
    distinct?: Im_health_goal_daily_historyScalarFieldEnum | Im_health_goal_daily_historyScalarFieldEnum[]
  }


  /**
   * im_health_goal_daily_history create
   */
  export type im_health_goal_daily_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal_daily_history
     */
    select?: im_health_goal_daily_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goal_daily_historyInclude<ExtArgs> | null
    /**
     * The data needed to create a im_health_goal_daily_history.
     */
    data: XOR<im_health_goal_daily_historyCreateInput, im_health_goal_daily_historyUncheckedCreateInput>
  }


  /**
   * im_health_goal_daily_history createMany
   */
  export type im_health_goal_daily_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many im_health_goal_daily_histories.
     */
    data: im_health_goal_daily_historyCreateManyInput | im_health_goal_daily_historyCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * im_health_goal_daily_history update
   */
  export type im_health_goal_daily_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal_daily_history
     */
    select?: im_health_goal_daily_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goal_daily_historyInclude<ExtArgs> | null
    /**
     * The data needed to update a im_health_goal_daily_history.
     */
    data: XOR<im_health_goal_daily_historyUpdateInput, im_health_goal_daily_historyUncheckedUpdateInput>
    /**
     * Choose, which im_health_goal_daily_history to update.
     */
    where: im_health_goal_daily_historyWhereUniqueInput
  }


  /**
   * im_health_goal_daily_history updateMany
   */
  export type im_health_goal_daily_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update im_health_goal_daily_histories.
     */
    data: XOR<im_health_goal_daily_historyUpdateManyMutationInput, im_health_goal_daily_historyUncheckedUpdateManyInput>
    /**
     * Filter which im_health_goal_daily_histories to update
     */
    where?: im_health_goal_daily_historyWhereInput
  }


  /**
   * im_health_goal_daily_history upsert
   */
  export type im_health_goal_daily_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal_daily_history
     */
    select?: im_health_goal_daily_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goal_daily_historyInclude<ExtArgs> | null
    /**
     * The filter to search for the im_health_goal_daily_history to update in case it exists.
     */
    where: im_health_goal_daily_historyWhereUniqueInput
    /**
     * In case the im_health_goal_daily_history found by the `where` argument doesn't exist, create a new im_health_goal_daily_history with this data.
     */
    create: XOR<im_health_goal_daily_historyCreateInput, im_health_goal_daily_historyUncheckedCreateInput>
    /**
     * In case the im_health_goal_daily_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<im_health_goal_daily_historyUpdateInput, im_health_goal_daily_historyUncheckedUpdateInput>
  }


  /**
   * im_health_goal_daily_history delete
   */
  export type im_health_goal_daily_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal_daily_history
     */
    select?: im_health_goal_daily_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goal_daily_historyInclude<ExtArgs> | null
    /**
     * Filter which im_health_goal_daily_history to delete.
     */
    where: im_health_goal_daily_historyWhereUniqueInput
  }


  /**
   * im_health_goal_daily_history deleteMany
   */
  export type im_health_goal_daily_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which im_health_goal_daily_histories to delete
     */
    where?: im_health_goal_daily_historyWhereInput
  }


  /**
   * im_health_goal_daily_history without action
   */
  export type im_health_goal_daily_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health_goal_daily_history
     */
    select?: im_health_goal_daily_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_health_goal_daily_historyInclude<ExtArgs> | null
  }



  /**
   * Model im_meal
   */

  export type AggregateIm_meal = {
    _count: Im_mealCountAggregateOutputType | null
    _avg: Im_mealAvgAggregateOutputType | null
    _sum: Im_mealSumAggregateOutputType | null
    _min: Im_mealMinAggregateOutputType | null
    _max: Im_mealMaxAggregateOutputType | null
  }

  export type Im_mealAvgAggregateOutputType = {
    id_meal: number | null
    meal_quantity: number | null
    meal_calories: number | null
    meal_carbs: number | null
    meal_prots: number | null
    meal_fats: number | null
    meal_length: number | null
    meal_difficulty: number | null
    meal_season: number | null
    id_nutrition: number | null
  }

  export type Im_mealSumAggregateOutputType = {
    id_meal: number | null
    meal_quantity: number | null
    meal_calories: number | null
    meal_carbs: number | null
    meal_prots: number | null
    meal_fats: number | null
    meal_length: number | null
    meal_difficulty: number | null
    meal_season: number | null
    id_nutrition: number | null
  }

  export type Im_mealMinAggregateOutputType = {
    id_meal: number | null
    meal_name: string | null
    meal_quantity: number | null
    meal_calories: number | null
    meal_carbs: number | null
    meal_prots: number | null
    meal_fats: number | null
    meal_description: string | null
    meal_length: number | null
    meal_image: string | null
    meal_difficulty: number | null
    meal_season: number | null
    id_nutrition: number | null
  }

  export type Im_mealMaxAggregateOutputType = {
    id_meal: number | null
    meal_name: string | null
    meal_quantity: number | null
    meal_calories: number | null
    meal_carbs: number | null
    meal_prots: number | null
    meal_fats: number | null
    meal_description: string | null
    meal_length: number | null
    meal_image: string | null
    meal_difficulty: number | null
    meal_season: number | null
    id_nutrition: number | null
  }

  export type Im_mealCountAggregateOutputType = {
    id_meal: number
    meal_name: number
    meal_quantity: number
    meal_calories: number
    meal_carbs: number
    meal_prots: number
    meal_fats: number
    meal_description: number
    meal_length: number
    meal_image: number
    meal_difficulty: number
    meal_season: number
    id_nutrition: number
    _all: number
  }


  export type Im_mealAvgAggregateInputType = {
    id_meal?: true
    meal_quantity?: true
    meal_calories?: true
    meal_carbs?: true
    meal_prots?: true
    meal_fats?: true
    meal_length?: true
    meal_difficulty?: true
    meal_season?: true
    id_nutrition?: true
  }

  export type Im_mealSumAggregateInputType = {
    id_meal?: true
    meal_quantity?: true
    meal_calories?: true
    meal_carbs?: true
    meal_prots?: true
    meal_fats?: true
    meal_length?: true
    meal_difficulty?: true
    meal_season?: true
    id_nutrition?: true
  }

  export type Im_mealMinAggregateInputType = {
    id_meal?: true
    meal_name?: true
    meal_quantity?: true
    meal_calories?: true
    meal_carbs?: true
    meal_prots?: true
    meal_fats?: true
    meal_description?: true
    meal_length?: true
    meal_image?: true
    meal_difficulty?: true
    meal_season?: true
    id_nutrition?: true
  }

  export type Im_mealMaxAggregateInputType = {
    id_meal?: true
    meal_name?: true
    meal_quantity?: true
    meal_calories?: true
    meal_carbs?: true
    meal_prots?: true
    meal_fats?: true
    meal_description?: true
    meal_length?: true
    meal_image?: true
    meal_difficulty?: true
    meal_season?: true
    id_nutrition?: true
  }

  export type Im_mealCountAggregateInputType = {
    id_meal?: true
    meal_name?: true
    meal_quantity?: true
    meal_calories?: true
    meal_carbs?: true
    meal_prots?: true
    meal_fats?: true
    meal_description?: true
    meal_length?: true
    meal_image?: true
    meal_difficulty?: true
    meal_season?: true
    id_nutrition?: true
    _all?: true
  }

  export type Im_mealAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which im_meal to aggregate.
     */
    where?: im_mealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_meals to fetch.
     */
    orderBy?: im_mealOrderByWithRelationInput | im_mealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: im_mealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_meals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_meals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned im_meals
    **/
    _count?: true | Im_mealCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Im_mealAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Im_mealSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Im_mealMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Im_mealMaxAggregateInputType
  }

  export type GetIm_mealAggregateType<T extends Im_mealAggregateArgs> = {
        [P in keyof T & keyof AggregateIm_meal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIm_meal[P]>
      : GetScalarType<T[P], AggregateIm_meal[P]>
  }




  export type im_mealGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: im_mealWhereInput
    orderBy?: im_mealOrderByWithAggregationInput | im_mealOrderByWithAggregationInput[]
    by: Im_mealScalarFieldEnum[] | Im_mealScalarFieldEnum
    having?: im_mealScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Im_mealCountAggregateInputType | true
    _avg?: Im_mealAvgAggregateInputType
    _sum?: Im_mealSumAggregateInputType
    _min?: Im_mealMinAggregateInputType
    _max?: Im_mealMaxAggregateInputType
  }

  export type Im_mealGroupByOutputType = {
    id_meal: number
    meal_name: string
    meal_quantity: number
    meal_calories: number
    meal_carbs: number
    meal_prots: number
    meal_fats: number
    meal_description: string
    meal_length: number
    meal_image: string
    meal_difficulty: number
    meal_season: number
    id_nutrition: number
    _count: Im_mealCountAggregateOutputType | null
    _avg: Im_mealAvgAggregateOutputType | null
    _sum: Im_mealSumAggregateOutputType | null
    _min: Im_mealMinAggregateOutputType | null
    _max: Im_mealMaxAggregateOutputType | null
  }

  type GetIm_mealGroupByPayload<T extends im_mealGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Im_mealGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Im_mealGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Im_mealGroupByOutputType[P]>
            : GetScalarType<T[P], Im_mealGroupByOutputType[P]>
        }
      >
    >


  export type im_mealSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_meal?: boolean
    meal_name?: boolean
    meal_quantity?: boolean
    meal_calories?: boolean
    meal_carbs?: boolean
    meal_prots?: boolean
    meal_fats?: boolean
    meal_description?: boolean
    meal_length?: boolean
    meal_image?: boolean
    meal_difficulty?: boolean
    meal_season?: boolean
    id_nutrition?: boolean
    im_nutrition?: boolean | im_nutritionDefaultArgs<ExtArgs>
    im_recipe?: boolean | im_meal$im_recipeArgs<ExtArgs>
    _count?: boolean | Im_mealCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["im_meal"]>

  export type im_mealSelectScalar = {
    id_meal?: boolean
    meal_name?: boolean
    meal_quantity?: boolean
    meal_calories?: boolean
    meal_carbs?: boolean
    meal_prots?: boolean
    meal_fats?: boolean
    meal_description?: boolean
    meal_length?: boolean
    meal_image?: boolean
    meal_difficulty?: boolean
    meal_season?: boolean
    id_nutrition?: boolean
  }

  export type im_mealInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    im_nutrition?: boolean | im_nutritionDefaultArgs<ExtArgs>
    im_recipe?: boolean | im_meal$im_recipeArgs<ExtArgs>
    _count?: boolean | Im_mealCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $im_mealPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "im_meal"
    objects: {
      im_nutrition: Prisma.$im_nutritionPayload<ExtArgs>
      im_recipe: Prisma.$im_recipePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_meal: number
      meal_name: string
      meal_quantity: number
      meal_calories: number
      meal_carbs: number
      meal_prots: number
      meal_fats: number
      meal_description: string
      meal_length: number
      meal_image: string
      meal_difficulty: number
      meal_season: number
      id_nutrition: number
    }, ExtArgs["result"]["im_meal"]>
    composites: {}
  }


  type im_mealGetPayload<S extends boolean | null | undefined | im_mealDefaultArgs> = $Result.GetResult<Prisma.$im_mealPayload, S>

  type im_mealCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<im_mealFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Im_mealCountAggregateInputType | true
    }

  export interface im_mealDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['im_meal'], meta: { name: 'im_meal' } }
    /**
     * Find zero or one Im_meal that matches the filter.
     * @param {im_mealFindUniqueArgs} args - Arguments to find a Im_meal
     * @example
     * // Get one Im_meal
     * const im_meal = await prisma.im_meal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends im_mealFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, im_mealFindUniqueArgs<ExtArgs>>
    ): Prisma__im_mealClient<$Result.GetResult<Prisma.$im_mealPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Im_meal that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {im_mealFindUniqueOrThrowArgs} args - Arguments to find a Im_meal
     * @example
     * // Get one Im_meal
     * const im_meal = await prisma.im_meal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends im_mealFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, im_mealFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__im_mealClient<$Result.GetResult<Prisma.$im_mealPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Im_meal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_mealFindFirstArgs} args - Arguments to find a Im_meal
     * @example
     * // Get one Im_meal
     * const im_meal = await prisma.im_meal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends im_mealFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, im_mealFindFirstArgs<ExtArgs>>
    ): Prisma__im_mealClient<$Result.GetResult<Prisma.$im_mealPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Im_meal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_mealFindFirstOrThrowArgs} args - Arguments to find a Im_meal
     * @example
     * // Get one Im_meal
     * const im_meal = await prisma.im_meal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends im_mealFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, im_mealFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__im_mealClient<$Result.GetResult<Prisma.$im_mealPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Im_meals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_mealFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Im_meals
     * const im_meals = await prisma.im_meal.findMany()
     * 
     * // Get first 10 Im_meals
     * const im_meals = await prisma.im_meal.findMany({ take: 10 })
     * 
     * // Only select the `id_meal`
     * const im_mealWithId_mealOnly = await prisma.im_meal.findMany({ select: { id_meal: true } })
     * 
    **/
    findMany<T extends im_mealFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_mealFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$im_mealPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Im_meal.
     * @param {im_mealCreateArgs} args - Arguments to create a Im_meal.
     * @example
     * // Create one Im_meal
     * const Im_meal = await prisma.im_meal.create({
     *   data: {
     *     // ... data to create a Im_meal
     *   }
     * })
     * 
    **/
    create<T extends im_mealCreateArgs<ExtArgs>>(
      args: SelectSubset<T, im_mealCreateArgs<ExtArgs>>
    ): Prisma__im_mealClient<$Result.GetResult<Prisma.$im_mealPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Im_meals.
     *     @param {im_mealCreateManyArgs} args - Arguments to create many Im_meals.
     *     @example
     *     // Create many Im_meals
     *     const im_meal = await prisma.im_meal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends im_mealCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_mealCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Im_meal.
     * @param {im_mealDeleteArgs} args - Arguments to delete one Im_meal.
     * @example
     * // Delete one Im_meal
     * const Im_meal = await prisma.im_meal.delete({
     *   where: {
     *     // ... filter to delete one Im_meal
     *   }
     * })
     * 
    **/
    delete<T extends im_mealDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, im_mealDeleteArgs<ExtArgs>>
    ): Prisma__im_mealClient<$Result.GetResult<Prisma.$im_mealPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Im_meal.
     * @param {im_mealUpdateArgs} args - Arguments to update one Im_meal.
     * @example
     * // Update one Im_meal
     * const im_meal = await prisma.im_meal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends im_mealUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, im_mealUpdateArgs<ExtArgs>>
    ): Prisma__im_mealClient<$Result.GetResult<Prisma.$im_mealPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Im_meals.
     * @param {im_mealDeleteManyArgs} args - Arguments to filter Im_meals to delete.
     * @example
     * // Delete a few Im_meals
     * const { count } = await prisma.im_meal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends im_mealDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_mealDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Im_meals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_mealUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Im_meals
     * const im_meal = await prisma.im_meal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends im_mealUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, im_mealUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Im_meal.
     * @param {im_mealUpsertArgs} args - Arguments to update or create a Im_meal.
     * @example
     * // Update or create a Im_meal
     * const im_meal = await prisma.im_meal.upsert({
     *   create: {
     *     // ... data to create a Im_meal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Im_meal we want to update
     *   }
     * })
    **/
    upsert<T extends im_mealUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, im_mealUpsertArgs<ExtArgs>>
    ): Prisma__im_mealClient<$Result.GetResult<Prisma.$im_mealPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Im_meals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_mealCountArgs} args - Arguments to filter Im_meals to count.
     * @example
     * // Count the number of Im_meals
     * const count = await prisma.im_meal.count({
     *   where: {
     *     // ... the filter for the Im_meals we want to count
     *   }
     * })
    **/
    count<T extends im_mealCountArgs>(
      args?: Subset<T, im_mealCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Im_mealCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Im_meal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Im_mealAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Im_mealAggregateArgs>(args: Subset<T, Im_mealAggregateArgs>): Prisma.PrismaPromise<GetIm_mealAggregateType<T>>

    /**
     * Group by Im_meal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_mealGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends im_mealGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: im_mealGroupByArgs['orderBy'] }
        : { orderBy?: im_mealGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, im_mealGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIm_mealGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the im_meal model
   */
  readonly fields: im_mealFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for im_meal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__im_mealClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    im_nutrition<T extends im_nutritionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, im_nutritionDefaultArgs<ExtArgs>>): Prisma__im_nutritionClient<$Result.GetResult<Prisma.$im_nutritionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    im_recipe<T extends im_meal$im_recipeArgs<ExtArgs> = {}>(args?: Subset<T, im_meal$im_recipeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$im_recipePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the im_meal model
   */ 
  interface im_mealFieldRefs {
    readonly id_meal: FieldRef<"im_meal", 'Int'>
    readonly meal_name: FieldRef<"im_meal", 'String'>
    readonly meal_quantity: FieldRef<"im_meal", 'Int'>
    readonly meal_calories: FieldRef<"im_meal", 'Int'>
    readonly meal_carbs: FieldRef<"im_meal", 'Int'>
    readonly meal_prots: FieldRef<"im_meal", 'Int'>
    readonly meal_fats: FieldRef<"im_meal", 'Int'>
    readonly meal_description: FieldRef<"im_meal", 'String'>
    readonly meal_length: FieldRef<"im_meal", 'Int'>
    readonly meal_image: FieldRef<"im_meal", 'String'>
    readonly meal_difficulty: FieldRef<"im_meal", 'Int'>
    readonly meal_season: FieldRef<"im_meal", 'Int'>
    readonly id_nutrition: FieldRef<"im_meal", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * im_meal findUnique
   */
  export type im_mealFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_meal
     */
    select?: im_mealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_mealInclude<ExtArgs> | null
    /**
     * Filter, which im_meal to fetch.
     */
    where: im_mealWhereUniqueInput
  }


  /**
   * im_meal findUniqueOrThrow
   */
  export type im_mealFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_meal
     */
    select?: im_mealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_mealInclude<ExtArgs> | null
    /**
     * Filter, which im_meal to fetch.
     */
    where: im_mealWhereUniqueInput
  }


  /**
   * im_meal findFirst
   */
  export type im_mealFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_meal
     */
    select?: im_mealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_mealInclude<ExtArgs> | null
    /**
     * Filter, which im_meal to fetch.
     */
    where?: im_mealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_meals to fetch.
     */
    orderBy?: im_mealOrderByWithRelationInput | im_mealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for im_meals.
     */
    cursor?: im_mealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_meals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_meals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of im_meals.
     */
    distinct?: Im_mealScalarFieldEnum | Im_mealScalarFieldEnum[]
  }


  /**
   * im_meal findFirstOrThrow
   */
  export type im_mealFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_meal
     */
    select?: im_mealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_mealInclude<ExtArgs> | null
    /**
     * Filter, which im_meal to fetch.
     */
    where?: im_mealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_meals to fetch.
     */
    orderBy?: im_mealOrderByWithRelationInput | im_mealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for im_meals.
     */
    cursor?: im_mealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_meals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_meals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of im_meals.
     */
    distinct?: Im_mealScalarFieldEnum | Im_mealScalarFieldEnum[]
  }


  /**
   * im_meal findMany
   */
  export type im_mealFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_meal
     */
    select?: im_mealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_mealInclude<ExtArgs> | null
    /**
     * Filter, which im_meals to fetch.
     */
    where?: im_mealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_meals to fetch.
     */
    orderBy?: im_mealOrderByWithRelationInput | im_mealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing im_meals.
     */
    cursor?: im_mealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_meals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_meals.
     */
    skip?: number
    distinct?: Im_mealScalarFieldEnum | Im_mealScalarFieldEnum[]
  }


  /**
   * im_meal create
   */
  export type im_mealCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_meal
     */
    select?: im_mealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_mealInclude<ExtArgs> | null
    /**
     * The data needed to create a im_meal.
     */
    data: XOR<im_mealCreateInput, im_mealUncheckedCreateInput>
  }


  /**
   * im_meal createMany
   */
  export type im_mealCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many im_meals.
     */
    data: im_mealCreateManyInput | im_mealCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * im_meal update
   */
  export type im_mealUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_meal
     */
    select?: im_mealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_mealInclude<ExtArgs> | null
    /**
     * The data needed to update a im_meal.
     */
    data: XOR<im_mealUpdateInput, im_mealUncheckedUpdateInput>
    /**
     * Choose, which im_meal to update.
     */
    where: im_mealWhereUniqueInput
  }


  /**
   * im_meal updateMany
   */
  export type im_mealUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update im_meals.
     */
    data: XOR<im_mealUpdateManyMutationInput, im_mealUncheckedUpdateManyInput>
    /**
     * Filter which im_meals to update
     */
    where?: im_mealWhereInput
  }


  /**
   * im_meal upsert
   */
  export type im_mealUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_meal
     */
    select?: im_mealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_mealInclude<ExtArgs> | null
    /**
     * The filter to search for the im_meal to update in case it exists.
     */
    where: im_mealWhereUniqueInput
    /**
     * In case the im_meal found by the `where` argument doesn't exist, create a new im_meal with this data.
     */
    create: XOR<im_mealCreateInput, im_mealUncheckedCreateInput>
    /**
     * In case the im_meal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<im_mealUpdateInput, im_mealUncheckedUpdateInput>
  }


  /**
   * im_meal delete
   */
  export type im_mealDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_meal
     */
    select?: im_mealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_mealInclude<ExtArgs> | null
    /**
     * Filter which im_meal to delete.
     */
    where: im_mealWhereUniqueInput
  }


  /**
   * im_meal deleteMany
   */
  export type im_mealDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which im_meals to delete
     */
    where?: im_mealWhereInput
  }


  /**
   * im_meal.im_recipe
   */
  export type im_meal$im_recipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_recipe
     */
    select?: im_recipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_recipeInclude<ExtArgs> | null
    where?: im_recipeWhereInput
    orderBy?: im_recipeOrderByWithRelationInput | im_recipeOrderByWithRelationInput[]
    cursor?: im_recipeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Im_recipeScalarFieldEnum | Im_recipeScalarFieldEnum[]
  }


  /**
   * im_meal without action
   */
  export type im_mealDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_meal
     */
    select?: im_mealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_mealInclude<ExtArgs> | null
  }



  /**
   * Model im_nutrition
   */

  export type AggregateIm_nutrition = {
    _count: Im_nutritionCountAggregateOutputType | null
    _avg: Im_nutritionAvgAggregateOutputType | null
    _sum: Im_nutritionSumAggregateOutputType | null
    _min: Im_nutritionMinAggregateOutputType | null
    _max: Im_nutritionMaxAggregateOutputType | null
  }

  export type Im_nutritionAvgAggregateOutputType = {
    id_nutrition: number | null
    nutrition_goal: number | null
    nutrition_goal_calories: number | null
    nutrition_goal_carbs: number | null
    nutrition_goal_prots: number | null
    nutrition_goal_fats: number | null
    id_user: number | null
  }

  export type Im_nutritionSumAggregateOutputType = {
    id_nutrition: number | null
    nutrition_goal: number | null
    nutrition_goal_calories: number | null
    nutrition_goal_carbs: number | null
    nutrition_goal_prots: number | null
    nutrition_goal_fats: number | null
    id_user: number | null
  }

  export type Im_nutritionMinAggregateOutputType = {
    id_nutrition: number | null
    nutrition_goal: number | null
    nutrition_goal_calories: number | null
    nutrition_goal_carbs: number | null
    nutrition_goal_prots: number | null
    nutrition_goal_fats: number | null
    id_user: number | null
  }

  export type Im_nutritionMaxAggregateOutputType = {
    id_nutrition: number | null
    nutrition_goal: number | null
    nutrition_goal_calories: number | null
    nutrition_goal_carbs: number | null
    nutrition_goal_prots: number | null
    nutrition_goal_fats: number | null
    id_user: number | null
  }

  export type Im_nutritionCountAggregateOutputType = {
    id_nutrition: number
    nutrition_goal: number
    nutrition_goal_calories: number
    nutrition_goal_carbs: number
    nutrition_goal_prots: number
    nutrition_goal_fats: number
    id_user: number
    _all: number
  }


  export type Im_nutritionAvgAggregateInputType = {
    id_nutrition?: true
    nutrition_goal?: true
    nutrition_goal_calories?: true
    nutrition_goal_carbs?: true
    nutrition_goal_prots?: true
    nutrition_goal_fats?: true
    id_user?: true
  }

  export type Im_nutritionSumAggregateInputType = {
    id_nutrition?: true
    nutrition_goal?: true
    nutrition_goal_calories?: true
    nutrition_goal_carbs?: true
    nutrition_goal_prots?: true
    nutrition_goal_fats?: true
    id_user?: true
  }

  export type Im_nutritionMinAggregateInputType = {
    id_nutrition?: true
    nutrition_goal?: true
    nutrition_goal_calories?: true
    nutrition_goal_carbs?: true
    nutrition_goal_prots?: true
    nutrition_goal_fats?: true
    id_user?: true
  }

  export type Im_nutritionMaxAggregateInputType = {
    id_nutrition?: true
    nutrition_goal?: true
    nutrition_goal_calories?: true
    nutrition_goal_carbs?: true
    nutrition_goal_prots?: true
    nutrition_goal_fats?: true
    id_user?: true
  }

  export type Im_nutritionCountAggregateInputType = {
    id_nutrition?: true
    nutrition_goal?: true
    nutrition_goal_calories?: true
    nutrition_goal_carbs?: true
    nutrition_goal_prots?: true
    nutrition_goal_fats?: true
    id_user?: true
    _all?: true
  }

  export type Im_nutritionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which im_nutrition to aggregate.
     */
    where?: im_nutritionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_nutritions to fetch.
     */
    orderBy?: im_nutritionOrderByWithRelationInput | im_nutritionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: im_nutritionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_nutritions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_nutritions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned im_nutritions
    **/
    _count?: true | Im_nutritionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Im_nutritionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Im_nutritionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Im_nutritionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Im_nutritionMaxAggregateInputType
  }

  export type GetIm_nutritionAggregateType<T extends Im_nutritionAggregateArgs> = {
        [P in keyof T & keyof AggregateIm_nutrition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIm_nutrition[P]>
      : GetScalarType<T[P], AggregateIm_nutrition[P]>
  }




  export type im_nutritionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: im_nutritionWhereInput
    orderBy?: im_nutritionOrderByWithAggregationInput | im_nutritionOrderByWithAggregationInput[]
    by: Im_nutritionScalarFieldEnum[] | Im_nutritionScalarFieldEnum
    having?: im_nutritionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Im_nutritionCountAggregateInputType | true
    _avg?: Im_nutritionAvgAggregateInputType
    _sum?: Im_nutritionSumAggregateInputType
    _min?: Im_nutritionMinAggregateInputType
    _max?: Im_nutritionMaxAggregateInputType
  }

  export type Im_nutritionGroupByOutputType = {
    id_nutrition: number
    nutrition_goal: number
    nutrition_goal_calories: number
    nutrition_goal_carbs: number
    nutrition_goal_prots: number
    nutrition_goal_fats: number
    id_user: number
    _count: Im_nutritionCountAggregateOutputType | null
    _avg: Im_nutritionAvgAggregateOutputType | null
    _sum: Im_nutritionSumAggregateOutputType | null
    _min: Im_nutritionMinAggregateOutputType | null
    _max: Im_nutritionMaxAggregateOutputType | null
  }

  type GetIm_nutritionGroupByPayload<T extends im_nutritionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Im_nutritionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Im_nutritionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Im_nutritionGroupByOutputType[P]>
            : GetScalarType<T[P], Im_nutritionGroupByOutputType[P]>
        }
      >
    >


  export type im_nutritionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_nutrition?: boolean
    nutrition_goal?: boolean
    nutrition_goal_calories?: boolean
    nutrition_goal_carbs?: boolean
    nutrition_goal_prots?: boolean
    nutrition_goal_fats?: boolean
    id_user?: boolean
    im_meal?: boolean | im_nutrition$im_mealArgs<ExtArgs>
    im_user?: boolean | im_userDefaultArgs<ExtArgs>
    _count?: boolean | Im_nutritionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["im_nutrition"]>

  export type im_nutritionSelectScalar = {
    id_nutrition?: boolean
    nutrition_goal?: boolean
    nutrition_goal_calories?: boolean
    nutrition_goal_carbs?: boolean
    nutrition_goal_prots?: boolean
    nutrition_goal_fats?: boolean
    id_user?: boolean
  }

  export type im_nutritionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    im_meal?: boolean | im_nutrition$im_mealArgs<ExtArgs>
    im_user?: boolean | im_userDefaultArgs<ExtArgs>
    _count?: boolean | Im_nutritionCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $im_nutritionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "im_nutrition"
    objects: {
      im_meal: Prisma.$im_mealPayload<ExtArgs>[]
      im_user: Prisma.$im_userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_nutrition: number
      nutrition_goal: number
      nutrition_goal_calories: number
      nutrition_goal_carbs: number
      nutrition_goal_prots: number
      nutrition_goal_fats: number
      id_user: number
    }, ExtArgs["result"]["im_nutrition"]>
    composites: {}
  }


  type im_nutritionGetPayload<S extends boolean | null | undefined | im_nutritionDefaultArgs> = $Result.GetResult<Prisma.$im_nutritionPayload, S>

  type im_nutritionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<im_nutritionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Im_nutritionCountAggregateInputType | true
    }

  export interface im_nutritionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['im_nutrition'], meta: { name: 'im_nutrition' } }
    /**
     * Find zero or one Im_nutrition that matches the filter.
     * @param {im_nutritionFindUniqueArgs} args - Arguments to find a Im_nutrition
     * @example
     * // Get one Im_nutrition
     * const im_nutrition = await prisma.im_nutrition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends im_nutritionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, im_nutritionFindUniqueArgs<ExtArgs>>
    ): Prisma__im_nutritionClient<$Result.GetResult<Prisma.$im_nutritionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Im_nutrition that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {im_nutritionFindUniqueOrThrowArgs} args - Arguments to find a Im_nutrition
     * @example
     * // Get one Im_nutrition
     * const im_nutrition = await prisma.im_nutrition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends im_nutritionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, im_nutritionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__im_nutritionClient<$Result.GetResult<Prisma.$im_nutritionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Im_nutrition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_nutritionFindFirstArgs} args - Arguments to find a Im_nutrition
     * @example
     * // Get one Im_nutrition
     * const im_nutrition = await prisma.im_nutrition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends im_nutritionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, im_nutritionFindFirstArgs<ExtArgs>>
    ): Prisma__im_nutritionClient<$Result.GetResult<Prisma.$im_nutritionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Im_nutrition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_nutritionFindFirstOrThrowArgs} args - Arguments to find a Im_nutrition
     * @example
     * // Get one Im_nutrition
     * const im_nutrition = await prisma.im_nutrition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends im_nutritionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, im_nutritionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__im_nutritionClient<$Result.GetResult<Prisma.$im_nutritionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Im_nutritions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_nutritionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Im_nutritions
     * const im_nutritions = await prisma.im_nutrition.findMany()
     * 
     * // Get first 10 Im_nutritions
     * const im_nutritions = await prisma.im_nutrition.findMany({ take: 10 })
     * 
     * // Only select the `id_nutrition`
     * const im_nutritionWithId_nutritionOnly = await prisma.im_nutrition.findMany({ select: { id_nutrition: true } })
     * 
    **/
    findMany<T extends im_nutritionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_nutritionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$im_nutritionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Im_nutrition.
     * @param {im_nutritionCreateArgs} args - Arguments to create a Im_nutrition.
     * @example
     * // Create one Im_nutrition
     * const Im_nutrition = await prisma.im_nutrition.create({
     *   data: {
     *     // ... data to create a Im_nutrition
     *   }
     * })
     * 
    **/
    create<T extends im_nutritionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, im_nutritionCreateArgs<ExtArgs>>
    ): Prisma__im_nutritionClient<$Result.GetResult<Prisma.$im_nutritionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Im_nutritions.
     *     @param {im_nutritionCreateManyArgs} args - Arguments to create many Im_nutritions.
     *     @example
     *     // Create many Im_nutritions
     *     const im_nutrition = await prisma.im_nutrition.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends im_nutritionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_nutritionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Im_nutrition.
     * @param {im_nutritionDeleteArgs} args - Arguments to delete one Im_nutrition.
     * @example
     * // Delete one Im_nutrition
     * const Im_nutrition = await prisma.im_nutrition.delete({
     *   where: {
     *     // ... filter to delete one Im_nutrition
     *   }
     * })
     * 
    **/
    delete<T extends im_nutritionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, im_nutritionDeleteArgs<ExtArgs>>
    ): Prisma__im_nutritionClient<$Result.GetResult<Prisma.$im_nutritionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Im_nutrition.
     * @param {im_nutritionUpdateArgs} args - Arguments to update one Im_nutrition.
     * @example
     * // Update one Im_nutrition
     * const im_nutrition = await prisma.im_nutrition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends im_nutritionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, im_nutritionUpdateArgs<ExtArgs>>
    ): Prisma__im_nutritionClient<$Result.GetResult<Prisma.$im_nutritionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Im_nutritions.
     * @param {im_nutritionDeleteManyArgs} args - Arguments to filter Im_nutritions to delete.
     * @example
     * // Delete a few Im_nutritions
     * const { count } = await prisma.im_nutrition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends im_nutritionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_nutritionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Im_nutritions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_nutritionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Im_nutritions
     * const im_nutrition = await prisma.im_nutrition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends im_nutritionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, im_nutritionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Im_nutrition.
     * @param {im_nutritionUpsertArgs} args - Arguments to update or create a Im_nutrition.
     * @example
     * // Update or create a Im_nutrition
     * const im_nutrition = await prisma.im_nutrition.upsert({
     *   create: {
     *     // ... data to create a Im_nutrition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Im_nutrition we want to update
     *   }
     * })
    **/
    upsert<T extends im_nutritionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, im_nutritionUpsertArgs<ExtArgs>>
    ): Prisma__im_nutritionClient<$Result.GetResult<Prisma.$im_nutritionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Im_nutritions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_nutritionCountArgs} args - Arguments to filter Im_nutritions to count.
     * @example
     * // Count the number of Im_nutritions
     * const count = await prisma.im_nutrition.count({
     *   where: {
     *     // ... the filter for the Im_nutritions we want to count
     *   }
     * })
    **/
    count<T extends im_nutritionCountArgs>(
      args?: Subset<T, im_nutritionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Im_nutritionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Im_nutrition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Im_nutritionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Im_nutritionAggregateArgs>(args: Subset<T, Im_nutritionAggregateArgs>): Prisma.PrismaPromise<GetIm_nutritionAggregateType<T>>

    /**
     * Group by Im_nutrition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_nutritionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends im_nutritionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: im_nutritionGroupByArgs['orderBy'] }
        : { orderBy?: im_nutritionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, im_nutritionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIm_nutritionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the im_nutrition model
   */
  readonly fields: im_nutritionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for im_nutrition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__im_nutritionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    im_meal<T extends im_nutrition$im_mealArgs<ExtArgs> = {}>(args?: Subset<T, im_nutrition$im_mealArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$im_mealPayload<ExtArgs>, T, 'findMany'> | Null>;

    im_user<T extends im_userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, im_userDefaultArgs<ExtArgs>>): Prisma__im_userClient<$Result.GetResult<Prisma.$im_userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the im_nutrition model
   */ 
  interface im_nutritionFieldRefs {
    readonly id_nutrition: FieldRef<"im_nutrition", 'Int'>
    readonly nutrition_goal: FieldRef<"im_nutrition", 'Int'>
    readonly nutrition_goal_calories: FieldRef<"im_nutrition", 'Int'>
    readonly nutrition_goal_carbs: FieldRef<"im_nutrition", 'Int'>
    readonly nutrition_goal_prots: FieldRef<"im_nutrition", 'Int'>
    readonly nutrition_goal_fats: FieldRef<"im_nutrition", 'Int'>
    readonly id_user: FieldRef<"im_nutrition", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * im_nutrition findUnique
   */
  export type im_nutritionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_nutrition
     */
    select?: im_nutritionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_nutritionInclude<ExtArgs> | null
    /**
     * Filter, which im_nutrition to fetch.
     */
    where: im_nutritionWhereUniqueInput
  }


  /**
   * im_nutrition findUniqueOrThrow
   */
  export type im_nutritionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_nutrition
     */
    select?: im_nutritionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_nutritionInclude<ExtArgs> | null
    /**
     * Filter, which im_nutrition to fetch.
     */
    where: im_nutritionWhereUniqueInput
  }


  /**
   * im_nutrition findFirst
   */
  export type im_nutritionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_nutrition
     */
    select?: im_nutritionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_nutritionInclude<ExtArgs> | null
    /**
     * Filter, which im_nutrition to fetch.
     */
    where?: im_nutritionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_nutritions to fetch.
     */
    orderBy?: im_nutritionOrderByWithRelationInput | im_nutritionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for im_nutritions.
     */
    cursor?: im_nutritionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_nutritions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_nutritions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of im_nutritions.
     */
    distinct?: Im_nutritionScalarFieldEnum | Im_nutritionScalarFieldEnum[]
  }


  /**
   * im_nutrition findFirstOrThrow
   */
  export type im_nutritionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_nutrition
     */
    select?: im_nutritionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_nutritionInclude<ExtArgs> | null
    /**
     * Filter, which im_nutrition to fetch.
     */
    where?: im_nutritionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_nutritions to fetch.
     */
    orderBy?: im_nutritionOrderByWithRelationInput | im_nutritionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for im_nutritions.
     */
    cursor?: im_nutritionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_nutritions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_nutritions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of im_nutritions.
     */
    distinct?: Im_nutritionScalarFieldEnum | Im_nutritionScalarFieldEnum[]
  }


  /**
   * im_nutrition findMany
   */
  export type im_nutritionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_nutrition
     */
    select?: im_nutritionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_nutritionInclude<ExtArgs> | null
    /**
     * Filter, which im_nutritions to fetch.
     */
    where?: im_nutritionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_nutritions to fetch.
     */
    orderBy?: im_nutritionOrderByWithRelationInput | im_nutritionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing im_nutritions.
     */
    cursor?: im_nutritionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_nutritions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_nutritions.
     */
    skip?: number
    distinct?: Im_nutritionScalarFieldEnum | Im_nutritionScalarFieldEnum[]
  }


  /**
   * im_nutrition create
   */
  export type im_nutritionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_nutrition
     */
    select?: im_nutritionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_nutritionInclude<ExtArgs> | null
    /**
     * The data needed to create a im_nutrition.
     */
    data: XOR<im_nutritionCreateInput, im_nutritionUncheckedCreateInput>
  }


  /**
   * im_nutrition createMany
   */
  export type im_nutritionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many im_nutritions.
     */
    data: im_nutritionCreateManyInput | im_nutritionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * im_nutrition update
   */
  export type im_nutritionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_nutrition
     */
    select?: im_nutritionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_nutritionInclude<ExtArgs> | null
    /**
     * The data needed to update a im_nutrition.
     */
    data: XOR<im_nutritionUpdateInput, im_nutritionUncheckedUpdateInput>
    /**
     * Choose, which im_nutrition to update.
     */
    where: im_nutritionWhereUniqueInput
  }


  /**
   * im_nutrition updateMany
   */
  export type im_nutritionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update im_nutritions.
     */
    data: XOR<im_nutritionUpdateManyMutationInput, im_nutritionUncheckedUpdateManyInput>
    /**
     * Filter which im_nutritions to update
     */
    where?: im_nutritionWhereInput
  }


  /**
   * im_nutrition upsert
   */
  export type im_nutritionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_nutrition
     */
    select?: im_nutritionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_nutritionInclude<ExtArgs> | null
    /**
     * The filter to search for the im_nutrition to update in case it exists.
     */
    where: im_nutritionWhereUniqueInput
    /**
     * In case the im_nutrition found by the `where` argument doesn't exist, create a new im_nutrition with this data.
     */
    create: XOR<im_nutritionCreateInput, im_nutritionUncheckedCreateInput>
    /**
     * In case the im_nutrition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<im_nutritionUpdateInput, im_nutritionUncheckedUpdateInput>
  }


  /**
   * im_nutrition delete
   */
  export type im_nutritionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_nutrition
     */
    select?: im_nutritionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_nutritionInclude<ExtArgs> | null
    /**
     * Filter which im_nutrition to delete.
     */
    where: im_nutritionWhereUniqueInput
  }


  /**
   * im_nutrition deleteMany
   */
  export type im_nutritionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which im_nutritions to delete
     */
    where?: im_nutritionWhereInput
  }


  /**
   * im_nutrition.im_meal
   */
  export type im_nutrition$im_mealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_meal
     */
    select?: im_mealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_mealInclude<ExtArgs> | null
    where?: im_mealWhereInput
    orderBy?: im_mealOrderByWithRelationInput | im_mealOrderByWithRelationInput[]
    cursor?: im_mealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Im_mealScalarFieldEnum | Im_mealScalarFieldEnum[]
  }


  /**
   * im_nutrition without action
   */
  export type im_nutritionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_nutrition
     */
    select?: im_nutritionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_nutritionInclude<ExtArgs> | null
  }



  /**
   * Model im_recipe
   */

  export type AggregateIm_recipe = {
    _count: Im_recipeCountAggregateOutputType | null
    _avg: Im_recipeAvgAggregateOutputType | null
    _sum: Im_recipeSumAggregateOutputType | null
    _min: Im_recipeMinAggregateOutputType | null
    _max: Im_recipeMaxAggregateOutputType | null
  }

  export type Im_recipeAvgAggregateOutputType = {
    id_recipe: number | null
    id_meal: number | null
    id_food: number | null
  }

  export type Im_recipeSumAggregateOutputType = {
    id_recipe: number | null
    id_meal: number | null
    id_food: number | null
  }

  export type Im_recipeMinAggregateOutputType = {
    id_recipe: number | null
    id_meal: number | null
    id_food: number | null
  }

  export type Im_recipeMaxAggregateOutputType = {
    id_recipe: number | null
    id_meal: number | null
    id_food: number | null
  }

  export type Im_recipeCountAggregateOutputType = {
    id_recipe: number
    id_meal: number
    id_food: number
    _all: number
  }


  export type Im_recipeAvgAggregateInputType = {
    id_recipe?: true
    id_meal?: true
    id_food?: true
  }

  export type Im_recipeSumAggregateInputType = {
    id_recipe?: true
    id_meal?: true
    id_food?: true
  }

  export type Im_recipeMinAggregateInputType = {
    id_recipe?: true
    id_meal?: true
    id_food?: true
  }

  export type Im_recipeMaxAggregateInputType = {
    id_recipe?: true
    id_meal?: true
    id_food?: true
  }

  export type Im_recipeCountAggregateInputType = {
    id_recipe?: true
    id_meal?: true
    id_food?: true
    _all?: true
  }

  export type Im_recipeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which im_recipe to aggregate.
     */
    where?: im_recipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_recipes to fetch.
     */
    orderBy?: im_recipeOrderByWithRelationInput | im_recipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: im_recipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned im_recipes
    **/
    _count?: true | Im_recipeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Im_recipeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Im_recipeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Im_recipeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Im_recipeMaxAggregateInputType
  }

  export type GetIm_recipeAggregateType<T extends Im_recipeAggregateArgs> = {
        [P in keyof T & keyof AggregateIm_recipe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIm_recipe[P]>
      : GetScalarType<T[P], AggregateIm_recipe[P]>
  }




  export type im_recipeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: im_recipeWhereInput
    orderBy?: im_recipeOrderByWithAggregationInput | im_recipeOrderByWithAggregationInput[]
    by: Im_recipeScalarFieldEnum[] | Im_recipeScalarFieldEnum
    having?: im_recipeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Im_recipeCountAggregateInputType | true
    _avg?: Im_recipeAvgAggregateInputType
    _sum?: Im_recipeSumAggregateInputType
    _min?: Im_recipeMinAggregateInputType
    _max?: Im_recipeMaxAggregateInputType
  }

  export type Im_recipeGroupByOutputType = {
    id_recipe: number
    id_meal: number
    id_food: number
    _count: Im_recipeCountAggregateOutputType | null
    _avg: Im_recipeAvgAggregateOutputType | null
    _sum: Im_recipeSumAggregateOutputType | null
    _min: Im_recipeMinAggregateOutputType | null
    _max: Im_recipeMaxAggregateOutputType | null
  }

  type GetIm_recipeGroupByPayload<T extends im_recipeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Im_recipeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Im_recipeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Im_recipeGroupByOutputType[P]>
            : GetScalarType<T[P], Im_recipeGroupByOutputType[P]>
        }
      >
    >


  export type im_recipeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_recipe?: boolean
    id_meal?: boolean
    id_food?: boolean
    im_meal?: boolean | im_mealDefaultArgs<ExtArgs>
    im_food?: boolean | im_foodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["im_recipe"]>

  export type im_recipeSelectScalar = {
    id_recipe?: boolean
    id_meal?: boolean
    id_food?: boolean
  }

  export type im_recipeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    im_meal?: boolean | im_mealDefaultArgs<ExtArgs>
    im_food?: boolean | im_foodDefaultArgs<ExtArgs>
  }


  export type $im_recipePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "im_recipe"
    objects: {
      im_meal: Prisma.$im_mealPayload<ExtArgs>
      im_food: Prisma.$im_foodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_recipe: number
      id_meal: number
      id_food: number
    }, ExtArgs["result"]["im_recipe"]>
    composites: {}
  }


  type im_recipeGetPayload<S extends boolean | null | undefined | im_recipeDefaultArgs> = $Result.GetResult<Prisma.$im_recipePayload, S>

  type im_recipeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<im_recipeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Im_recipeCountAggregateInputType | true
    }

  export interface im_recipeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['im_recipe'], meta: { name: 'im_recipe' } }
    /**
     * Find zero or one Im_recipe that matches the filter.
     * @param {im_recipeFindUniqueArgs} args - Arguments to find a Im_recipe
     * @example
     * // Get one Im_recipe
     * const im_recipe = await prisma.im_recipe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends im_recipeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, im_recipeFindUniqueArgs<ExtArgs>>
    ): Prisma__im_recipeClient<$Result.GetResult<Prisma.$im_recipePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Im_recipe that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {im_recipeFindUniqueOrThrowArgs} args - Arguments to find a Im_recipe
     * @example
     * // Get one Im_recipe
     * const im_recipe = await prisma.im_recipe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends im_recipeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, im_recipeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__im_recipeClient<$Result.GetResult<Prisma.$im_recipePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Im_recipe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_recipeFindFirstArgs} args - Arguments to find a Im_recipe
     * @example
     * // Get one Im_recipe
     * const im_recipe = await prisma.im_recipe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends im_recipeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, im_recipeFindFirstArgs<ExtArgs>>
    ): Prisma__im_recipeClient<$Result.GetResult<Prisma.$im_recipePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Im_recipe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_recipeFindFirstOrThrowArgs} args - Arguments to find a Im_recipe
     * @example
     * // Get one Im_recipe
     * const im_recipe = await prisma.im_recipe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends im_recipeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, im_recipeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__im_recipeClient<$Result.GetResult<Prisma.$im_recipePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Im_recipes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_recipeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Im_recipes
     * const im_recipes = await prisma.im_recipe.findMany()
     * 
     * // Get first 10 Im_recipes
     * const im_recipes = await prisma.im_recipe.findMany({ take: 10 })
     * 
     * // Only select the `id_recipe`
     * const im_recipeWithId_recipeOnly = await prisma.im_recipe.findMany({ select: { id_recipe: true } })
     * 
    **/
    findMany<T extends im_recipeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_recipeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$im_recipePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Im_recipe.
     * @param {im_recipeCreateArgs} args - Arguments to create a Im_recipe.
     * @example
     * // Create one Im_recipe
     * const Im_recipe = await prisma.im_recipe.create({
     *   data: {
     *     // ... data to create a Im_recipe
     *   }
     * })
     * 
    **/
    create<T extends im_recipeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, im_recipeCreateArgs<ExtArgs>>
    ): Prisma__im_recipeClient<$Result.GetResult<Prisma.$im_recipePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Im_recipes.
     *     @param {im_recipeCreateManyArgs} args - Arguments to create many Im_recipes.
     *     @example
     *     // Create many Im_recipes
     *     const im_recipe = await prisma.im_recipe.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends im_recipeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_recipeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Im_recipe.
     * @param {im_recipeDeleteArgs} args - Arguments to delete one Im_recipe.
     * @example
     * // Delete one Im_recipe
     * const Im_recipe = await prisma.im_recipe.delete({
     *   where: {
     *     // ... filter to delete one Im_recipe
     *   }
     * })
     * 
    **/
    delete<T extends im_recipeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, im_recipeDeleteArgs<ExtArgs>>
    ): Prisma__im_recipeClient<$Result.GetResult<Prisma.$im_recipePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Im_recipe.
     * @param {im_recipeUpdateArgs} args - Arguments to update one Im_recipe.
     * @example
     * // Update one Im_recipe
     * const im_recipe = await prisma.im_recipe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends im_recipeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, im_recipeUpdateArgs<ExtArgs>>
    ): Prisma__im_recipeClient<$Result.GetResult<Prisma.$im_recipePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Im_recipes.
     * @param {im_recipeDeleteManyArgs} args - Arguments to filter Im_recipes to delete.
     * @example
     * // Delete a few Im_recipes
     * const { count } = await prisma.im_recipe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends im_recipeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_recipeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Im_recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_recipeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Im_recipes
     * const im_recipe = await prisma.im_recipe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends im_recipeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, im_recipeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Im_recipe.
     * @param {im_recipeUpsertArgs} args - Arguments to update or create a Im_recipe.
     * @example
     * // Update or create a Im_recipe
     * const im_recipe = await prisma.im_recipe.upsert({
     *   create: {
     *     // ... data to create a Im_recipe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Im_recipe we want to update
     *   }
     * })
    **/
    upsert<T extends im_recipeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, im_recipeUpsertArgs<ExtArgs>>
    ): Prisma__im_recipeClient<$Result.GetResult<Prisma.$im_recipePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Im_recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_recipeCountArgs} args - Arguments to filter Im_recipes to count.
     * @example
     * // Count the number of Im_recipes
     * const count = await prisma.im_recipe.count({
     *   where: {
     *     // ... the filter for the Im_recipes we want to count
     *   }
     * })
    **/
    count<T extends im_recipeCountArgs>(
      args?: Subset<T, im_recipeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Im_recipeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Im_recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Im_recipeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Im_recipeAggregateArgs>(args: Subset<T, Im_recipeAggregateArgs>): Prisma.PrismaPromise<GetIm_recipeAggregateType<T>>

    /**
     * Group by Im_recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_recipeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends im_recipeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: im_recipeGroupByArgs['orderBy'] }
        : { orderBy?: im_recipeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, im_recipeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIm_recipeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the im_recipe model
   */
  readonly fields: im_recipeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for im_recipe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__im_recipeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    im_meal<T extends im_mealDefaultArgs<ExtArgs> = {}>(args?: Subset<T, im_mealDefaultArgs<ExtArgs>>): Prisma__im_mealClient<$Result.GetResult<Prisma.$im_mealPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    im_food<T extends im_foodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, im_foodDefaultArgs<ExtArgs>>): Prisma__im_foodClient<$Result.GetResult<Prisma.$im_foodPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the im_recipe model
   */ 
  interface im_recipeFieldRefs {
    readonly id_recipe: FieldRef<"im_recipe", 'Int'>
    readonly id_meal: FieldRef<"im_recipe", 'Int'>
    readonly id_food: FieldRef<"im_recipe", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * im_recipe findUnique
   */
  export type im_recipeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_recipe
     */
    select?: im_recipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_recipeInclude<ExtArgs> | null
    /**
     * Filter, which im_recipe to fetch.
     */
    where: im_recipeWhereUniqueInput
  }


  /**
   * im_recipe findUniqueOrThrow
   */
  export type im_recipeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_recipe
     */
    select?: im_recipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_recipeInclude<ExtArgs> | null
    /**
     * Filter, which im_recipe to fetch.
     */
    where: im_recipeWhereUniqueInput
  }


  /**
   * im_recipe findFirst
   */
  export type im_recipeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_recipe
     */
    select?: im_recipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_recipeInclude<ExtArgs> | null
    /**
     * Filter, which im_recipe to fetch.
     */
    where?: im_recipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_recipes to fetch.
     */
    orderBy?: im_recipeOrderByWithRelationInput | im_recipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for im_recipes.
     */
    cursor?: im_recipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of im_recipes.
     */
    distinct?: Im_recipeScalarFieldEnum | Im_recipeScalarFieldEnum[]
  }


  /**
   * im_recipe findFirstOrThrow
   */
  export type im_recipeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_recipe
     */
    select?: im_recipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_recipeInclude<ExtArgs> | null
    /**
     * Filter, which im_recipe to fetch.
     */
    where?: im_recipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_recipes to fetch.
     */
    orderBy?: im_recipeOrderByWithRelationInput | im_recipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for im_recipes.
     */
    cursor?: im_recipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of im_recipes.
     */
    distinct?: Im_recipeScalarFieldEnum | Im_recipeScalarFieldEnum[]
  }


  /**
   * im_recipe findMany
   */
  export type im_recipeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_recipe
     */
    select?: im_recipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_recipeInclude<ExtArgs> | null
    /**
     * Filter, which im_recipes to fetch.
     */
    where?: im_recipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_recipes to fetch.
     */
    orderBy?: im_recipeOrderByWithRelationInput | im_recipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing im_recipes.
     */
    cursor?: im_recipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_recipes.
     */
    skip?: number
    distinct?: Im_recipeScalarFieldEnum | Im_recipeScalarFieldEnum[]
  }


  /**
   * im_recipe create
   */
  export type im_recipeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_recipe
     */
    select?: im_recipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_recipeInclude<ExtArgs> | null
    /**
     * The data needed to create a im_recipe.
     */
    data: XOR<im_recipeCreateInput, im_recipeUncheckedCreateInput>
  }


  /**
   * im_recipe createMany
   */
  export type im_recipeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many im_recipes.
     */
    data: im_recipeCreateManyInput | im_recipeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * im_recipe update
   */
  export type im_recipeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_recipe
     */
    select?: im_recipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_recipeInclude<ExtArgs> | null
    /**
     * The data needed to update a im_recipe.
     */
    data: XOR<im_recipeUpdateInput, im_recipeUncheckedUpdateInput>
    /**
     * Choose, which im_recipe to update.
     */
    where: im_recipeWhereUniqueInput
  }


  /**
   * im_recipe updateMany
   */
  export type im_recipeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update im_recipes.
     */
    data: XOR<im_recipeUpdateManyMutationInput, im_recipeUncheckedUpdateManyInput>
    /**
     * Filter which im_recipes to update
     */
    where?: im_recipeWhereInput
  }


  /**
   * im_recipe upsert
   */
  export type im_recipeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_recipe
     */
    select?: im_recipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_recipeInclude<ExtArgs> | null
    /**
     * The filter to search for the im_recipe to update in case it exists.
     */
    where: im_recipeWhereUniqueInput
    /**
     * In case the im_recipe found by the `where` argument doesn't exist, create a new im_recipe with this data.
     */
    create: XOR<im_recipeCreateInput, im_recipeUncheckedCreateInput>
    /**
     * In case the im_recipe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<im_recipeUpdateInput, im_recipeUncheckedUpdateInput>
  }


  /**
   * im_recipe delete
   */
  export type im_recipeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_recipe
     */
    select?: im_recipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_recipeInclude<ExtArgs> | null
    /**
     * Filter which im_recipe to delete.
     */
    where: im_recipeWhereUniqueInput
  }


  /**
   * im_recipe deleteMany
   */
  export type im_recipeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which im_recipes to delete
     */
    where?: im_recipeWhereInput
  }


  /**
   * im_recipe without action
   */
  export type im_recipeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_recipe
     */
    select?: im_recipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_recipeInclude<ExtArgs> | null
  }



  /**
   * Model im_training
   */

  export type AggregateIm_training = {
    _count: Im_trainingCountAggregateOutputType | null
    _avg: Im_trainingAvgAggregateOutputType | null
    _sum: Im_trainingSumAggregateOutputType | null
    _min: Im_trainingMinAggregateOutputType | null
    _max: Im_trainingMaxAggregateOutputType | null
  }

  export type Im_trainingAvgAggregateOutputType = {
    id_training: number | null
    id_user: number | null
  }

  export type Im_trainingSumAggregateOutputType = {
    id_training: number | null
    id_user: number | null
  }

  export type Im_trainingMinAggregateOutputType = {
    id_training: number | null
    training_goal: string | null
    id_user: number | null
  }

  export type Im_trainingMaxAggregateOutputType = {
    id_training: number | null
    training_goal: string | null
    id_user: number | null
  }

  export type Im_trainingCountAggregateOutputType = {
    id_training: number
    training_goal: number
    id_user: number
    _all: number
  }


  export type Im_trainingAvgAggregateInputType = {
    id_training?: true
    id_user?: true
  }

  export type Im_trainingSumAggregateInputType = {
    id_training?: true
    id_user?: true
  }

  export type Im_trainingMinAggregateInputType = {
    id_training?: true
    training_goal?: true
    id_user?: true
  }

  export type Im_trainingMaxAggregateInputType = {
    id_training?: true
    training_goal?: true
    id_user?: true
  }

  export type Im_trainingCountAggregateInputType = {
    id_training?: true
    training_goal?: true
    id_user?: true
    _all?: true
  }

  export type Im_trainingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which im_training to aggregate.
     */
    where?: im_trainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_trainings to fetch.
     */
    orderBy?: im_trainingOrderByWithRelationInput | im_trainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: im_trainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_trainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned im_trainings
    **/
    _count?: true | Im_trainingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Im_trainingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Im_trainingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Im_trainingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Im_trainingMaxAggregateInputType
  }

  export type GetIm_trainingAggregateType<T extends Im_trainingAggregateArgs> = {
        [P in keyof T & keyof AggregateIm_training]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIm_training[P]>
      : GetScalarType<T[P], AggregateIm_training[P]>
  }




  export type im_trainingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: im_trainingWhereInput
    orderBy?: im_trainingOrderByWithAggregationInput | im_trainingOrderByWithAggregationInput[]
    by: Im_trainingScalarFieldEnum[] | Im_trainingScalarFieldEnum
    having?: im_trainingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Im_trainingCountAggregateInputType | true
    _avg?: Im_trainingAvgAggregateInputType
    _sum?: Im_trainingSumAggregateInputType
    _min?: Im_trainingMinAggregateInputType
    _max?: Im_trainingMaxAggregateInputType
  }

  export type Im_trainingGroupByOutputType = {
    id_training: number
    training_goal: string
    id_user: number
    _count: Im_trainingCountAggregateOutputType | null
    _avg: Im_trainingAvgAggregateOutputType | null
    _sum: Im_trainingSumAggregateOutputType | null
    _min: Im_trainingMinAggregateOutputType | null
    _max: Im_trainingMaxAggregateOutputType | null
  }

  type GetIm_trainingGroupByPayload<T extends im_trainingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Im_trainingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Im_trainingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Im_trainingGroupByOutputType[P]>
            : GetScalarType<T[P], Im_trainingGroupByOutputType[P]>
        }
      >
    >


  export type im_trainingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_training?: boolean
    training_goal?: boolean
    id_user?: boolean
    im_user?: boolean | im_userDefaultArgs<ExtArgs>
    im_workout?: boolean | im_training$im_workoutArgs<ExtArgs>
    _count?: boolean | Im_trainingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["im_training"]>

  export type im_trainingSelectScalar = {
    id_training?: boolean
    training_goal?: boolean
    id_user?: boolean
  }

  export type im_trainingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    im_user?: boolean | im_userDefaultArgs<ExtArgs>
    im_workout?: boolean | im_training$im_workoutArgs<ExtArgs>
    _count?: boolean | Im_trainingCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $im_trainingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "im_training"
    objects: {
      im_user: Prisma.$im_userPayload<ExtArgs>
      im_workout: Prisma.$im_workoutPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_training: number
      training_goal: string
      id_user: number
    }, ExtArgs["result"]["im_training"]>
    composites: {}
  }


  type im_trainingGetPayload<S extends boolean | null | undefined | im_trainingDefaultArgs> = $Result.GetResult<Prisma.$im_trainingPayload, S>

  type im_trainingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<im_trainingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Im_trainingCountAggregateInputType | true
    }

  export interface im_trainingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['im_training'], meta: { name: 'im_training' } }
    /**
     * Find zero or one Im_training that matches the filter.
     * @param {im_trainingFindUniqueArgs} args - Arguments to find a Im_training
     * @example
     * // Get one Im_training
     * const im_training = await prisma.im_training.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends im_trainingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, im_trainingFindUniqueArgs<ExtArgs>>
    ): Prisma__im_trainingClient<$Result.GetResult<Prisma.$im_trainingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Im_training that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {im_trainingFindUniqueOrThrowArgs} args - Arguments to find a Im_training
     * @example
     * // Get one Im_training
     * const im_training = await prisma.im_training.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends im_trainingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, im_trainingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__im_trainingClient<$Result.GetResult<Prisma.$im_trainingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Im_training that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_trainingFindFirstArgs} args - Arguments to find a Im_training
     * @example
     * // Get one Im_training
     * const im_training = await prisma.im_training.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends im_trainingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, im_trainingFindFirstArgs<ExtArgs>>
    ): Prisma__im_trainingClient<$Result.GetResult<Prisma.$im_trainingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Im_training that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_trainingFindFirstOrThrowArgs} args - Arguments to find a Im_training
     * @example
     * // Get one Im_training
     * const im_training = await prisma.im_training.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends im_trainingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, im_trainingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__im_trainingClient<$Result.GetResult<Prisma.$im_trainingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Im_trainings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_trainingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Im_trainings
     * const im_trainings = await prisma.im_training.findMany()
     * 
     * // Get first 10 Im_trainings
     * const im_trainings = await prisma.im_training.findMany({ take: 10 })
     * 
     * // Only select the `id_training`
     * const im_trainingWithId_trainingOnly = await prisma.im_training.findMany({ select: { id_training: true } })
     * 
    **/
    findMany<T extends im_trainingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_trainingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$im_trainingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Im_training.
     * @param {im_trainingCreateArgs} args - Arguments to create a Im_training.
     * @example
     * // Create one Im_training
     * const Im_training = await prisma.im_training.create({
     *   data: {
     *     // ... data to create a Im_training
     *   }
     * })
     * 
    **/
    create<T extends im_trainingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, im_trainingCreateArgs<ExtArgs>>
    ): Prisma__im_trainingClient<$Result.GetResult<Prisma.$im_trainingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Im_trainings.
     *     @param {im_trainingCreateManyArgs} args - Arguments to create many Im_trainings.
     *     @example
     *     // Create many Im_trainings
     *     const im_training = await prisma.im_training.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends im_trainingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_trainingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Im_training.
     * @param {im_trainingDeleteArgs} args - Arguments to delete one Im_training.
     * @example
     * // Delete one Im_training
     * const Im_training = await prisma.im_training.delete({
     *   where: {
     *     // ... filter to delete one Im_training
     *   }
     * })
     * 
    **/
    delete<T extends im_trainingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, im_trainingDeleteArgs<ExtArgs>>
    ): Prisma__im_trainingClient<$Result.GetResult<Prisma.$im_trainingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Im_training.
     * @param {im_trainingUpdateArgs} args - Arguments to update one Im_training.
     * @example
     * // Update one Im_training
     * const im_training = await prisma.im_training.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends im_trainingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, im_trainingUpdateArgs<ExtArgs>>
    ): Prisma__im_trainingClient<$Result.GetResult<Prisma.$im_trainingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Im_trainings.
     * @param {im_trainingDeleteManyArgs} args - Arguments to filter Im_trainings to delete.
     * @example
     * // Delete a few Im_trainings
     * const { count } = await prisma.im_training.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends im_trainingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_trainingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Im_trainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_trainingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Im_trainings
     * const im_training = await prisma.im_training.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends im_trainingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, im_trainingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Im_training.
     * @param {im_trainingUpsertArgs} args - Arguments to update or create a Im_training.
     * @example
     * // Update or create a Im_training
     * const im_training = await prisma.im_training.upsert({
     *   create: {
     *     // ... data to create a Im_training
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Im_training we want to update
     *   }
     * })
    **/
    upsert<T extends im_trainingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, im_trainingUpsertArgs<ExtArgs>>
    ): Prisma__im_trainingClient<$Result.GetResult<Prisma.$im_trainingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Im_trainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_trainingCountArgs} args - Arguments to filter Im_trainings to count.
     * @example
     * // Count the number of Im_trainings
     * const count = await prisma.im_training.count({
     *   where: {
     *     // ... the filter for the Im_trainings we want to count
     *   }
     * })
    **/
    count<T extends im_trainingCountArgs>(
      args?: Subset<T, im_trainingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Im_trainingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Im_training.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Im_trainingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Im_trainingAggregateArgs>(args: Subset<T, Im_trainingAggregateArgs>): Prisma.PrismaPromise<GetIm_trainingAggregateType<T>>

    /**
     * Group by Im_training.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_trainingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends im_trainingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: im_trainingGroupByArgs['orderBy'] }
        : { orderBy?: im_trainingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, im_trainingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIm_trainingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the im_training model
   */
  readonly fields: im_trainingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for im_training.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__im_trainingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    im_user<T extends im_userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, im_userDefaultArgs<ExtArgs>>): Prisma__im_userClient<$Result.GetResult<Prisma.$im_userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    im_workout<T extends im_training$im_workoutArgs<ExtArgs> = {}>(args?: Subset<T, im_training$im_workoutArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$im_workoutPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the im_training model
   */ 
  interface im_trainingFieldRefs {
    readonly id_training: FieldRef<"im_training", 'Int'>
    readonly training_goal: FieldRef<"im_training", 'String'>
    readonly id_user: FieldRef<"im_training", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * im_training findUnique
   */
  export type im_trainingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_training
     */
    select?: im_trainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_trainingInclude<ExtArgs> | null
    /**
     * Filter, which im_training to fetch.
     */
    where: im_trainingWhereUniqueInput
  }


  /**
   * im_training findUniqueOrThrow
   */
  export type im_trainingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_training
     */
    select?: im_trainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_trainingInclude<ExtArgs> | null
    /**
     * Filter, which im_training to fetch.
     */
    where: im_trainingWhereUniqueInput
  }


  /**
   * im_training findFirst
   */
  export type im_trainingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_training
     */
    select?: im_trainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_trainingInclude<ExtArgs> | null
    /**
     * Filter, which im_training to fetch.
     */
    where?: im_trainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_trainings to fetch.
     */
    orderBy?: im_trainingOrderByWithRelationInput | im_trainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for im_trainings.
     */
    cursor?: im_trainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_trainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of im_trainings.
     */
    distinct?: Im_trainingScalarFieldEnum | Im_trainingScalarFieldEnum[]
  }


  /**
   * im_training findFirstOrThrow
   */
  export type im_trainingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_training
     */
    select?: im_trainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_trainingInclude<ExtArgs> | null
    /**
     * Filter, which im_training to fetch.
     */
    where?: im_trainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_trainings to fetch.
     */
    orderBy?: im_trainingOrderByWithRelationInput | im_trainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for im_trainings.
     */
    cursor?: im_trainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_trainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of im_trainings.
     */
    distinct?: Im_trainingScalarFieldEnum | Im_trainingScalarFieldEnum[]
  }


  /**
   * im_training findMany
   */
  export type im_trainingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_training
     */
    select?: im_trainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_trainingInclude<ExtArgs> | null
    /**
     * Filter, which im_trainings to fetch.
     */
    where?: im_trainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_trainings to fetch.
     */
    orderBy?: im_trainingOrderByWithRelationInput | im_trainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing im_trainings.
     */
    cursor?: im_trainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_trainings.
     */
    skip?: number
    distinct?: Im_trainingScalarFieldEnum | Im_trainingScalarFieldEnum[]
  }


  /**
   * im_training create
   */
  export type im_trainingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_training
     */
    select?: im_trainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_trainingInclude<ExtArgs> | null
    /**
     * The data needed to create a im_training.
     */
    data: XOR<im_trainingCreateInput, im_trainingUncheckedCreateInput>
  }


  /**
   * im_training createMany
   */
  export type im_trainingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many im_trainings.
     */
    data: im_trainingCreateManyInput | im_trainingCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * im_training update
   */
  export type im_trainingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_training
     */
    select?: im_trainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_trainingInclude<ExtArgs> | null
    /**
     * The data needed to update a im_training.
     */
    data: XOR<im_trainingUpdateInput, im_trainingUncheckedUpdateInput>
    /**
     * Choose, which im_training to update.
     */
    where: im_trainingWhereUniqueInput
  }


  /**
   * im_training updateMany
   */
  export type im_trainingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update im_trainings.
     */
    data: XOR<im_trainingUpdateManyMutationInput, im_trainingUncheckedUpdateManyInput>
    /**
     * Filter which im_trainings to update
     */
    where?: im_trainingWhereInput
  }


  /**
   * im_training upsert
   */
  export type im_trainingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_training
     */
    select?: im_trainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_trainingInclude<ExtArgs> | null
    /**
     * The filter to search for the im_training to update in case it exists.
     */
    where: im_trainingWhereUniqueInput
    /**
     * In case the im_training found by the `where` argument doesn't exist, create a new im_training with this data.
     */
    create: XOR<im_trainingCreateInput, im_trainingUncheckedCreateInput>
    /**
     * In case the im_training was found with the provided `where` argument, update it with this data.
     */
    update: XOR<im_trainingUpdateInput, im_trainingUncheckedUpdateInput>
  }


  /**
   * im_training delete
   */
  export type im_trainingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_training
     */
    select?: im_trainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_trainingInclude<ExtArgs> | null
    /**
     * Filter which im_training to delete.
     */
    where: im_trainingWhereUniqueInput
  }


  /**
   * im_training deleteMany
   */
  export type im_trainingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which im_trainings to delete
     */
    where?: im_trainingWhereInput
  }


  /**
   * im_training.im_workout
   */
  export type im_training$im_workoutArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_workout
     */
    select?: im_workoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_workoutInclude<ExtArgs> | null
    where?: im_workoutWhereInput
    orderBy?: im_workoutOrderByWithRelationInput | im_workoutOrderByWithRelationInput[]
    cursor?: im_workoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Im_workoutScalarFieldEnum | Im_workoutScalarFieldEnum[]
  }


  /**
   * im_training without action
   */
  export type im_trainingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_training
     */
    select?: im_trainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_trainingInclude<ExtArgs> | null
  }



  /**
   * Model im_undesirable_food
   */

  export type AggregateIm_undesirable_food = {
    _count: Im_undesirable_foodCountAggregateOutputType | null
    _avg: Im_undesirable_foodAvgAggregateOutputType | null
    _sum: Im_undesirable_foodSumAggregateOutputType | null
    _min: Im_undesirable_foodMinAggregateOutputType | null
    _max: Im_undesirable_foodMaxAggregateOutputType | null
  }

  export type Im_undesirable_foodAvgAggregateOutputType = {
    id_undesirable_food: number | null
    id_food: number | null
    id_user: number | null
  }

  export type Im_undesirable_foodSumAggregateOutputType = {
    id_undesirable_food: number | null
    id_food: number | null
    id_user: number | null
  }

  export type Im_undesirable_foodMinAggregateOutputType = {
    id_undesirable_food: number | null
    id_food: number | null
    id_user: number | null
  }

  export type Im_undesirable_foodMaxAggregateOutputType = {
    id_undesirable_food: number | null
    id_food: number | null
    id_user: number | null
  }

  export type Im_undesirable_foodCountAggregateOutputType = {
    id_undesirable_food: number
    id_food: number
    id_user: number
    _all: number
  }


  export type Im_undesirable_foodAvgAggregateInputType = {
    id_undesirable_food?: true
    id_food?: true
    id_user?: true
  }

  export type Im_undesirable_foodSumAggregateInputType = {
    id_undesirable_food?: true
    id_food?: true
    id_user?: true
  }

  export type Im_undesirable_foodMinAggregateInputType = {
    id_undesirable_food?: true
    id_food?: true
    id_user?: true
  }

  export type Im_undesirable_foodMaxAggregateInputType = {
    id_undesirable_food?: true
    id_food?: true
    id_user?: true
  }

  export type Im_undesirable_foodCountAggregateInputType = {
    id_undesirable_food?: true
    id_food?: true
    id_user?: true
    _all?: true
  }

  export type Im_undesirable_foodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which im_undesirable_food to aggregate.
     */
    where?: im_undesirable_foodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_undesirable_foods to fetch.
     */
    orderBy?: im_undesirable_foodOrderByWithRelationInput | im_undesirable_foodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: im_undesirable_foodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_undesirable_foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_undesirable_foods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned im_undesirable_foods
    **/
    _count?: true | Im_undesirable_foodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Im_undesirable_foodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Im_undesirable_foodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Im_undesirable_foodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Im_undesirable_foodMaxAggregateInputType
  }

  export type GetIm_undesirable_foodAggregateType<T extends Im_undesirable_foodAggregateArgs> = {
        [P in keyof T & keyof AggregateIm_undesirable_food]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIm_undesirable_food[P]>
      : GetScalarType<T[P], AggregateIm_undesirable_food[P]>
  }




  export type im_undesirable_foodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: im_undesirable_foodWhereInput
    orderBy?: im_undesirable_foodOrderByWithAggregationInput | im_undesirable_foodOrderByWithAggregationInput[]
    by: Im_undesirable_foodScalarFieldEnum[] | Im_undesirable_foodScalarFieldEnum
    having?: im_undesirable_foodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Im_undesirable_foodCountAggregateInputType | true
    _avg?: Im_undesirable_foodAvgAggregateInputType
    _sum?: Im_undesirable_foodSumAggregateInputType
    _min?: Im_undesirable_foodMinAggregateInputType
    _max?: Im_undesirable_foodMaxAggregateInputType
  }

  export type Im_undesirable_foodGroupByOutputType = {
    id_undesirable_food: number
    id_food: number
    id_user: number
    _count: Im_undesirable_foodCountAggregateOutputType | null
    _avg: Im_undesirable_foodAvgAggregateOutputType | null
    _sum: Im_undesirable_foodSumAggregateOutputType | null
    _min: Im_undesirable_foodMinAggregateOutputType | null
    _max: Im_undesirable_foodMaxAggregateOutputType | null
  }

  type GetIm_undesirable_foodGroupByPayload<T extends im_undesirable_foodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Im_undesirable_foodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Im_undesirable_foodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Im_undesirable_foodGroupByOutputType[P]>
            : GetScalarType<T[P], Im_undesirable_foodGroupByOutputType[P]>
        }
      >
    >


  export type im_undesirable_foodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_undesirable_food?: boolean
    id_food?: boolean
    id_user?: boolean
    im_user?: boolean | im_userDefaultArgs<ExtArgs>
    im_food?: boolean | im_foodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["im_undesirable_food"]>

  export type im_undesirable_foodSelectScalar = {
    id_undesirable_food?: boolean
    id_food?: boolean
    id_user?: boolean
  }

  export type im_undesirable_foodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    im_user?: boolean | im_userDefaultArgs<ExtArgs>
    im_food?: boolean | im_foodDefaultArgs<ExtArgs>
  }


  export type $im_undesirable_foodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "im_undesirable_food"
    objects: {
      im_user: Prisma.$im_userPayload<ExtArgs>
      im_food: Prisma.$im_foodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_undesirable_food: number
      id_food: number
      id_user: number
    }, ExtArgs["result"]["im_undesirable_food"]>
    composites: {}
  }


  type im_undesirable_foodGetPayload<S extends boolean | null | undefined | im_undesirable_foodDefaultArgs> = $Result.GetResult<Prisma.$im_undesirable_foodPayload, S>

  type im_undesirable_foodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<im_undesirable_foodFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Im_undesirable_foodCountAggregateInputType | true
    }

  export interface im_undesirable_foodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['im_undesirable_food'], meta: { name: 'im_undesirable_food' } }
    /**
     * Find zero or one Im_undesirable_food that matches the filter.
     * @param {im_undesirable_foodFindUniqueArgs} args - Arguments to find a Im_undesirable_food
     * @example
     * // Get one Im_undesirable_food
     * const im_undesirable_food = await prisma.im_undesirable_food.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends im_undesirable_foodFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, im_undesirable_foodFindUniqueArgs<ExtArgs>>
    ): Prisma__im_undesirable_foodClient<$Result.GetResult<Prisma.$im_undesirable_foodPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Im_undesirable_food that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {im_undesirable_foodFindUniqueOrThrowArgs} args - Arguments to find a Im_undesirable_food
     * @example
     * // Get one Im_undesirable_food
     * const im_undesirable_food = await prisma.im_undesirable_food.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends im_undesirable_foodFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, im_undesirable_foodFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__im_undesirable_foodClient<$Result.GetResult<Prisma.$im_undesirable_foodPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Im_undesirable_food that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_undesirable_foodFindFirstArgs} args - Arguments to find a Im_undesirable_food
     * @example
     * // Get one Im_undesirable_food
     * const im_undesirable_food = await prisma.im_undesirable_food.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends im_undesirable_foodFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, im_undesirable_foodFindFirstArgs<ExtArgs>>
    ): Prisma__im_undesirable_foodClient<$Result.GetResult<Prisma.$im_undesirable_foodPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Im_undesirable_food that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_undesirable_foodFindFirstOrThrowArgs} args - Arguments to find a Im_undesirable_food
     * @example
     * // Get one Im_undesirable_food
     * const im_undesirable_food = await prisma.im_undesirable_food.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends im_undesirable_foodFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, im_undesirable_foodFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__im_undesirable_foodClient<$Result.GetResult<Prisma.$im_undesirable_foodPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Im_undesirable_foods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_undesirable_foodFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Im_undesirable_foods
     * const im_undesirable_foods = await prisma.im_undesirable_food.findMany()
     * 
     * // Get first 10 Im_undesirable_foods
     * const im_undesirable_foods = await prisma.im_undesirable_food.findMany({ take: 10 })
     * 
     * // Only select the `id_undesirable_food`
     * const im_undesirable_foodWithId_undesirable_foodOnly = await prisma.im_undesirable_food.findMany({ select: { id_undesirable_food: true } })
     * 
    **/
    findMany<T extends im_undesirable_foodFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_undesirable_foodFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$im_undesirable_foodPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Im_undesirable_food.
     * @param {im_undesirable_foodCreateArgs} args - Arguments to create a Im_undesirable_food.
     * @example
     * // Create one Im_undesirable_food
     * const Im_undesirable_food = await prisma.im_undesirable_food.create({
     *   data: {
     *     // ... data to create a Im_undesirable_food
     *   }
     * })
     * 
    **/
    create<T extends im_undesirable_foodCreateArgs<ExtArgs>>(
      args: SelectSubset<T, im_undesirable_foodCreateArgs<ExtArgs>>
    ): Prisma__im_undesirable_foodClient<$Result.GetResult<Prisma.$im_undesirable_foodPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Im_undesirable_foods.
     *     @param {im_undesirable_foodCreateManyArgs} args - Arguments to create many Im_undesirable_foods.
     *     @example
     *     // Create many Im_undesirable_foods
     *     const im_undesirable_food = await prisma.im_undesirable_food.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends im_undesirable_foodCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_undesirable_foodCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Im_undesirable_food.
     * @param {im_undesirable_foodDeleteArgs} args - Arguments to delete one Im_undesirable_food.
     * @example
     * // Delete one Im_undesirable_food
     * const Im_undesirable_food = await prisma.im_undesirable_food.delete({
     *   where: {
     *     // ... filter to delete one Im_undesirable_food
     *   }
     * })
     * 
    **/
    delete<T extends im_undesirable_foodDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, im_undesirable_foodDeleteArgs<ExtArgs>>
    ): Prisma__im_undesirable_foodClient<$Result.GetResult<Prisma.$im_undesirable_foodPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Im_undesirable_food.
     * @param {im_undesirable_foodUpdateArgs} args - Arguments to update one Im_undesirable_food.
     * @example
     * // Update one Im_undesirable_food
     * const im_undesirable_food = await prisma.im_undesirable_food.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends im_undesirable_foodUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, im_undesirable_foodUpdateArgs<ExtArgs>>
    ): Prisma__im_undesirable_foodClient<$Result.GetResult<Prisma.$im_undesirable_foodPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Im_undesirable_foods.
     * @param {im_undesirable_foodDeleteManyArgs} args - Arguments to filter Im_undesirable_foods to delete.
     * @example
     * // Delete a few Im_undesirable_foods
     * const { count } = await prisma.im_undesirable_food.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends im_undesirable_foodDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_undesirable_foodDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Im_undesirable_foods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_undesirable_foodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Im_undesirable_foods
     * const im_undesirable_food = await prisma.im_undesirable_food.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends im_undesirable_foodUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, im_undesirable_foodUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Im_undesirable_food.
     * @param {im_undesirable_foodUpsertArgs} args - Arguments to update or create a Im_undesirable_food.
     * @example
     * // Update or create a Im_undesirable_food
     * const im_undesirable_food = await prisma.im_undesirable_food.upsert({
     *   create: {
     *     // ... data to create a Im_undesirable_food
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Im_undesirable_food we want to update
     *   }
     * })
    **/
    upsert<T extends im_undesirable_foodUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, im_undesirable_foodUpsertArgs<ExtArgs>>
    ): Prisma__im_undesirable_foodClient<$Result.GetResult<Prisma.$im_undesirable_foodPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Im_undesirable_foods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_undesirable_foodCountArgs} args - Arguments to filter Im_undesirable_foods to count.
     * @example
     * // Count the number of Im_undesirable_foods
     * const count = await prisma.im_undesirable_food.count({
     *   where: {
     *     // ... the filter for the Im_undesirable_foods we want to count
     *   }
     * })
    **/
    count<T extends im_undesirable_foodCountArgs>(
      args?: Subset<T, im_undesirable_foodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Im_undesirable_foodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Im_undesirable_food.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Im_undesirable_foodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Im_undesirable_foodAggregateArgs>(args: Subset<T, Im_undesirable_foodAggregateArgs>): Prisma.PrismaPromise<GetIm_undesirable_foodAggregateType<T>>

    /**
     * Group by Im_undesirable_food.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_undesirable_foodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends im_undesirable_foodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: im_undesirable_foodGroupByArgs['orderBy'] }
        : { orderBy?: im_undesirable_foodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, im_undesirable_foodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIm_undesirable_foodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the im_undesirable_food model
   */
  readonly fields: im_undesirable_foodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for im_undesirable_food.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__im_undesirable_foodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    im_user<T extends im_userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, im_userDefaultArgs<ExtArgs>>): Prisma__im_userClient<$Result.GetResult<Prisma.$im_userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    im_food<T extends im_foodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, im_foodDefaultArgs<ExtArgs>>): Prisma__im_foodClient<$Result.GetResult<Prisma.$im_foodPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the im_undesirable_food model
   */ 
  interface im_undesirable_foodFieldRefs {
    readonly id_undesirable_food: FieldRef<"im_undesirable_food", 'Int'>
    readonly id_food: FieldRef<"im_undesirable_food", 'Int'>
    readonly id_user: FieldRef<"im_undesirable_food", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * im_undesirable_food findUnique
   */
  export type im_undesirable_foodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_undesirable_food
     */
    select?: im_undesirable_foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_undesirable_foodInclude<ExtArgs> | null
    /**
     * Filter, which im_undesirable_food to fetch.
     */
    where: im_undesirable_foodWhereUniqueInput
  }


  /**
   * im_undesirable_food findUniqueOrThrow
   */
  export type im_undesirable_foodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_undesirable_food
     */
    select?: im_undesirable_foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_undesirable_foodInclude<ExtArgs> | null
    /**
     * Filter, which im_undesirable_food to fetch.
     */
    where: im_undesirable_foodWhereUniqueInput
  }


  /**
   * im_undesirable_food findFirst
   */
  export type im_undesirable_foodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_undesirable_food
     */
    select?: im_undesirable_foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_undesirable_foodInclude<ExtArgs> | null
    /**
     * Filter, which im_undesirable_food to fetch.
     */
    where?: im_undesirable_foodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_undesirable_foods to fetch.
     */
    orderBy?: im_undesirable_foodOrderByWithRelationInput | im_undesirable_foodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for im_undesirable_foods.
     */
    cursor?: im_undesirable_foodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_undesirable_foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_undesirable_foods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of im_undesirable_foods.
     */
    distinct?: Im_undesirable_foodScalarFieldEnum | Im_undesirable_foodScalarFieldEnum[]
  }


  /**
   * im_undesirable_food findFirstOrThrow
   */
  export type im_undesirable_foodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_undesirable_food
     */
    select?: im_undesirable_foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_undesirable_foodInclude<ExtArgs> | null
    /**
     * Filter, which im_undesirable_food to fetch.
     */
    where?: im_undesirable_foodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_undesirable_foods to fetch.
     */
    orderBy?: im_undesirable_foodOrderByWithRelationInput | im_undesirable_foodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for im_undesirable_foods.
     */
    cursor?: im_undesirable_foodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_undesirable_foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_undesirable_foods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of im_undesirable_foods.
     */
    distinct?: Im_undesirable_foodScalarFieldEnum | Im_undesirable_foodScalarFieldEnum[]
  }


  /**
   * im_undesirable_food findMany
   */
  export type im_undesirable_foodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_undesirable_food
     */
    select?: im_undesirable_foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_undesirable_foodInclude<ExtArgs> | null
    /**
     * Filter, which im_undesirable_foods to fetch.
     */
    where?: im_undesirable_foodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_undesirable_foods to fetch.
     */
    orderBy?: im_undesirable_foodOrderByWithRelationInput | im_undesirable_foodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing im_undesirable_foods.
     */
    cursor?: im_undesirable_foodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_undesirable_foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_undesirable_foods.
     */
    skip?: number
    distinct?: Im_undesirable_foodScalarFieldEnum | Im_undesirable_foodScalarFieldEnum[]
  }


  /**
   * im_undesirable_food create
   */
  export type im_undesirable_foodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_undesirable_food
     */
    select?: im_undesirable_foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_undesirable_foodInclude<ExtArgs> | null
    /**
     * The data needed to create a im_undesirable_food.
     */
    data: XOR<im_undesirable_foodCreateInput, im_undesirable_foodUncheckedCreateInput>
  }


  /**
   * im_undesirable_food createMany
   */
  export type im_undesirable_foodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many im_undesirable_foods.
     */
    data: im_undesirable_foodCreateManyInput | im_undesirable_foodCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * im_undesirable_food update
   */
  export type im_undesirable_foodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_undesirable_food
     */
    select?: im_undesirable_foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_undesirable_foodInclude<ExtArgs> | null
    /**
     * The data needed to update a im_undesirable_food.
     */
    data: XOR<im_undesirable_foodUpdateInput, im_undesirable_foodUncheckedUpdateInput>
    /**
     * Choose, which im_undesirable_food to update.
     */
    where: im_undesirable_foodWhereUniqueInput
  }


  /**
   * im_undesirable_food updateMany
   */
  export type im_undesirable_foodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update im_undesirable_foods.
     */
    data: XOR<im_undesirable_foodUpdateManyMutationInput, im_undesirable_foodUncheckedUpdateManyInput>
    /**
     * Filter which im_undesirable_foods to update
     */
    where?: im_undesirable_foodWhereInput
  }


  /**
   * im_undesirable_food upsert
   */
  export type im_undesirable_foodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_undesirable_food
     */
    select?: im_undesirable_foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_undesirable_foodInclude<ExtArgs> | null
    /**
     * The filter to search for the im_undesirable_food to update in case it exists.
     */
    where: im_undesirable_foodWhereUniqueInput
    /**
     * In case the im_undesirable_food found by the `where` argument doesn't exist, create a new im_undesirable_food with this data.
     */
    create: XOR<im_undesirable_foodCreateInput, im_undesirable_foodUncheckedCreateInput>
    /**
     * In case the im_undesirable_food was found with the provided `where` argument, update it with this data.
     */
    update: XOR<im_undesirable_foodUpdateInput, im_undesirable_foodUncheckedUpdateInput>
  }


  /**
   * im_undesirable_food delete
   */
  export type im_undesirable_foodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_undesirable_food
     */
    select?: im_undesirable_foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_undesirable_foodInclude<ExtArgs> | null
    /**
     * Filter which im_undesirable_food to delete.
     */
    where: im_undesirable_foodWhereUniqueInput
  }


  /**
   * im_undesirable_food deleteMany
   */
  export type im_undesirable_foodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which im_undesirable_foods to delete
     */
    where?: im_undesirable_foodWhereInput
  }


  /**
   * im_undesirable_food without action
   */
  export type im_undesirable_foodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_undesirable_food
     */
    select?: im_undesirable_foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_undesirable_foodInclude<ExtArgs> | null
  }



  /**
   * Model im_user
   */

  export type AggregateIm_user = {
    _count: Im_userCountAggregateOutputType | null
    _avg: Im_userAvgAggregateOutputType | null
    _sum: Im_userSumAggregateOutputType | null
    _min: Im_userMinAggregateOutputType | null
    _max: Im_userMaxAggregateOutputType | null
  }

  export type Im_userAvgAggregateOutputType = {
    id_user: number | null
    user_gender: number | null
    user_height: number | null
    user_weight: number | null
    user_age: number | null
    user_training_level: number | null
    user_nutrition_diet: number | null
  }

  export type Im_userSumAggregateOutputType = {
    id_user: number | null
    user_gender: number | null
    user_height: number | null
    user_weight: number | null
    user_age: number | null
    user_training_level: number | null
    user_nutrition_diet: number | null
  }

  export type Im_userMinAggregateOutputType = {
    id_user: number | null
    user_firstname: string | null
    user_name: string | null
    user_mail: string | null
    user_password: string | null
    user_birth_date: Date | null
    user_inscription_date: Date | null
    user_gender: number | null
    user_height: number | null
    user_weight: number | null
    user_age: number | null
    user_training_level: number | null
    user_nutrition_diet: number | null
  }

  export type Im_userMaxAggregateOutputType = {
    id_user: number | null
    user_firstname: string | null
    user_name: string | null
    user_mail: string | null
    user_password: string | null
    user_birth_date: Date | null
    user_inscription_date: Date | null
    user_gender: number | null
    user_height: number | null
    user_weight: number | null
    user_age: number | null
    user_training_level: number | null
    user_nutrition_diet: number | null
  }

  export type Im_userCountAggregateOutputType = {
    id_user: number
    user_firstname: number
    user_name: number
    user_mail: number
    user_password: number
    user_birth_date: number
    user_inscription_date: number
    user_gender: number
    user_height: number
    user_weight: number
    user_age: number
    user_training_level: number
    user_nutrition_diet: number
    _all: number
  }


  export type Im_userAvgAggregateInputType = {
    id_user?: true
    user_gender?: true
    user_height?: true
    user_weight?: true
    user_age?: true
    user_training_level?: true
    user_nutrition_diet?: true
  }

  export type Im_userSumAggregateInputType = {
    id_user?: true
    user_gender?: true
    user_height?: true
    user_weight?: true
    user_age?: true
    user_training_level?: true
    user_nutrition_diet?: true
  }

  export type Im_userMinAggregateInputType = {
    id_user?: true
    user_firstname?: true
    user_name?: true
    user_mail?: true
    user_password?: true
    user_birth_date?: true
    user_inscription_date?: true
    user_gender?: true
    user_height?: true
    user_weight?: true
    user_age?: true
    user_training_level?: true
    user_nutrition_diet?: true
  }

  export type Im_userMaxAggregateInputType = {
    id_user?: true
    user_firstname?: true
    user_name?: true
    user_mail?: true
    user_password?: true
    user_birth_date?: true
    user_inscription_date?: true
    user_gender?: true
    user_height?: true
    user_weight?: true
    user_age?: true
    user_training_level?: true
    user_nutrition_diet?: true
  }

  export type Im_userCountAggregateInputType = {
    id_user?: true
    user_firstname?: true
    user_name?: true
    user_mail?: true
    user_password?: true
    user_birth_date?: true
    user_inscription_date?: true
    user_gender?: true
    user_height?: true
    user_weight?: true
    user_age?: true
    user_training_level?: true
    user_nutrition_diet?: true
    _all?: true
  }

  export type Im_userAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which im_user to aggregate.
     */
    where?: im_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_users to fetch.
     */
    orderBy?: im_userOrderByWithRelationInput | im_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: im_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned im_users
    **/
    _count?: true | Im_userCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Im_userAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Im_userSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Im_userMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Im_userMaxAggregateInputType
  }

  export type GetIm_userAggregateType<T extends Im_userAggregateArgs> = {
        [P in keyof T & keyof AggregateIm_user]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIm_user[P]>
      : GetScalarType<T[P], AggregateIm_user[P]>
  }




  export type im_userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: im_userWhereInput
    orderBy?: im_userOrderByWithAggregationInput | im_userOrderByWithAggregationInput[]
    by: Im_userScalarFieldEnum[] | Im_userScalarFieldEnum
    having?: im_userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Im_userCountAggregateInputType | true
    _avg?: Im_userAvgAggregateInputType
    _sum?: Im_userSumAggregateInputType
    _min?: Im_userMinAggregateInputType
    _max?: Im_userMaxAggregateInputType
  }

  export type Im_userGroupByOutputType = {
    id_user: number
    user_firstname: string
    user_name: string
    user_mail: string
    user_password: string
    user_birth_date: Date
    user_inscription_date: Date
    user_gender: number
    user_height: number
    user_weight: number
    user_age: number
    user_training_level: number
    user_nutrition_diet: number
    _count: Im_userCountAggregateOutputType | null
    _avg: Im_userAvgAggregateOutputType | null
    _sum: Im_userSumAggregateOutputType | null
    _min: Im_userMinAggregateOutputType | null
    _max: Im_userMaxAggregateOutputType | null
  }

  type GetIm_userGroupByPayload<T extends im_userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Im_userGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Im_userGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Im_userGroupByOutputType[P]>
            : GetScalarType<T[P], Im_userGroupByOutputType[P]>
        }
      >
    >


  export type im_userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_user?: boolean
    user_firstname?: boolean
    user_name?: boolean
    user_mail?: boolean
    user_password?: boolean
    user_birth_date?: boolean
    user_inscription_date?: boolean
    user_gender?: boolean
    user_height?: boolean
    user_weight?: boolean
    user_age?: boolean
    user_training_level?: boolean
    user_nutrition_diet?: boolean
    im_health?: boolean | im_user$im_healthArgs<ExtArgs>
    im_nutrition?: boolean | im_user$im_nutritionArgs<ExtArgs>
    im_training?: boolean | im_user$im_trainingArgs<ExtArgs>
    im_undesirable_food?: boolean | im_user$im_undesirable_foodArgs<ExtArgs>
    _count?: boolean | Im_userCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["im_user"]>

  export type im_userSelectScalar = {
    id_user?: boolean
    user_firstname?: boolean
    user_name?: boolean
    user_mail?: boolean
    user_password?: boolean
    user_birth_date?: boolean
    user_inscription_date?: boolean
    user_gender?: boolean
    user_height?: boolean
    user_weight?: boolean
    user_age?: boolean
    user_training_level?: boolean
    user_nutrition_diet?: boolean
  }

  export type im_userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    im_health?: boolean | im_user$im_healthArgs<ExtArgs>
    im_nutrition?: boolean | im_user$im_nutritionArgs<ExtArgs>
    im_training?: boolean | im_user$im_trainingArgs<ExtArgs>
    im_undesirable_food?: boolean | im_user$im_undesirable_foodArgs<ExtArgs>
    _count?: boolean | Im_userCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $im_userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "im_user"
    objects: {
      im_health: Prisma.$im_healthPayload<ExtArgs>[]
      im_nutrition: Prisma.$im_nutritionPayload<ExtArgs>[]
      im_training: Prisma.$im_trainingPayload<ExtArgs>[]
      im_undesirable_food: Prisma.$im_undesirable_foodPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_user: number
      user_firstname: string
      user_name: string
      user_mail: string
      user_password: string
      user_birth_date: Date
      user_inscription_date: Date
      user_gender: number
      user_height: number
      user_weight: number
      user_age: number
      user_training_level: number
      user_nutrition_diet: number
    }, ExtArgs["result"]["im_user"]>
    composites: {}
  }


  type im_userGetPayload<S extends boolean | null | undefined | im_userDefaultArgs> = $Result.GetResult<Prisma.$im_userPayload, S>

  type im_userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<im_userFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Im_userCountAggregateInputType | true
    }

  export interface im_userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['im_user'], meta: { name: 'im_user' } }
    /**
     * Find zero or one Im_user that matches the filter.
     * @param {im_userFindUniqueArgs} args - Arguments to find a Im_user
     * @example
     * // Get one Im_user
     * const im_user = await prisma.im_user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends im_userFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, im_userFindUniqueArgs<ExtArgs>>
    ): Prisma__im_userClient<$Result.GetResult<Prisma.$im_userPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Im_user that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {im_userFindUniqueOrThrowArgs} args - Arguments to find a Im_user
     * @example
     * // Get one Im_user
     * const im_user = await prisma.im_user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends im_userFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, im_userFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__im_userClient<$Result.GetResult<Prisma.$im_userPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Im_user that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_userFindFirstArgs} args - Arguments to find a Im_user
     * @example
     * // Get one Im_user
     * const im_user = await prisma.im_user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends im_userFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, im_userFindFirstArgs<ExtArgs>>
    ): Prisma__im_userClient<$Result.GetResult<Prisma.$im_userPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Im_user that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_userFindFirstOrThrowArgs} args - Arguments to find a Im_user
     * @example
     * // Get one Im_user
     * const im_user = await prisma.im_user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends im_userFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, im_userFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__im_userClient<$Result.GetResult<Prisma.$im_userPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Im_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_userFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Im_users
     * const im_users = await prisma.im_user.findMany()
     * 
     * // Get first 10 Im_users
     * const im_users = await prisma.im_user.findMany({ take: 10 })
     * 
     * // Only select the `id_user`
     * const im_userWithId_userOnly = await prisma.im_user.findMany({ select: { id_user: true } })
     * 
    **/
    findMany<T extends im_userFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_userFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$im_userPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Im_user.
     * @param {im_userCreateArgs} args - Arguments to create a Im_user.
     * @example
     * // Create one Im_user
     * const Im_user = await prisma.im_user.create({
     *   data: {
     *     // ... data to create a Im_user
     *   }
     * })
     * 
    **/
    create<T extends im_userCreateArgs<ExtArgs>>(
      args: SelectSubset<T, im_userCreateArgs<ExtArgs>>
    ): Prisma__im_userClient<$Result.GetResult<Prisma.$im_userPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Im_users.
     *     @param {im_userCreateManyArgs} args - Arguments to create many Im_users.
     *     @example
     *     // Create many Im_users
     *     const im_user = await prisma.im_user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends im_userCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_userCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Im_user.
     * @param {im_userDeleteArgs} args - Arguments to delete one Im_user.
     * @example
     * // Delete one Im_user
     * const Im_user = await prisma.im_user.delete({
     *   where: {
     *     // ... filter to delete one Im_user
     *   }
     * })
     * 
    **/
    delete<T extends im_userDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, im_userDeleteArgs<ExtArgs>>
    ): Prisma__im_userClient<$Result.GetResult<Prisma.$im_userPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Im_user.
     * @param {im_userUpdateArgs} args - Arguments to update one Im_user.
     * @example
     * // Update one Im_user
     * const im_user = await prisma.im_user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends im_userUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, im_userUpdateArgs<ExtArgs>>
    ): Prisma__im_userClient<$Result.GetResult<Prisma.$im_userPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Im_users.
     * @param {im_userDeleteManyArgs} args - Arguments to filter Im_users to delete.
     * @example
     * // Delete a few Im_users
     * const { count } = await prisma.im_user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends im_userDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_userDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Im_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Im_users
     * const im_user = await prisma.im_user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends im_userUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, im_userUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Im_user.
     * @param {im_userUpsertArgs} args - Arguments to update or create a Im_user.
     * @example
     * // Update or create a Im_user
     * const im_user = await prisma.im_user.upsert({
     *   create: {
     *     // ... data to create a Im_user
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Im_user we want to update
     *   }
     * })
    **/
    upsert<T extends im_userUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, im_userUpsertArgs<ExtArgs>>
    ): Prisma__im_userClient<$Result.GetResult<Prisma.$im_userPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Im_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_userCountArgs} args - Arguments to filter Im_users to count.
     * @example
     * // Count the number of Im_users
     * const count = await prisma.im_user.count({
     *   where: {
     *     // ... the filter for the Im_users we want to count
     *   }
     * })
    **/
    count<T extends im_userCountArgs>(
      args?: Subset<T, im_userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Im_userCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Im_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Im_userAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Im_userAggregateArgs>(args: Subset<T, Im_userAggregateArgs>): Prisma.PrismaPromise<GetIm_userAggregateType<T>>

    /**
     * Group by Im_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends im_userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: im_userGroupByArgs['orderBy'] }
        : { orderBy?: im_userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, im_userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIm_userGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the im_user model
   */
  readonly fields: im_userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for im_user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__im_userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    im_health<T extends im_user$im_healthArgs<ExtArgs> = {}>(args?: Subset<T, im_user$im_healthArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$im_healthPayload<ExtArgs>, T, 'findMany'> | Null>;

    im_nutrition<T extends im_user$im_nutritionArgs<ExtArgs> = {}>(args?: Subset<T, im_user$im_nutritionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$im_nutritionPayload<ExtArgs>, T, 'findMany'> | Null>;

    im_training<T extends im_user$im_trainingArgs<ExtArgs> = {}>(args?: Subset<T, im_user$im_trainingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$im_trainingPayload<ExtArgs>, T, 'findMany'> | Null>;

    im_undesirable_food<T extends im_user$im_undesirable_foodArgs<ExtArgs> = {}>(args?: Subset<T, im_user$im_undesirable_foodArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$im_undesirable_foodPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the im_user model
   */ 
  interface im_userFieldRefs {
    readonly id_user: FieldRef<"im_user", 'Int'>
    readonly user_firstname: FieldRef<"im_user", 'String'>
    readonly user_name: FieldRef<"im_user", 'String'>
    readonly user_mail: FieldRef<"im_user", 'String'>
    readonly user_password: FieldRef<"im_user", 'String'>
    readonly user_birth_date: FieldRef<"im_user", 'DateTime'>
    readonly user_inscription_date: FieldRef<"im_user", 'DateTime'>
    readonly user_gender: FieldRef<"im_user", 'Int'>
    readonly user_height: FieldRef<"im_user", 'Int'>
    readonly user_weight: FieldRef<"im_user", 'Int'>
    readonly user_age: FieldRef<"im_user", 'Int'>
    readonly user_training_level: FieldRef<"im_user", 'Int'>
    readonly user_nutrition_diet: FieldRef<"im_user", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * im_user findUnique
   */
  export type im_userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_user
     */
    select?: im_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_userInclude<ExtArgs> | null
    /**
     * Filter, which im_user to fetch.
     */
    where: im_userWhereUniqueInput
  }


  /**
   * im_user findUniqueOrThrow
   */
  export type im_userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_user
     */
    select?: im_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_userInclude<ExtArgs> | null
    /**
     * Filter, which im_user to fetch.
     */
    where: im_userWhereUniqueInput
  }


  /**
   * im_user findFirst
   */
  export type im_userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_user
     */
    select?: im_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_userInclude<ExtArgs> | null
    /**
     * Filter, which im_user to fetch.
     */
    where?: im_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_users to fetch.
     */
    orderBy?: im_userOrderByWithRelationInput | im_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for im_users.
     */
    cursor?: im_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of im_users.
     */
    distinct?: Im_userScalarFieldEnum | Im_userScalarFieldEnum[]
  }


  /**
   * im_user findFirstOrThrow
   */
  export type im_userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_user
     */
    select?: im_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_userInclude<ExtArgs> | null
    /**
     * Filter, which im_user to fetch.
     */
    where?: im_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_users to fetch.
     */
    orderBy?: im_userOrderByWithRelationInput | im_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for im_users.
     */
    cursor?: im_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of im_users.
     */
    distinct?: Im_userScalarFieldEnum | Im_userScalarFieldEnum[]
  }


  /**
   * im_user findMany
   */
  export type im_userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_user
     */
    select?: im_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_userInclude<ExtArgs> | null
    /**
     * Filter, which im_users to fetch.
     */
    where?: im_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_users to fetch.
     */
    orderBy?: im_userOrderByWithRelationInput | im_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing im_users.
     */
    cursor?: im_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_users.
     */
    skip?: number
    distinct?: Im_userScalarFieldEnum | Im_userScalarFieldEnum[]
  }


  /**
   * im_user create
   */
  export type im_userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_user
     */
    select?: im_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_userInclude<ExtArgs> | null
    /**
     * The data needed to create a im_user.
     */
    data: XOR<im_userCreateInput, im_userUncheckedCreateInput>
  }


  /**
   * im_user createMany
   */
  export type im_userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many im_users.
     */
    data: im_userCreateManyInput | im_userCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * im_user update
   */
  export type im_userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_user
     */
    select?: im_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_userInclude<ExtArgs> | null
    /**
     * The data needed to update a im_user.
     */
    data: XOR<im_userUpdateInput, im_userUncheckedUpdateInput>
    /**
     * Choose, which im_user to update.
     */
    where: im_userWhereUniqueInput
  }


  /**
   * im_user updateMany
   */
  export type im_userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update im_users.
     */
    data: XOR<im_userUpdateManyMutationInput, im_userUncheckedUpdateManyInput>
    /**
     * Filter which im_users to update
     */
    where?: im_userWhereInput
  }


  /**
   * im_user upsert
   */
  export type im_userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_user
     */
    select?: im_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_userInclude<ExtArgs> | null
    /**
     * The filter to search for the im_user to update in case it exists.
     */
    where: im_userWhereUniqueInput
    /**
     * In case the im_user found by the `where` argument doesn't exist, create a new im_user with this data.
     */
    create: XOR<im_userCreateInput, im_userUncheckedCreateInput>
    /**
     * In case the im_user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<im_userUpdateInput, im_userUncheckedUpdateInput>
  }


  /**
   * im_user delete
   */
  export type im_userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_user
     */
    select?: im_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_userInclude<ExtArgs> | null
    /**
     * Filter which im_user to delete.
     */
    where: im_userWhereUniqueInput
  }


  /**
   * im_user deleteMany
   */
  export type im_userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which im_users to delete
     */
    where?: im_userWhereInput
  }


  /**
   * im_user.im_health
   */
  export type im_user$im_healthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_health
     */
    select?: im_healthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_healthInclude<ExtArgs> | null
    where?: im_healthWhereInput
    orderBy?: im_healthOrderByWithRelationInput | im_healthOrderByWithRelationInput[]
    cursor?: im_healthWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Im_healthScalarFieldEnum | Im_healthScalarFieldEnum[]
  }


  /**
   * im_user.im_nutrition
   */
  export type im_user$im_nutritionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_nutrition
     */
    select?: im_nutritionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_nutritionInclude<ExtArgs> | null
    where?: im_nutritionWhereInput
    orderBy?: im_nutritionOrderByWithRelationInput | im_nutritionOrderByWithRelationInput[]
    cursor?: im_nutritionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Im_nutritionScalarFieldEnum | Im_nutritionScalarFieldEnum[]
  }


  /**
   * im_user.im_training
   */
  export type im_user$im_trainingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_training
     */
    select?: im_trainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_trainingInclude<ExtArgs> | null
    where?: im_trainingWhereInput
    orderBy?: im_trainingOrderByWithRelationInput | im_trainingOrderByWithRelationInput[]
    cursor?: im_trainingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Im_trainingScalarFieldEnum | Im_trainingScalarFieldEnum[]
  }


  /**
   * im_user.im_undesirable_food
   */
  export type im_user$im_undesirable_foodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_undesirable_food
     */
    select?: im_undesirable_foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_undesirable_foodInclude<ExtArgs> | null
    where?: im_undesirable_foodWhereInput
    orderBy?: im_undesirable_foodOrderByWithRelationInput | im_undesirable_foodOrderByWithRelationInput[]
    cursor?: im_undesirable_foodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Im_undesirable_foodScalarFieldEnum | Im_undesirable_foodScalarFieldEnum[]
  }


  /**
   * im_user without action
   */
  export type im_userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_user
     */
    select?: im_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_userInclude<ExtArgs> | null
  }



  /**
   * Model im_workout
   */

  export type AggregateIm_workout = {
    _count: Im_workoutCountAggregateOutputType | null
    _avg: Im_workoutAvgAggregateOutputType | null
    _sum: Im_workoutSumAggregateOutputType | null
    _min: Im_workoutMinAggregateOutputType | null
    _max: Im_workoutMaxAggregateOutputType | null
  }

  export type Im_workoutAvgAggregateOutputType = {
    id_workout: number | null
    workout_point: number | null
    id_training: number | null
  }

  export type Im_workoutSumAggregateOutputType = {
    id_workout: number | null
    workout_point: number | null
    id_training: number | null
  }

  export type Im_workoutMinAggregateOutputType = {
    id_workout: number | null
    workout_point: number | null
    workout_name: string | null
    workout_comment: string | null
    id_training: number | null
  }

  export type Im_workoutMaxAggregateOutputType = {
    id_workout: number | null
    workout_point: number | null
    workout_name: string | null
    workout_comment: string | null
    id_training: number | null
  }

  export type Im_workoutCountAggregateOutputType = {
    id_workout: number
    workout_point: number
    workout_name: number
    workout_comment: number
    id_training: number
    _all: number
  }


  export type Im_workoutAvgAggregateInputType = {
    id_workout?: true
    workout_point?: true
    id_training?: true
  }

  export type Im_workoutSumAggregateInputType = {
    id_workout?: true
    workout_point?: true
    id_training?: true
  }

  export type Im_workoutMinAggregateInputType = {
    id_workout?: true
    workout_point?: true
    workout_name?: true
    workout_comment?: true
    id_training?: true
  }

  export type Im_workoutMaxAggregateInputType = {
    id_workout?: true
    workout_point?: true
    workout_name?: true
    workout_comment?: true
    id_training?: true
  }

  export type Im_workoutCountAggregateInputType = {
    id_workout?: true
    workout_point?: true
    workout_name?: true
    workout_comment?: true
    id_training?: true
    _all?: true
  }

  export type Im_workoutAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which im_workout to aggregate.
     */
    where?: im_workoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_workouts to fetch.
     */
    orderBy?: im_workoutOrderByWithRelationInput | im_workoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: im_workoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_workouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_workouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned im_workouts
    **/
    _count?: true | Im_workoutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Im_workoutAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Im_workoutSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Im_workoutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Im_workoutMaxAggregateInputType
  }

  export type GetIm_workoutAggregateType<T extends Im_workoutAggregateArgs> = {
        [P in keyof T & keyof AggregateIm_workout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIm_workout[P]>
      : GetScalarType<T[P], AggregateIm_workout[P]>
  }




  export type im_workoutGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: im_workoutWhereInput
    orderBy?: im_workoutOrderByWithAggregationInput | im_workoutOrderByWithAggregationInput[]
    by: Im_workoutScalarFieldEnum[] | Im_workoutScalarFieldEnum
    having?: im_workoutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Im_workoutCountAggregateInputType | true
    _avg?: Im_workoutAvgAggregateInputType
    _sum?: Im_workoutSumAggregateInputType
    _min?: Im_workoutMinAggregateInputType
    _max?: Im_workoutMaxAggregateInputType
  }

  export type Im_workoutGroupByOutputType = {
    id_workout: number
    workout_point: number
    workout_name: string
    workout_comment: string
    id_training: number
    _count: Im_workoutCountAggregateOutputType | null
    _avg: Im_workoutAvgAggregateOutputType | null
    _sum: Im_workoutSumAggregateOutputType | null
    _min: Im_workoutMinAggregateOutputType | null
    _max: Im_workoutMaxAggregateOutputType | null
  }

  type GetIm_workoutGroupByPayload<T extends im_workoutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Im_workoutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Im_workoutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Im_workoutGroupByOutputType[P]>
            : GetScalarType<T[P], Im_workoutGroupByOutputType[P]>
        }
      >
    >


  export type im_workoutSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_workout?: boolean
    workout_point?: boolean
    workout_name?: boolean
    workout_comment?: boolean
    id_training?: boolean
    im_exercise?: boolean | im_workout$im_exerciseArgs<ExtArgs>
    im_training?: boolean | im_trainingDefaultArgs<ExtArgs>
    _count?: boolean | Im_workoutCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["im_workout"]>

  export type im_workoutSelectScalar = {
    id_workout?: boolean
    workout_point?: boolean
    workout_name?: boolean
    workout_comment?: boolean
    id_training?: boolean
  }

  export type im_workoutInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    im_exercise?: boolean | im_workout$im_exerciseArgs<ExtArgs>
    im_training?: boolean | im_trainingDefaultArgs<ExtArgs>
    _count?: boolean | Im_workoutCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $im_workoutPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "im_workout"
    objects: {
      im_exercise: Prisma.$im_exercisePayload<ExtArgs>[]
      im_training: Prisma.$im_trainingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_workout: number
      workout_point: number
      workout_name: string
      workout_comment: string
      id_training: number
    }, ExtArgs["result"]["im_workout"]>
    composites: {}
  }


  type im_workoutGetPayload<S extends boolean | null | undefined | im_workoutDefaultArgs> = $Result.GetResult<Prisma.$im_workoutPayload, S>

  type im_workoutCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<im_workoutFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Im_workoutCountAggregateInputType | true
    }

  export interface im_workoutDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['im_workout'], meta: { name: 'im_workout' } }
    /**
     * Find zero or one Im_workout that matches the filter.
     * @param {im_workoutFindUniqueArgs} args - Arguments to find a Im_workout
     * @example
     * // Get one Im_workout
     * const im_workout = await prisma.im_workout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends im_workoutFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, im_workoutFindUniqueArgs<ExtArgs>>
    ): Prisma__im_workoutClient<$Result.GetResult<Prisma.$im_workoutPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Im_workout that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {im_workoutFindUniqueOrThrowArgs} args - Arguments to find a Im_workout
     * @example
     * // Get one Im_workout
     * const im_workout = await prisma.im_workout.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends im_workoutFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, im_workoutFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__im_workoutClient<$Result.GetResult<Prisma.$im_workoutPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Im_workout that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_workoutFindFirstArgs} args - Arguments to find a Im_workout
     * @example
     * // Get one Im_workout
     * const im_workout = await prisma.im_workout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends im_workoutFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, im_workoutFindFirstArgs<ExtArgs>>
    ): Prisma__im_workoutClient<$Result.GetResult<Prisma.$im_workoutPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Im_workout that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_workoutFindFirstOrThrowArgs} args - Arguments to find a Im_workout
     * @example
     * // Get one Im_workout
     * const im_workout = await prisma.im_workout.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends im_workoutFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, im_workoutFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__im_workoutClient<$Result.GetResult<Prisma.$im_workoutPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Im_workouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_workoutFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Im_workouts
     * const im_workouts = await prisma.im_workout.findMany()
     * 
     * // Get first 10 Im_workouts
     * const im_workouts = await prisma.im_workout.findMany({ take: 10 })
     * 
     * // Only select the `id_workout`
     * const im_workoutWithId_workoutOnly = await prisma.im_workout.findMany({ select: { id_workout: true } })
     * 
    **/
    findMany<T extends im_workoutFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_workoutFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$im_workoutPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Im_workout.
     * @param {im_workoutCreateArgs} args - Arguments to create a Im_workout.
     * @example
     * // Create one Im_workout
     * const Im_workout = await prisma.im_workout.create({
     *   data: {
     *     // ... data to create a Im_workout
     *   }
     * })
     * 
    **/
    create<T extends im_workoutCreateArgs<ExtArgs>>(
      args: SelectSubset<T, im_workoutCreateArgs<ExtArgs>>
    ): Prisma__im_workoutClient<$Result.GetResult<Prisma.$im_workoutPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Im_workouts.
     *     @param {im_workoutCreateManyArgs} args - Arguments to create many Im_workouts.
     *     @example
     *     // Create many Im_workouts
     *     const im_workout = await prisma.im_workout.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends im_workoutCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_workoutCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Im_workout.
     * @param {im_workoutDeleteArgs} args - Arguments to delete one Im_workout.
     * @example
     * // Delete one Im_workout
     * const Im_workout = await prisma.im_workout.delete({
     *   where: {
     *     // ... filter to delete one Im_workout
     *   }
     * })
     * 
    **/
    delete<T extends im_workoutDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, im_workoutDeleteArgs<ExtArgs>>
    ): Prisma__im_workoutClient<$Result.GetResult<Prisma.$im_workoutPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Im_workout.
     * @param {im_workoutUpdateArgs} args - Arguments to update one Im_workout.
     * @example
     * // Update one Im_workout
     * const im_workout = await prisma.im_workout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends im_workoutUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, im_workoutUpdateArgs<ExtArgs>>
    ): Prisma__im_workoutClient<$Result.GetResult<Prisma.$im_workoutPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Im_workouts.
     * @param {im_workoutDeleteManyArgs} args - Arguments to filter Im_workouts to delete.
     * @example
     * // Delete a few Im_workouts
     * const { count } = await prisma.im_workout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends im_workoutDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, im_workoutDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Im_workouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_workoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Im_workouts
     * const im_workout = await prisma.im_workout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends im_workoutUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, im_workoutUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Im_workout.
     * @param {im_workoutUpsertArgs} args - Arguments to update or create a Im_workout.
     * @example
     * // Update or create a Im_workout
     * const im_workout = await prisma.im_workout.upsert({
     *   create: {
     *     // ... data to create a Im_workout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Im_workout we want to update
     *   }
     * })
    **/
    upsert<T extends im_workoutUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, im_workoutUpsertArgs<ExtArgs>>
    ): Prisma__im_workoutClient<$Result.GetResult<Prisma.$im_workoutPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Im_workouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_workoutCountArgs} args - Arguments to filter Im_workouts to count.
     * @example
     * // Count the number of Im_workouts
     * const count = await prisma.im_workout.count({
     *   where: {
     *     // ... the filter for the Im_workouts we want to count
     *   }
     * })
    **/
    count<T extends im_workoutCountArgs>(
      args?: Subset<T, im_workoutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Im_workoutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Im_workout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Im_workoutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Im_workoutAggregateArgs>(args: Subset<T, Im_workoutAggregateArgs>): Prisma.PrismaPromise<GetIm_workoutAggregateType<T>>

    /**
     * Group by Im_workout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {im_workoutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends im_workoutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: im_workoutGroupByArgs['orderBy'] }
        : { orderBy?: im_workoutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, im_workoutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIm_workoutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the im_workout model
   */
  readonly fields: im_workoutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for im_workout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__im_workoutClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    im_exercise<T extends im_workout$im_exerciseArgs<ExtArgs> = {}>(args?: Subset<T, im_workout$im_exerciseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$im_exercisePayload<ExtArgs>, T, 'findMany'> | Null>;

    im_training<T extends im_trainingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, im_trainingDefaultArgs<ExtArgs>>): Prisma__im_trainingClient<$Result.GetResult<Prisma.$im_trainingPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the im_workout model
   */ 
  interface im_workoutFieldRefs {
    readonly id_workout: FieldRef<"im_workout", 'Int'>
    readonly workout_point: FieldRef<"im_workout", 'Int'>
    readonly workout_name: FieldRef<"im_workout", 'String'>
    readonly workout_comment: FieldRef<"im_workout", 'String'>
    readonly id_training: FieldRef<"im_workout", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * im_workout findUnique
   */
  export type im_workoutFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_workout
     */
    select?: im_workoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_workoutInclude<ExtArgs> | null
    /**
     * Filter, which im_workout to fetch.
     */
    where: im_workoutWhereUniqueInput
  }


  /**
   * im_workout findUniqueOrThrow
   */
  export type im_workoutFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_workout
     */
    select?: im_workoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_workoutInclude<ExtArgs> | null
    /**
     * Filter, which im_workout to fetch.
     */
    where: im_workoutWhereUniqueInput
  }


  /**
   * im_workout findFirst
   */
  export type im_workoutFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_workout
     */
    select?: im_workoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_workoutInclude<ExtArgs> | null
    /**
     * Filter, which im_workout to fetch.
     */
    where?: im_workoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_workouts to fetch.
     */
    orderBy?: im_workoutOrderByWithRelationInput | im_workoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for im_workouts.
     */
    cursor?: im_workoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_workouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_workouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of im_workouts.
     */
    distinct?: Im_workoutScalarFieldEnum | Im_workoutScalarFieldEnum[]
  }


  /**
   * im_workout findFirstOrThrow
   */
  export type im_workoutFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_workout
     */
    select?: im_workoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_workoutInclude<ExtArgs> | null
    /**
     * Filter, which im_workout to fetch.
     */
    where?: im_workoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_workouts to fetch.
     */
    orderBy?: im_workoutOrderByWithRelationInput | im_workoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for im_workouts.
     */
    cursor?: im_workoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_workouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_workouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of im_workouts.
     */
    distinct?: Im_workoutScalarFieldEnum | Im_workoutScalarFieldEnum[]
  }


  /**
   * im_workout findMany
   */
  export type im_workoutFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_workout
     */
    select?: im_workoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_workoutInclude<ExtArgs> | null
    /**
     * Filter, which im_workouts to fetch.
     */
    where?: im_workoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of im_workouts to fetch.
     */
    orderBy?: im_workoutOrderByWithRelationInput | im_workoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing im_workouts.
     */
    cursor?: im_workoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` im_workouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` im_workouts.
     */
    skip?: number
    distinct?: Im_workoutScalarFieldEnum | Im_workoutScalarFieldEnum[]
  }


  /**
   * im_workout create
   */
  export type im_workoutCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_workout
     */
    select?: im_workoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_workoutInclude<ExtArgs> | null
    /**
     * The data needed to create a im_workout.
     */
    data: XOR<im_workoutCreateInput, im_workoutUncheckedCreateInput>
  }


  /**
   * im_workout createMany
   */
  export type im_workoutCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many im_workouts.
     */
    data: im_workoutCreateManyInput | im_workoutCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * im_workout update
   */
  export type im_workoutUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_workout
     */
    select?: im_workoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_workoutInclude<ExtArgs> | null
    /**
     * The data needed to update a im_workout.
     */
    data: XOR<im_workoutUpdateInput, im_workoutUncheckedUpdateInput>
    /**
     * Choose, which im_workout to update.
     */
    where: im_workoutWhereUniqueInput
  }


  /**
   * im_workout updateMany
   */
  export type im_workoutUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update im_workouts.
     */
    data: XOR<im_workoutUpdateManyMutationInput, im_workoutUncheckedUpdateManyInput>
    /**
     * Filter which im_workouts to update
     */
    where?: im_workoutWhereInput
  }


  /**
   * im_workout upsert
   */
  export type im_workoutUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_workout
     */
    select?: im_workoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_workoutInclude<ExtArgs> | null
    /**
     * The filter to search for the im_workout to update in case it exists.
     */
    where: im_workoutWhereUniqueInput
    /**
     * In case the im_workout found by the `where` argument doesn't exist, create a new im_workout with this data.
     */
    create: XOR<im_workoutCreateInput, im_workoutUncheckedCreateInput>
    /**
     * In case the im_workout was found with the provided `where` argument, update it with this data.
     */
    update: XOR<im_workoutUpdateInput, im_workoutUncheckedUpdateInput>
  }


  /**
   * im_workout delete
   */
  export type im_workoutDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_workout
     */
    select?: im_workoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_workoutInclude<ExtArgs> | null
    /**
     * Filter which im_workout to delete.
     */
    where: im_workoutWhereUniqueInput
  }


  /**
   * im_workout deleteMany
   */
  export type im_workoutDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which im_workouts to delete
     */
    where?: im_workoutWhereInput
  }


  /**
   * im_workout.im_exercise
   */
  export type im_workout$im_exerciseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_exercise
     */
    select?: im_exerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_exerciseInclude<ExtArgs> | null
    where?: im_exerciseWhereInput
    orderBy?: im_exerciseOrderByWithRelationInput | im_exerciseOrderByWithRelationInput[]
    cursor?: im_exerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Im_exerciseScalarFieldEnum | Im_exerciseScalarFieldEnum[]
  }


  /**
   * im_workout without action
   */
  export type im_workoutDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the im_workout
     */
    select?: im_workoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: im_workoutInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Im_exerciseScalarFieldEnum: {
    id_exercise: 'id_exercise',
    exercise_name: 'exercise_name',
    exercise_type: 'exercise_type',
    exercise_rest_time: 'exercise_rest_time',
    exercise_reps: 'exercise_reps',
    exercise_series: 'exercise_series',
    exercise_description: 'exercise_description',
    id_workout: 'id_workout'
  };

  export type Im_exerciseScalarFieldEnum = (typeof Im_exerciseScalarFieldEnum)[keyof typeof Im_exerciseScalarFieldEnum]


  export const Im_exercise_historyScalarFieldEnum: {
    id_exercise_history: 'id_exercise_history',
    exercise_history_date: 'exercise_history_date',
    id_exercise: 'id_exercise'
  };

  export type Im_exercise_historyScalarFieldEnum = (typeof Im_exercise_historyScalarFieldEnum)[keyof typeof Im_exercise_historyScalarFieldEnum]


  export const Im_foodScalarFieldEnum: {
    id_food: 'id_food',
    food_name: 'food_name',
    food_type: 'food_type',
    food_calories: 'food_calories',
    food_carbs: 'food_carbs',
    food_prots: 'food_prots',
    food_fats: 'food_fats'
  };

  export type Im_foodScalarFieldEnum = (typeof Im_foodScalarFieldEnum)[keyof typeof Im_foodScalarFieldEnum]


  export const Im_healthScalarFieldEnum: {
    id_health: 'id_health',
    id_user: 'id_user'
  };

  export type Im_healthScalarFieldEnum = (typeof Im_healthScalarFieldEnum)[keyof typeof Im_healthScalarFieldEnum]


  export const Im_health_goalScalarFieldEnum: {
    id_health_goal: 'id_health_goal',
    health_goal_steps: 'health_goal_steps',
    health_goal_weight: 'health_goal_weight',
    health_goal_sleep: 'health_goal_sleep',
    health_goal_water: 'health_goal_water',
    id_health: 'id_health'
  };

  export type Im_health_goalScalarFieldEnum = (typeof Im_health_goalScalarFieldEnum)[keyof typeof Im_health_goalScalarFieldEnum]


  export const Im_health_goal_dailyScalarFieldEnum: {
    id_health_goal_daily: 'id_health_goal_daily',
    health_goal_daily_date: 'health_goal_daily_date',
    health_goal_daily_steps: 'health_goal_daily_steps',
    health_goal_daily_weight: 'health_goal_daily_weight',
    health_goal_daily_sleep: 'health_goal_daily_sleep',
    health_goal_daily_water: 'health_goal_daily_water',
    id_health_goal: 'id_health_goal'
  };

  export type Im_health_goal_dailyScalarFieldEnum = (typeof Im_health_goal_dailyScalarFieldEnum)[keyof typeof Im_health_goal_dailyScalarFieldEnum]


  export const Im_health_goal_daily_historyScalarFieldEnum: {
    id_health_goal_daily_history: 'id_health_goal_daily_history',
    health_goal_daily_history_date: 'health_goal_daily_history_date',
    id_health_goal_daily: 'id_health_goal_daily'
  };

  export type Im_health_goal_daily_historyScalarFieldEnum = (typeof Im_health_goal_daily_historyScalarFieldEnum)[keyof typeof Im_health_goal_daily_historyScalarFieldEnum]


  export const Im_mealScalarFieldEnum: {
    id_meal: 'id_meal',
    meal_name: 'meal_name',
    meal_quantity: 'meal_quantity',
    meal_calories: 'meal_calories',
    meal_carbs: 'meal_carbs',
    meal_prots: 'meal_prots',
    meal_fats: 'meal_fats',
    meal_description: 'meal_description',
    meal_length: 'meal_length',
    meal_image: 'meal_image',
    meal_difficulty: 'meal_difficulty',
    meal_season: 'meal_season',
    id_nutrition: 'id_nutrition'
  };

  export type Im_mealScalarFieldEnum = (typeof Im_mealScalarFieldEnum)[keyof typeof Im_mealScalarFieldEnum]


  export const Im_nutritionScalarFieldEnum: {
    id_nutrition: 'id_nutrition',
    nutrition_goal: 'nutrition_goal',
    nutrition_goal_calories: 'nutrition_goal_calories',
    nutrition_goal_carbs: 'nutrition_goal_carbs',
    nutrition_goal_prots: 'nutrition_goal_prots',
    nutrition_goal_fats: 'nutrition_goal_fats',
    id_user: 'id_user'
  };

  export type Im_nutritionScalarFieldEnum = (typeof Im_nutritionScalarFieldEnum)[keyof typeof Im_nutritionScalarFieldEnum]


  export const Im_recipeScalarFieldEnum: {
    id_recipe: 'id_recipe',
    id_meal: 'id_meal',
    id_food: 'id_food'
  };

  export type Im_recipeScalarFieldEnum = (typeof Im_recipeScalarFieldEnum)[keyof typeof Im_recipeScalarFieldEnum]


  export const Im_trainingScalarFieldEnum: {
    id_training: 'id_training',
    training_goal: 'training_goal',
    id_user: 'id_user'
  };

  export type Im_trainingScalarFieldEnum = (typeof Im_trainingScalarFieldEnum)[keyof typeof Im_trainingScalarFieldEnum]


  export const Im_undesirable_foodScalarFieldEnum: {
    id_undesirable_food: 'id_undesirable_food',
    id_food: 'id_food',
    id_user: 'id_user'
  };

  export type Im_undesirable_foodScalarFieldEnum = (typeof Im_undesirable_foodScalarFieldEnum)[keyof typeof Im_undesirable_foodScalarFieldEnum]


  export const Im_userScalarFieldEnum: {
    id_user: 'id_user',
    user_firstname: 'user_firstname',
    user_name: 'user_name',
    user_mail: 'user_mail',
    user_password: 'user_password',
    user_birth_date: 'user_birth_date',
    user_inscription_date: 'user_inscription_date',
    user_gender: 'user_gender',
    user_height: 'user_height',
    user_weight: 'user_weight',
    user_age: 'user_age',
    user_training_level: 'user_training_level',
    user_nutrition_diet: 'user_nutrition_diet'
  };

  export type Im_userScalarFieldEnum = (typeof Im_userScalarFieldEnum)[keyof typeof Im_userScalarFieldEnum]


  export const Im_workoutScalarFieldEnum: {
    id_workout: 'id_workout',
    workout_point: 'workout_point',
    workout_name: 'workout_name',
    workout_comment: 'workout_comment',
    id_training: 'id_training'
  };

  export type Im_workoutScalarFieldEnum = (typeof Im_workoutScalarFieldEnum)[keyof typeof Im_workoutScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type im_exerciseWhereInput = {
    AND?: im_exerciseWhereInput | im_exerciseWhereInput[]
    OR?: im_exerciseWhereInput[]
    NOT?: im_exerciseWhereInput | im_exerciseWhereInput[]
    id_exercise?: IntFilter<"im_exercise"> | number
    exercise_name?: StringFilter<"im_exercise"> | string
    exercise_type?: StringFilter<"im_exercise"> | string
    exercise_rest_time?: IntFilter<"im_exercise"> | number
    exercise_reps?: IntFilter<"im_exercise"> | number
    exercise_series?: IntFilter<"im_exercise"> | number
    exercise_description?: StringFilter<"im_exercise"> | string
    id_workout?: IntFilter<"im_exercise"> | number
    im_workout?: XOR<Im_workoutRelationFilter, im_workoutWhereInput>
    im_exercise_history?: Im_exercise_historyListRelationFilter
  }

  export type im_exerciseOrderByWithRelationInput = {
    id_exercise?: SortOrder
    exercise_name?: SortOrder
    exercise_type?: SortOrder
    exercise_rest_time?: SortOrder
    exercise_reps?: SortOrder
    exercise_series?: SortOrder
    exercise_description?: SortOrder
    id_workout?: SortOrder
    im_workout?: im_workoutOrderByWithRelationInput
    im_exercise_history?: im_exercise_historyOrderByRelationAggregateInput
  }

  export type im_exerciseWhereUniqueInput = Prisma.AtLeast<{
    id_exercise?: number
    AND?: im_exerciseWhereInput | im_exerciseWhereInput[]
    OR?: im_exerciseWhereInput[]
    NOT?: im_exerciseWhereInput | im_exerciseWhereInput[]
    exercise_name?: StringFilter<"im_exercise"> | string
    exercise_type?: StringFilter<"im_exercise"> | string
    exercise_rest_time?: IntFilter<"im_exercise"> | number
    exercise_reps?: IntFilter<"im_exercise"> | number
    exercise_series?: IntFilter<"im_exercise"> | number
    exercise_description?: StringFilter<"im_exercise"> | string
    id_workout?: IntFilter<"im_exercise"> | number
    im_workout?: XOR<Im_workoutRelationFilter, im_workoutWhereInput>
    im_exercise_history?: Im_exercise_historyListRelationFilter
  }, "id_exercise">

  export type im_exerciseOrderByWithAggregationInput = {
    id_exercise?: SortOrder
    exercise_name?: SortOrder
    exercise_type?: SortOrder
    exercise_rest_time?: SortOrder
    exercise_reps?: SortOrder
    exercise_series?: SortOrder
    exercise_description?: SortOrder
    id_workout?: SortOrder
    _count?: im_exerciseCountOrderByAggregateInput
    _avg?: im_exerciseAvgOrderByAggregateInput
    _max?: im_exerciseMaxOrderByAggregateInput
    _min?: im_exerciseMinOrderByAggregateInput
    _sum?: im_exerciseSumOrderByAggregateInput
  }

  export type im_exerciseScalarWhereWithAggregatesInput = {
    AND?: im_exerciseScalarWhereWithAggregatesInput | im_exerciseScalarWhereWithAggregatesInput[]
    OR?: im_exerciseScalarWhereWithAggregatesInput[]
    NOT?: im_exerciseScalarWhereWithAggregatesInput | im_exerciseScalarWhereWithAggregatesInput[]
    id_exercise?: IntWithAggregatesFilter<"im_exercise"> | number
    exercise_name?: StringWithAggregatesFilter<"im_exercise"> | string
    exercise_type?: StringWithAggregatesFilter<"im_exercise"> | string
    exercise_rest_time?: IntWithAggregatesFilter<"im_exercise"> | number
    exercise_reps?: IntWithAggregatesFilter<"im_exercise"> | number
    exercise_series?: IntWithAggregatesFilter<"im_exercise"> | number
    exercise_description?: StringWithAggregatesFilter<"im_exercise"> | string
    id_workout?: IntWithAggregatesFilter<"im_exercise"> | number
  }

  export type im_exercise_historyWhereInput = {
    AND?: im_exercise_historyWhereInput | im_exercise_historyWhereInput[]
    OR?: im_exercise_historyWhereInput[]
    NOT?: im_exercise_historyWhereInput | im_exercise_historyWhereInput[]
    id_exercise_history?: IntFilter<"im_exercise_history"> | number
    exercise_history_date?: DateTimeFilter<"im_exercise_history"> | Date | string
    id_exercise?: IntFilter<"im_exercise_history"> | number
    im_exercise?: XOR<Im_exerciseRelationFilter, im_exerciseWhereInput>
  }

  export type im_exercise_historyOrderByWithRelationInput = {
    id_exercise_history?: SortOrder
    exercise_history_date?: SortOrder
    id_exercise?: SortOrder
    im_exercise?: im_exerciseOrderByWithRelationInput
  }

  export type im_exercise_historyWhereUniqueInput = Prisma.AtLeast<{
    id_exercise_history?: number
    AND?: im_exercise_historyWhereInput | im_exercise_historyWhereInput[]
    OR?: im_exercise_historyWhereInput[]
    NOT?: im_exercise_historyWhereInput | im_exercise_historyWhereInput[]
    exercise_history_date?: DateTimeFilter<"im_exercise_history"> | Date | string
    id_exercise?: IntFilter<"im_exercise_history"> | number
    im_exercise?: XOR<Im_exerciseRelationFilter, im_exerciseWhereInput>
  }, "id_exercise_history">

  export type im_exercise_historyOrderByWithAggregationInput = {
    id_exercise_history?: SortOrder
    exercise_history_date?: SortOrder
    id_exercise?: SortOrder
    _count?: im_exercise_historyCountOrderByAggregateInput
    _avg?: im_exercise_historyAvgOrderByAggregateInput
    _max?: im_exercise_historyMaxOrderByAggregateInput
    _min?: im_exercise_historyMinOrderByAggregateInput
    _sum?: im_exercise_historySumOrderByAggregateInput
  }

  export type im_exercise_historyScalarWhereWithAggregatesInput = {
    AND?: im_exercise_historyScalarWhereWithAggregatesInput | im_exercise_historyScalarWhereWithAggregatesInput[]
    OR?: im_exercise_historyScalarWhereWithAggregatesInput[]
    NOT?: im_exercise_historyScalarWhereWithAggregatesInput | im_exercise_historyScalarWhereWithAggregatesInput[]
    id_exercise_history?: IntWithAggregatesFilter<"im_exercise_history"> | number
    exercise_history_date?: DateTimeWithAggregatesFilter<"im_exercise_history"> | Date | string
    id_exercise?: IntWithAggregatesFilter<"im_exercise_history"> | number
  }

  export type im_foodWhereInput = {
    AND?: im_foodWhereInput | im_foodWhereInput[]
    OR?: im_foodWhereInput[]
    NOT?: im_foodWhereInput | im_foodWhereInput[]
    id_food?: IntFilter<"im_food"> | number
    food_name?: StringFilter<"im_food"> | string
    food_type?: StringFilter<"im_food"> | string
    food_calories?: IntFilter<"im_food"> | number
    food_carbs?: IntFilter<"im_food"> | number
    food_prots?: IntFilter<"im_food"> | number
    food_fats?: IntFilter<"im_food"> | number
    im_recipe?: Im_recipeListRelationFilter
    im_undesirable_food?: Im_undesirable_foodListRelationFilter
  }

  export type im_foodOrderByWithRelationInput = {
    id_food?: SortOrder
    food_name?: SortOrder
    food_type?: SortOrder
    food_calories?: SortOrder
    food_carbs?: SortOrder
    food_prots?: SortOrder
    food_fats?: SortOrder
    im_recipe?: im_recipeOrderByRelationAggregateInput
    im_undesirable_food?: im_undesirable_foodOrderByRelationAggregateInput
  }

  export type im_foodWhereUniqueInput = Prisma.AtLeast<{
    id_food?: number
    AND?: im_foodWhereInput | im_foodWhereInput[]
    OR?: im_foodWhereInput[]
    NOT?: im_foodWhereInput | im_foodWhereInput[]
    food_name?: StringFilter<"im_food"> | string
    food_type?: StringFilter<"im_food"> | string
    food_calories?: IntFilter<"im_food"> | number
    food_carbs?: IntFilter<"im_food"> | number
    food_prots?: IntFilter<"im_food"> | number
    food_fats?: IntFilter<"im_food"> | number
    im_recipe?: Im_recipeListRelationFilter
    im_undesirable_food?: Im_undesirable_foodListRelationFilter
  }, "id_food">

  export type im_foodOrderByWithAggregationInput = {
    id_food?: SortOrder
    food_name?: SortOrder
    food_type?: SortOrder
    food_calories?: SortOrder
    food_carbs?: SortOrder
    food_prots?: SortOrder
    food_fats?: SortOrder
    _count?: im_foodCountOrderByAggregateInput
    _avg?: im_foodAvgOrderByAggregateInput
    _max?: im_foodMaxOrderByAggregateInput
    _min?: im_foodMinOrderByAggregateInput
    _sum?: im_foodSumOrderByAggregateInput
  }

  export type im_foodScalarWhereWithAggregatesInput = {
    AND?: im_foodScalarWhereWithAggregatesInput | im_foodScalarWhereWithAggregatesInput[]
    OR?: im_foodScalarWhereWithAggregatesInput[]
    NOT?: im_foodScalarWhereWithAggregatesInput | im_foodScalarWhereWithAggregatesInput[]
    id_food?: IntWithAggregatesFilter<"im_food"> | number
    food_name?: StringWithAggregatesFilter<"im_food"> | string
    food_type?: StringWithAggregatesFilter<"im_food"> | string
    food_calories?: IntWithAggregatesFilter<"im_food"> | number
    food_carbs?: IntWithAggregatesFilter<"im_food"> | number
    food_prots?: IntWithAggregatesFilter<"im_food"> | number
    food_fats?: IntWithAggregatesFilter<"im_food"> | number
  }

  export type im_healthWhereInput = {
    AND?: im_healthWhereInput | im_healthWhereInput[]
    OR?: im_healthWhereInput[]
    NOT?: im_healthWhereInput | im_healthWhereInput[]
    id_health?: IntFilter<"im_health"> | number
    id_user?: IntFilter<"im_health"> | number
    im_user?: XOR<Im_userRelationFilter, im_userWhereInput>
    im_health_goal?: Im_health_goalListRelationFilter
  }

  export type im_healthOrderByWithRelationInput = {
    id_health?: SortOrder
    id_user?: SortOrder
    im_user?: im_userOrderByWithRelationInput
    im_health_goal?: im_health_goalOrderByRelationAggregateInput
  }

  export type im_healthWhereUniqueInput = Prisma.AtLeast<{
    id_health?: number
    AND?: im_healthWhereInput | im_healthWhereInput[]
    OR?: im_healthWhereInput[]
    NOT?: im_healthWhereInput | im_healthWhereInput[]
    id_user?: IntFilter<"im_health"> | number
    im_user?: XOR<Im_userRelationFilter, im_userWhereInput>
    im_health_goal?: Im_health_goalListRelationFilter
  }, "id_health">

  export type im_healthOrderByWithAggregationInput = {
    id_health?: SortOrder
    id_user?: SortOrder
    _count?: im_healthCountOrderByAggregateInput
    _avg?: im_healthAvgOrderByAggregateInput
    _max?: im_healthMaxOrderByAggregateInput
    _min?: im_healthMinOrderByAggregateInput
    _sum?: im_healthSumOrderByAggregateInput
  }

  export type im_healthScalarWhereWithAggregatesInput = {
    AND?: im_healthScalarWhereWithAggregatesInput | im_healthScalarWhereWithAggregatesInput[]
    OR?: im_healthScalarWhereWithAggregatesInput[]
    NOT?: im_healthScalarWhereWithAggregatesInput | im_healthScalarWhereWithAggregatesInput[]
    id_health?: IntWithAggregatesFilter<"im_health"> | number
    id_user?: IntWithAggregatesFilter<"im_health"> | number
  }

  export type im_health_goalWhereInput = {
    AND?: im_health_goalWhereInput | im_health_goalWhereInput[]
    OR?: im_health_goalWhereInput[]
    NOT?: im_health_goalWhereInput | im_health_goalWhereInput[]
    id_health_goal?: IntFilter<"im_health_goal"> | number
    health_goal_steps?: IntFilter<"im_health_goal"> | number
    health_goal_weight?: IntFilter<"im_health_goal"> | number
    health_goal_sleep?: IntFilter<"im_health_goal"> | number
    health_goal_water?: IntFilter<"im_health_goal"> | number
    id_health?: IntFilter<"im_health_goal"> | number
    im_health?: XOR<Im_healthRelationFilter, im_healthWhereInput>
    im_health_goal_daily?: Im_health_goal_dailyListRelationFilter
  }

  export type im_health_goalOrderByWithRelationInput = {
    id_health_goal?: SortOrder
    health_goal_steps?: SortOrder
    health_goal_weight?: SortOrder
    health_goal_sleep?: SortOrder
    health_goal_water?: SortOrder
    id_health?: SortOrder
    im_health?: im_healthOrderByWithRelationInput
    im_health_goal_daily?: im_health_goal_dailyOrderByRelationAggregateInput
  }

  export type im_health_goalWhereUniqueInput = Prisma.AtLeast<{
    id_health_goal?: number
    AND?: im_health_goalWhereInput | im_health_goalWhereInput[]
    OR?: im_health_goalWhereInput[]
    NOT?: im_health_goalWhereInput | im_health_goalWhereInput[]
    health_goal_steps?: IntFilter<"im_health_goal"> | number
    health_goal_weight?: IntFilter<"im_health_goal"> | number
    health_goal_sleep?: IntFilter<"im_health_goal"> | number
    health_goal_water?: IntFilter<"im_health_goal"> | number
    id_health?: IntFilter<"im_health_goal"> | number
    im_health?: XOR<Im_healthRelationFilter, im_healthWhereInput>
    im_health_goal_daily?: Im_health_goal_dailyListRelationFilter
  }, "id_health_goal">

  export type im_health_goalOrderByWithAggregationInput = {
    id_health_goal?: SortOrder
    health_goal_steps?: SortOrder
    health_goal_weight?: SortOrder
    health_goal_sleep?: SortOrder
    health_goal_water?: SortOrder
    id_health?: SortOrder
    _count?: im_health_goalCountOrderByAggregateInput
    _avg?: im_health_goalAvgOrderByAggregateInput
    _max?: im_health_goalMaxOrderByAggregateInput
    _min?: im_health_goalMinOrderByAggregateInput
    _sum?: im_health_goalSumOrderByAggregateInput
  }

  export type im_health_goalScalarWhereWithAggregatesInput = {
    AND?: im_health_goalScalarWhereWithAggregatesInput | im_health_goalScalarWhereWithAggregatesInput[]
    OR?: im_health_goalScalarWhereWithAggregatesInput[]
    NOT?: im_health_goalScalarWhereWithAggregatesInput | im_health_goalScalarWhereWithAggregatesInput[]
    id_health_goal?: IntWithAggregatesFilter<"im_health_goal"> | number
    health_goal_steps?: IntWithAggregatesFilter<"im_health_goal"> | number
    health_goal_weight?: IntWithAggregatesFilter<"im_health_goal"> | number
    health_goal_sleep?: IntWithAggregatesFilter<"im_health_goal"> | number
    health_goal_water?: IntWithAggregatesFilter<"im_health_goal"> | number
    id_health?: IntWithAggregatesFilter<"im_health_goal"> | number
  }

  export type im_health_goal_dailyWhereInput = {
    AND?: im_health_goal_dailyWhereInput | im_health_goal_dailyWhereInput[]
    OR?: im_health_goal_dailyWhereInput[]
    NOT?: im_health_goal_dailyWhereInput | im_health_goal_dailyWhereInput[]
    id_health_goal_daily?: IntFilter<"im_health_goal_daily"> | number
    health_goal_daily_date?: DateTimeFilter<"im_health_goal_daily"> | Date | string
    health_goal_daily_steps?: IntFilter<"im_health_goal_daily"> | number
    health_goal_daily_weight?: IntFilter<"im_health_goal_daily"> | number
    health_goal_daily_sleep?: IntFilter<"im_health_goal_daily"> | number
    health_goal_daily_water?: IntFilter<"im_health_goal_daily"> | number
    id_health_goal?: IntFilter<"im_health_goal_daily"> | number
    im_health_goal?: XOR<Im_health_goalRelationFilter, im_health_goalWhereInput>
    im_health_goal_daily_history?: Im_health_goal_daily_historyListRelationFilter
  }

  export type im_health_goal_dailyOrderByWithRelationInput = {
    id_health_goal_daily?: SortOrder
    health_goal_daily_date?: SortOrder
    health_goal_daily_steps?: SortOrder
    health_goal_daily_weight?: SortOrder
    health_goal_daily_sleep?: SortOrder
    health_goal_daily_water?: SortOrder
    id_health_goal?: SortOrder
    im_health_goal?: im_health_goalOrderByWithRelationInput
    im_health_goal_daily_history?: im_health_goal_daily_historyOrderByRelationAggregateInput
  }

  export type im_health_goal_dailyWhereUniqueInput = Prisma.AtLeast<{
    id_health_goal_daily?: number
    AND?: im_health_goal_dailyWhereInput | im_health_goal_dailyWhereInput[]
    OR?: im_health_goal_dailyWhereInput[]
    NOT?: im_health_goal_dailyWhereInput | im_health_goal_dailyWhereInput[]
    health_goal_daily_date?: DateTimeFilter<"im_health_goal_daily"> | Date | string
    health_goal_daily_steps?: IntFilter<"im_health_goal_daily"> | number
    health_goal_daily_weight?: IntFilter<"im_health_goal_daily"> | number
    health_goal_daily_sleep?: IntFilter<"im_health_goal_daily"> | number
    health_goal_daily_water?: IntFilter<"im_health_goal_daily"> | number
    id_health_goal?: IntFilter<"im_health_goal_daily"> | number
    im_health_goal?: XOR<Im_health_goalRelationFilter, im_health_goalWhereInput>
    im_health_goal_daily_history?: Im_health_goal_daily_historyListRelationFilter
  }, "id_health_goal_daily">

  export type im_health_goal_dailyOrderByWithAggregationInput = {
    id_health_goal_daily?: SortOrder
    health_goal_daily_date?: SortOrder
    health_goal_daily_steps?: SortOrder
    health_goal_daily_weight?: SortOrder
    health_goal_daily_sleep?: SortOrder
    health_goal_daily_water?: SortOrder
    id_health_goal?: SortOrder
    _count?: im_health_goal_dailyCountOrderByAggregateInput
    _avg?: im_health_goal_dailyAvgOrderByAggregateInput
    _max?: im_health_goal_dailyMaxOrderByAggregateInput
    _min?: im_health_goal_dailyMinOrderByAggregateInput
    _sum?: im_health_goal_dailySumOrderByAggregateInput
  }

  export type im_health_goal_dailyScalarWhereWithAggregatesInput = {
    AND?: im_health_goal_dailyScalarWhereWithAggregatesInput | im_health_goal_dailyScalarWhereWithAggregatesInput[]
    OR?: im_health_goal_dailyScalarWhereWithAggregatesInput[]
    NOT?: im_health_goal_dailyScalarWhereWithAggregatesInput | im_health_goal_dailyScalarWhereWithAggregatesInput[]
    id_health_goal_daily?: IntWithAggregatesFilter<"im_health_goal_daily"> | number
    health_goal_daily_date?: DateTimeWithAggregatesFilter<"im_health_goal_daily"> | Date | string
    health_goal_daily_steps?: IntWithAggregatesFilter<"im_health_goal_daily"> | number
    health_goal_daily_weight?: IntWithAggregatesFilter<"im_health_goal_daily"> | number
    health_goal_daily_sleep?: IntWithAggregatesFilter<"im_health_goal_daily"> | number
    health_goal_daily_water?: IntWithAggregatesFilter<"im_health_goal_daily"> | number
    id_health_goal?: IntWithAggregatesFilter<"im_health_goal_daily"> | number
  }

  export type im_health_goal_daily_historyWhereInput = {
    AND?: im_health_goal_daily_historyWhereInput | im_health_goal_daily_historyWhereInput[]
    OR?: im_health_goal_daily_historyWhereInput[]
    NOT?: im_health_goal_daily_historyWhereInput | im_health_goal_daily_historyWhereInput[]
    id_health_goal_daily_history?: IntFilter<"im_health_goal_daily_history"> | number
    health_goal_daily_history_date?: DateTimeFilter<"im_health_goal_daily_history"> | Date | string
    id_health_goal_daily?: IntFilter<"im_health_goal_daily_history"> | number
    im_health_goal_daily?: XOR<Im_health_goal_dailyRelationFilter, im_health_goal_dailyWhereInput>
  }

  export type im_health_goal_daily_historyOrderByWithRelationInput = {
    id_health_goal_daily_history?: SortOrder
    health_goal_daily_history_date?: SortOrder
    id_health_goal_daily?: SortOrder
    im_health_goal_daily?: im_health_goal_dailyOrderByWithRelationInput
  }

  export type im_health_goal_daily_historyWhereUniqueInput = Prisma.AtLeast<{
    id_health_goal_daily_history?: number
    AND?: im_health_goal_daily_historyWhereInput | im_health_goal_daily_historyWhereInput[]
    OR?: im_health_goal_daily_historyWhereInput[]
    NOT?: im_health_goal_daily_historyWhereInput | im_health_goal_daily_historyWhereInput[]
    health_goal_daily_history_date?: DateTimeFilter<"im_health_goal_daily_history"> | Date | string
    id_health_goal_daily?: IntFilter<"im_health_goal_daily_history"> | number
    im_health_goal_daily?: XOR<Im_health_goal_dailyRelationFilter, im_health_goal_dailyWhereInput>
  }, "id_health_goal_daily_history">

  export type im_health_goal_daily_historyOrderByWithAggregationInput = {
    id_health_goal_daily_history?: SortOrder
    health_goal_daily_history_date?: SortOrder
    id_health_goal_daily?: SortOrder
    _count?: im_health_goal_daily_historyCountOrderByAggregateInput
    _avg?: im_health_goal_daily_historyAvgOrderByAggregateInput
    _max?: im_health_goal_daily_historyMaxOrderByAggregateInput
    _min?: im_health_goal_daily_historyMinOrderByAggregateInput
    _sum?: im_health_goal_daily_historySumOrderByAggregateInput
  }

  export type im_health_goal_daily_historyScalarWhereWithAggregatesInput = {
    AND?: im_health_goal_daily_historyScalarWhereWithAggregatesInput | im_health_goal_daily_historyScalarWhereWithAggregatesInput[]
    OR?: im_health_goal_daily_historyScalarWhereWithAggregatesInput[]
    NOT?: im_health_goal_daily_historyScalarWhereWithAggregatesInput | im_health_goal_daily_historyScalarWhereWithAggregatesInput[]
    id_health_goal_daily_history?: IntWithAggregatesFilter<"im_health_goal_daily_history"> | number
    health_goal_daily_history_date?: DateTimeWithAggregatesFilter<"im_health_goal_daily_history"> | Date | string
    id_health_goal_daily?: IntWithAggregatesFilter<"im_health_goal_daily_history"> | number
  }

  export type im_mealWhereInput = {
    AND?: im_mealWhereInput | im_mealWhereInput[]
    OR?: im_mealWhereInput[]
    NOT?: im_mealWhereInput | im_mealWhereInput[]
    id_meal?: IntFilter<"im_meal"> | number
    meal_name?: StringFilter<"im_meal"> | string
    meal_quantity?: IntFilter<"im_meal"> | number
    meal_calories?: IntFilter<"im_meal"> | number
    meal_carbs?: IntFilter<"im_meal"> | number
    meal_prots?: IntFilter<"im_meal"> | number
    meal_fats?: IntFilter<"im_meal"> | number
    meal_description?: StringFilter<"im_meal"> | string
    meal_length?: IntFilter<"im_meal"> | number
    meal_image?: StringFilter<"im_meal"> | string
    meal_difficulty?: IntFilter<"im_meal"> | number
    meal_season?: IntFilter<"im_meal"> | number
    id_nutrition?: IntFilter<"im_meal"> | number
    im_nutrition?: XOR<Im_nutritionRelationFilter, im_nutritionWhereInput>
    im_recipe?: Im_recipeListRelationFilter
  }

  export type im_mealOrderByWithRelationInput = {
    id_meal?: SortOrder
    meal_name?: SortOrder
    meal_quantity?: SortOrder
    meal_calories?: SortOrder
    meal_carbs?: SortOrder
    meal_prots?: SortOrder
    meal_fats?: SortOrder
    meal_description?: SortOrder
    meal_length?: SortOrder
    meal_image?: SortOrder
    meal_difficulty?: SortOrder
    meal_season?: SortOrder
    id_nutrition?: SortOrder
    im_nutrition?: im_nutritionOrderByWithRelationInput
    im_recipe?: im_recipeOrderByRelationAggregateInput
  }

  export type im_mealWhereUniqueInput = Prisma.AtLeast<{
    id_meal?: number
    AND?: im_mealWhereInput | im_mealWhereInput[]
    OR?: im_mealWhereInput[]
    NOT?: im_mealWhereInput | im_mealWhereInput[]
    meal_name?: StringFilter<"im_meal"> | string
    meal_quantity?: IntFilter<"im_meal"> | number
    meal_calories?: IntFilter<"im_meal"> | number
    meal_carbs?: IntFilter<"im_meal"> | number
    meal_prots?: IntFilter<"im_meal"> | number
    meal_fats?: IntFilter<"im_meal"> | number
    meal_description?: StringFilter<"im_meal"> | string
    meal_length?: IntFilter<"im_meal"> | number
    meal_image?: StringFilter<"im_meal"> | string
    meal_difficulty?: IntFilter<"im_meal"> | number
    meal_season?: IntFilter<"im_meal"> | number
    id_nutrition?: IntFilter<"im_meal"> | number
    im_nutrition?: XOR<Im_nutritionRelationFilter, im_nutritionWhereInput>
    im_recipe?: Im_recipeListRelationFilter
  }, "id_meal">

  export type im_mealOrderByWithAggregationInput = {
    id_meal?: SortOrder
    meal_name?: SortOrder
    meal_quantity?: SortOrder
    meal_calories?: SortOrder
    meal_carbs?: SortOrder
    meal_prots?: SortOrder
    meal_fats?: SortOrder
    meal_description?: SortOrder
    meal_length?: SortOrder
    meal_image?: SortOrder
    meal_difficulty?: SortOrder
    meal_season?: SortOrder
    id_nutrition?: SortOrder
    _count?: im_mealCountOrderByAggregateInput
    _avg?: im_mealAvgOrderByAggregateInput
    _max?: im_mealMaxOrderByAggregateInput
    _min?: im_mealMinOrderByAggregateInput
    _sum?: im_mealSumOrderByAggregateInput
  }

  export type im_mealScalarWhereWithAggregatesInput = {
    AND?: im_mealScalarWhereWithAggregatesInput | im_mealScalarWhereWithAggregatesInput[]
    OR?: im_mealScalarWhereWithAggregatesInput[]
    NOT?: im_mealScalarWhereWithAggregatesInput | im_mealScalarWhereWithAggregatesInput[]
    id_meal?: IntWithAggregatesFilter<"im_meal"> | number
    meal_name?: StringWithAggregatesFilter<"im_meal"> | string
    meal_quantity?: IntWithAggregatesFilter<"im_meal"> | number
    meal_calories?: IntWithAggregatesFilter<"im_meal"> | number
    meal_carbs?: IntWithAggregatesFilter<"im_meal"> | number
    meal_prots?: IntWithAggregatesFilter<"im_meal"> | number
    meal_fats?: IntWithAggregatesFilter<"im_meal"> | number
    meal_description?: StringWithAggregatesFilter<"im_meal"> | string
    meal_length?: IntWithAggregatesFilter<"im_meal"> | number
    meal_image?: StringWithAggregatesFilter<"im_meal"> | string
    meal_difficulty?: IntWithAggregatesFilter<"im_meal"> | number
    meal_season?: IntWithAggregatesFilter<"im_meal"> | number
    id_nutrition?: IntWithAggregatesFilter<"im_meal"> | number
  }

  export type im_nutritionWhereInput = {
    AND?: im_nutritionWhereInput | im_nutritionWhereInput[]
    OR?: im_nutritionWhereInput[]
    NOT?: im_nutritionWhereInput | im_nutritionWhereInput[]
    id_nutrition?: IntFilter<"im_nutrition"> | number
    nutrition_goal?: IntFilter<"im_nutrition"> | number
    nutrition_goal_calories?: IntFilter<"im_nutrition"> | number
    nutrition_goal_carbs?: IntFilter<"im_nutrition"> | number
    nutrition_goal_prots?: IntFilter<"im_nutrition"> | number
    nutrition_goal_fats?: IntFilter<"im_nutrition"> | number
    id_user?: IntFilter<"im_nutrition"> | number
    im_meal?: Im_mealListRelationFilter
    im_user?: XOR<Im_userRelationFilter, im_userWhereInput>
  }

  export type im_nutritionOrderByWithRelationInput = {
    id_nutrition?: SortOrder
    nutrition_goal?: SortOrder
    nutrition_goal_calories?: SortOrder
    nutrition_goal_carbs?: SortOrder
    nutrition_goal_prots?: SortOrder
    nutrition_goal_fats?: SortOrder
    id_user?: SortOrder
    im_meal?: im_mealOrderByRelationAggregateInput
    im_user?: im_userOrderByWithRelationInput
  }

  export type im_nutritionWhereUniqueInput = Prisma.AtLeast<{
    id_nutrition?: number
    AND?: im_nutritionWhereInput | im_nutritionWhereInput[]
    OR?: im_nutritionWhereInput[]
    NOT?: im_nutritionWhereInput | im_nutritionWhereInput[]
    nutrition_goal?: IntFilter<"im_nutrition"> | number
    nutrition_goal_calories?: IntFilter<"im_nutrition"> | number
    nutrition_goal_carbs?: IntFilter<"im_nutrition"> | number
    nutrition_goal_prots?: IntFilter<"im_nutrition"> | number
    nutrition_goal_fats?: IntFilter<"im_nutrition"> | number
    id_user?: IntFilter<"im_nutrition"> | number
    im_meal?: Im_mealListRelationFilter
    im_user?: XOR<Im_userRelationFilter, im_userWhereInput>
  }, "id_nutrition">

  export type im_nutritionOrderByWithAggregationInput = {
    id_nutrition?: SortOrder
    nutrition_goal?: SortOrder
    nutrition_goal_calories?: SortOrder
    nutrition_goal_carbs?: SortOrder
    nutrition_goal_prots?: SortOrder
    nutrition_goal_fats?: SortOrder
    id_user?: SortOrder
    _count?: im_nutritionCountOrderByAggregateInput
    _avg?: im_nutritionAvgOrderByAggregateInput
    _max?: im_nutritionMaxOrderByAggregateInput
    _min?: im_nutritionMinOrderByAggregateInput
    _sum?: im_nutritionSumOrderByAggregateInput
  }

  export type im_nutritionScalarWhereWithAggregatesInput = {
    AND?: im_nutritionScalarWhereWithAggregatesInput | im_nutritionScalarWhereWithAggregatesInput[]
    OR?: im_nutritionScalarWhereWithAggregatesInput[]
    NOT?: im_nutritionScalarWhereWithAggregatesInput | im_nutritionScalarWhereWithAggregatesInput[]
    id_nutrition?: IntWithAggregatesFilter<"im_nutrition"> | number
    nutrition_goal?: IntWithAggregatesFilter<"im_nutrition"> | number
    nutrition_goal_calories?: IntWithAggregatesFilter<"im_nutrition"> | number
    nutrition_goal_carbs?: IntWithAggregatesFilter<"im_nutrition"> | number
    nutrition_goal_prots?: IntWithAggregatesFilter<"im_nutrition"> | number
    nutrition_goal_fats?: IntWithAggregatesFilter<"im_nutrition"> | number
    id_user?: IntWithAggregatesFilter<"im_nutrition"> | number
  }

  export type im_recipeWhereInput = {
    AND?: im_recipeWhereInput | im_recipeWhereInput[]
    OR?: im_recipeWhereInput[]
    NOT?: im_recipeWhereInput | im_recipeWhereInput[]
    id_recipe?: IntFilter<"im_recipe"> | number
    id_meal?: IntFilter<"im_recipe"> | number
    id_food?: IntFilter<"im_recipe"> | number
    im_meal?: XOR<Im_mealRelationFilter, im_mealWhereInput>
    im_food?: XOR<Im_foodRelationFilter, im_foodWhereInput>
  }

  export type im_recipeOrderByWithRelationInput = {
    id_recipe?: SortOrder
    id_meal?: SortOrder
    id_food?: SortOrder
    im_meal?: im_mealOrderByWithRelationInput
    im_food?: im_foodOrderByWithRelationInput
  }

  export type im_recipeWhereUniqueInput = Prisma.AtLeast<{
    id_recipe?: number
    AND?: im_recipeWhereInput | im_recipeWhereInput[]
    OR?: im_recipeWhereInput[]
    NOT?: im_recipeWhereInput | im_recipeWhereInput[]
    id_meal?: IntFilter<"im_recipe"> | number
    id_food?: IntFilter<"im_recipe"> | number
    im_meal?: XOR<Im_mealRelationFilter, im_mealWhereInput>
    im_food?: XOR<Im_foodRelationFilter, im_foodWhereInput>
  }, "id_recipe">

  export type im_recipeOrderByWithAggregationInput = {
    id_recipe?: SortOrder
    id_meal?: SortOrder
    id_food?: SortOrder
    _count?: im_recipeCountOrderByAggregateInput
    _avg?: im_recipeAvgOrderByAggregateInput
    _max?: im_recipeMaxOrderByAggregateInput
    _min?: im_recipeMinOrderByAggregateInput
    _sum?: im_recipeSumOrderByAggregateInput
  }

  export type im_recipeScalarWhereWithAggregatesInput = {
    AND?: im_recipeScalarWhereWithAggregatesInput | im_recipeScalarWhereWithAggregatesInput[]
    OR?: im_recipeScalarWhereWithAggregatesInput[]
    NOT?: im_recipeScalarWhereWithAggregatesInput | im_recipeScalarWhereWithAggregatesInput[]
    id_recipe?: IntWithAggregatesFilter<"im_recipe"> | number
    id_meal?: IntWithAggregatesFilter<"im_recipe"> | number
    id_food?: IntWithAggregatesFilter<"im_recipe"> | number
  }

  export type im_trainingWhereInput = {
    AND?: im_trainingWhereInput | im_trainingWhereInput[]
    OR?: im_trainingWhereInput[]
    NOT?: im_trainingWhereInput | im_trainingWhereInput[]
    id_training?: IntFilter<"im_training"> | number
    training_goal?: StringFilter<"im_training"> | string
    id_user?: IntFilter<"im_training"> | number
    im_user?: XOR<Im_userRelationFilter, im_userWhereInput>
    im_workout?: Im_workoutListRelationFilter
  }

  export type im_trainingOrderByWithRelationInput = {
    id_training?: SortOrder
    training_goal?: SortOrder
    id_user?: SortOrder
    im_user?: im_userOrderByWithRelationInput
    im_workout?: im_workoutOrderByRelationAggregateInput
  }

  export type im_trainingWhereUniqueInput = Prisma.AtLeast<{
    id_training?: number
    AND?: im_trainingWhereInput | im_trainingWhereInput[]
    OR?: im_trainingWhereInput[]
    NOT?: im_trainingWhereInput | im_trainingWhereInput[]
    training_goal?: StringFilter<"im_training"> | string
    id_user?: IntFilter<"im_training"> | number
    im_user?: XOR<Im_userRelationFilter, im_userWhereInput>
    im_workout?: Im_workoutListRelationFilter
  }, "id_training">

  export type im_trainingOrderByWithAggregationInput = {
    id_training?: SortOrder
    training_goal?: SortOrder
    id_user?: SortOrder
    _count?: im_trainingCountOrderByAggregateInput
    _avg?: im_trainingAvgOrderByAggregateInput
    _max?: im_trainingMaxOrderByAggregateInput
    _min?: im_trainingMinOrderByAggregateInput
    _sum?: im_trainingSumOrderByAggregateInput
  }

  export type im_trainingScalarWhereWithAggregatesInput = {
    AND?: im_trainingScalarWhereWithAggregatesInput | im_trainingScalarWhereWithAggregatesInput[]
    OR?: im_trainingScalarWhereWithAggregatesInput[]
    NOT?: im_trainingScalarWhereWithAggregatesInput | im_trainingScalarWhereWithAggregatesInput[]
    id_training?: IntWithAggregatesFilter<"im_training"> | number
    training_goal?: StringWithAggregatesFilter<"im_training"> | string
    id_user?: IntWithAggregatesFilter<"im_training"> | number
  }

  export type im_undesirable_foodWhereInput = {
    AND?: im_undesirable_foodWhereInput | im_undesirable_foodWhereInput[]
    OR?: im_undesirable_foodWhereInput[]
    NOT?: im_undesirable_foodWhereInput | im_undesirable_foodWhereInput[]
    id_undesirable_food?: IntFilter<"im_undesirable_food"> | number
    id_food?: IntFilter<"im_undesirable_food"> | number
    id_user?: IntFilter<"im_undesirable_food"> | number
    im_user?: XOR<Im_userRelationFilter, im_userWhereInput>
    im_food?: XOR<Im_foodRelationFilter, im_foodWhereInput>
  }

  export type im_undesirable_foodOrderByWithRelationInput = {
    id_undesirable_food?: SortOrder
    id_food?: SortOrder
    id_user?: SortOrder
    im_user?: im_userOrderByWithRelationInput
    im_food?: im_foodOrderByWithRelationInput
  }

  export type im_undesirable_foodWhereUniqueInput = Prisma.AtLeast<{
    id_undesirable_food?: number
    AND?: im_undesirable_foodWhereInput | im_undesirable_foodWhereInput[]
    OR?: im_undesirable_foodWhereInput[]
    NOT?: im_undesirable_foodWhereInput | im_undesirable_foodWhereInput[]
    id_food?: IntFilter<"im_undesirable_food"> | number
    id_user?: IntFilter<"im_undesirable_food"> | number
    im_user?: XOR<Im_userRelationFilter, im_userWhereInput>
    im_food?: XOR<Im_foodRelationFilter, im_foodWhereInput>
  }, "id_undesirable_food">

  export type im_undesirable_foodOrderByWithAggregationInput = {
    id_undesirable_food?: SortOrder
    id_food?: SortOrder
    id_user?: SortOrder
    _count?: im_undesirable_foodCountOrderByAggregateInput
    _avg?: im_undesirable_foodAvgOrderByAggregateInput
    _max?: im_undesirable_foodMaxOrderByAggregateInput
    _min?: im_undesirable_foodMinOrderByAggregateInput
    _sum?: im_undesirable_foodSumOrderByAggregateInput
  }

  export type im_undesirable_foodScalarWhereWithAggregatesInput = {
    AND?: im_undesirable_foodScalarWhereWithAggregatesInput | im_undesirable_foodScalarWhereWithAggregatesInput[]
    OR?: im_undesirable_foodScalarWhereWithAggregatesInput[]
    NOT?: im_undesirable_foodScalarWhereWithAggregatesInput | im_undesirable_foodScalarWhereWithAggregatesInput[]
    id_undesirable_food?: IntWithAggregatesFilter<"im_undesirable_food"> | number
    id_food?: IntWithAggregatesFilter<"im_undesirable_food"> | number
    id_user?: IntWithAggregatesFilter<"im_undesirable_food"> | number
  }

  export type im_userWhereInput = {
    AND?: im_userWhereInput | im_userWhereInput[]
    OR?: im_userWhereInput[]
    NOT?: im_userWhereInput | im_userWhereInput[]
    id_user?: IntFilter<"im_user"> | number
    user_firstname?: StringFilter<"im_user"> | string
    user_name?: StringFilter<"im_user"> | string
    user_mail?: StringFilter<"im_user"> | string
    user_password?: StringFilter<"im_user"> | string
    user_birth_date?: DateTimeFilter<"im_user"> | Date | string
    user_inscription_date?: DateTimeFilter<"im_user"> | Date | string
    user_gender?: IntFilter<"im_user"> | number
    user_height?: IntFilter<"im_user"> | number
    user_weight?: IntFilter<"im_user"> | number
    user_age?: IntFilter<"im_user"> | number
    user_training_level?: IntFilter<"im_user"> | number
    user_nutrition_diet?: IntFilter<"im_user"> | number
    im_health?: Im_healthListRelationFilter
    im_nutrition?: Im_nutritionListRelationFilter
    im_training?: Im_trainingListRelationFilter
    im_undesirable_food?: Im_undesirable_foodListRelationFilter
  }

  export type im_userOrderByWithRelationInput = {
    id_user?: SortOrder
    user_firstname?: SortOrder
    user_name?: SortOrder
    user_mail?: SortOrder
    user_password?: SortOrder
    user_birth_date?: SortOrder
    user_inscription_date?: SortOrder
    user_gender?: SortOrder
    user_height?: SortOrder
    user_weight?: SortOrder
    user_age?: SortOrder
    user_training_level?: SortOrder
    user_nutrition_diet?: SortOrder
    im_health?: im_healthOrderByRelationAggregateInput
    im_nutrition?: im_nutritionOrderByRelationAggregateInput
    im_training?: im_trainingOrderByRelationAggregateInput
    im_undesirable_food?: im_undesirable_foodOrderByRelationAggregateInput
  }

  export type im_userWhereUniqueInput = Prisma.AtLeast<{
    id_user?: number
    AND?: im_userWhereInput | im_userWhereInput[]
    OR?: im_userWhereInput[]
    NOT?: im_userWhereInput | im_userWhereInput[]
    user_firstname?: StringFilter<"im_user"> | string
    user_name?: StringFilter<"im_user"> | string
    user_mail?: StringFilter<"im_user"> | string
    user_password?: StringFilter<"im_user"> | string
    user_birth_date?: DateTimeFilter<"im_user"> | Date | string
    user_inscription_date?: DateTimeFilter<"im_user"> | Date | string
    user_gender?: IntFilter<"im_user"> | number
    user_height?: IntFilter<"im_user"> | number
    user_weight?: IntFilter<"im_user"> | number
    user_age?: IntFilter<"im_user"> | number
    user_training_level?: IntFilter<"im_user"> | number
    user_nutrition_diet?: IntFilter<"im_user"> | number
    im_health?: Im_healthListRelationFilter
    im_nutrition?: Im_nutritionListRelationFilter
    im_training?: Im_trainingListRelationFilter
    im_undesirable_food?: Im_undesirable_foodListRelationFilter
  }, "id_user">

  export type im_userOrderByWithAggregationInput = {
    id_user?: SortOrder
    user_firstname?: SortOrder
    user_name?: SortOrder
    user_mail?: SortOrder
    user_password?: SortOrder
    user_birth_date?: SortOrder
    user_inscription_date?: SortOrder
    user_gender?: SortOrder
    user_height?: SortOrder
    user_weight?: SortOrder
    user_age?: SortOrder
    user_training_level?: SortOrder
    user_nutrition_diet?: SortOrder
    _count?: im_userCountOrderByAggregateInput
    _avg?: im_userAvgOrderByAggregateInput
    _max?: im_userMaxOrderByAggregateInput
    _min?: im_userMinOrderByAggregateInput
    _sum?: im_userSumOrderByAggregateInput
  }

  export type im_userScalarWhereWithAggregatesInput = {
    AND?: im_userScalarWhereWithAggregatesInput | im_userScalarWhereWithAggregatesInput[]
    OR?: im_userScalarWhereWithAggregatesInput[]
    NOT?: im_userScalarWhereWithAggregatesInput | im_userScalarWhereWithAggregatesInput[]
    id_user?: IntWithAggregatesFilter<"im_user"> | number
    user_firstname?: StringWithAggregatesFilter<"im_user"> | string
    user_name?: StringWithAggregatesFilter<"im_user"> | string
    user_mail?: StringWithAggregatesFilter<"im_user"> | string
    user_password?: StringWithAggregatesFilter<"im_user"> | string
    user_birth_date?: DateTimeWithAggregatesFilter<"im_user"> | Date | string
    user_inscription_date?: DateTimeWithAggregatesFilter<"im_user"> | Date | string
    user_gender?: IntWithAggregatesFilter<"im_user"> | number
    user_height?: IntWithAggregatesFilter<"im_user"> | number
    user_weight?: IntWithAggregatesFilter<"im_user"> | number
    user_age?: IntWithAggregatesFilter<"im_user"> | number
    user_training_level?: IntWithAggregatesFilter<"im_user"> | number
    user_nutrition_diet?: IntWithAggregatesFilter<"im_user"> | number
  }

  export type im_workoutWhereInput = {
    AND?: im_workoutWhereInput | im_workoutWhereInput[]
    OR?: im_workoutWhereInput[]
    NOT?: im_workoutWhereInput | im_workoutWhereInput[]
    id_workout?: IntFilter<"im_workout"> | number
    workout_point?: IntFilter<"im_workout"> | number
    workout_name?: StringFilter<"im_workout"> | string
    workout_comment?: StringFilter<"im_workout"> | string
    id_training?: IntFilter<"im_workout"> | number
    im_exercise?: Im_exerciseListRelationFilter
    im_training?: XOR<Im_trainingRelationFilter, im_trainingWhereInput>
  }

  export type im_workoutOrderByWithRelationInput = {
    id_workout?: SortOrder
    workout_point?: SortOrder
    workout_name?: SortOrder
    workout_comment?: SortOrder
    id_training?: SortOrder
    im_exercise?: im_exerciseOrderByRelationAggregateInput
    im_training?: im_trainingOrderByWithRelationInput
  }

  export type im_workoutWhereUniqueInput = Prisma.AtLeast<{
    id_workout?: number
    AND?: im_workoutWhereInput | im_workoutWhereInput[]
    OR?: im_workoutWhereInput[]
    NOT?: im_workoutWhereInput | im_workoutWhereInput[]
    workout_point?: IntFilter<"im_workout"> | number
    workout_name?: StringFilter<"im_workout"> | string
    workout_comment?: StringFilter<"im_workout"> | string
    id_training?: IntFilter<"im_workout"> | number
    im_exercise?: Im_exerciseListRelationFilter
    im_training?: XOR<Im_trainingRelationFilter, im_trainingWhereInput>
  }, "id_workout">

  export type im_workoutOrderByWithAggregationInput = {
    id_workout?: SortOrder
    workout_point?: SortOrder
    workout_name?: SortOrder
    workout_comment?: SortOrder
    id_training?: SortOrder
    _count?: im_workoutCountOrderByAggregateInput
    _avg?: im_workoutAvgOrderByAggregateInput
    _max?: im_workoutMaxOrderByAggregateInput
    _min?: im_workoutMinOrderByAggregateInput
    _sum?: im_workoutSumOrderByAggregateInput
  }

  export type im_workoutScalarWhereWithAggregatesInput = {
    AND?: im_workoutScalarWhereWithAggregatesInput | im_workoutScalarWhereWithAggregatesInput[]
    OR?: im_workoutScalarWhereWithAggregatesInput[]
    NOT?: im_workoutScalarWhereWithAggregatesInput | im_workoutScalarWhereWithAggregatesInput[]
    id_workout?: IntWithAggregatesFilter<"im_workout"> | number
    workout_point?: IntWithAggregatesFilter<"im_workout"> | number
    workout_name?: StringWithAggregatesFilter<"im_workout"> | string
    workout_comment?: StringWithAggregatesFilter<"im_workout"> | string
    id_training?: IntWithAggregatesFilter<"im_workout"> | number
  }

  export type im_exerciseCreateInput = {
    exercise_name: string
    exercise_type: string
    exercise_rest_time: number
    exercise_reps: number
    exercise_series: number
    exercise_description: string
    im_workout: im_workoutCreateNestedOneWithoutIm_exerciseInput
    im_exercise_history?: im_exercise_historyCreateNestedManyWithoutIm_exerciseInput
  }

  export type im_exerciseUncheckedCreateInput = {
    id_exercise?: number
    exercise_name: string
    exercise_type: string
    exercise_rest_time: number
    exercise_reps: number
    exercise_series: number
    exercise_description: string
    id_workout: number
    im_exercise_history?: im_exercise_historyUncheckedCreateNestedManyWithoutIm_exerciseInput
  }

  export type im_exerciseUpdateInput = {
    exercise_name?: StringFieldUpdateOperationsInput | string
    exercise_type?: StringFieldUpdateOperationsInput | string
    exercise_rest_time?: IntFieldUpdateOperationsInput | number
    exercise_reps?: IntFieldUpdateOperationsInput | number
    exercise_series?: IntFieldUpdateOperationsInput | number
    exercise_description?: StringFieldUpdateOperationsInput | string
    im_workout?: im_workoutUpdateOneRequiredWithoutIm_exerciseNestedInput
    im_exercise_history?: im_exercise_historyUpdateManyWithoutIm_exerciseNestedInput
  }

  export type im_exerciseUncheckedUpdateInput = {
    id_exercise?: IntFieldUpdateOperationsInput | number
    exercise_name?: StringFieldUpdateOperationsInput | string
    exercise_type?: StringFieldUpdateOperationsInput | string
    exercise_rest_time?: IntFieldUpdateOperationsInput | number
    exercise_reps?: IntFieldUpdateOperationsInput | number
    exercise_series?: IntFieldUpdateOperationsInput | number
    exercise_description?: StringFieldUpdateOperationsInput | string
    id_workout?: IntFieldUpdateOperationsInput | number
    im_exercise_history?: im_exercise_historyUncheckedUpdateManyWithoutIm_exerciseNestedInput
  }

  export type im_exerciseCreateManyInput = {
    id_exercise?: number
    exercise_name: string
    exercise_type: string
    exercise_rest_time: number
    exercise_reps: number
    exercise_series: number
    exercise_description: string
    id_workout: number
  }

  export type im_exerciseUpdateManyMutationInput = {
    exercise_name?: StringFieldUpdateOperationsInput | string
    exercise_type?: StringFieldUpdateOperationsInput | string
    exercise_rest_time?: IntFieldUpdateOperationsInput | number
    exercise_reps?: IntFieldUpdateOperationsInput | number
    exercise_series?: IntFieldUpdateOperationsInput | number
    exercise_description?: StringFieldUpdateOperationsInput | string
  }

  export type im_exerciseUncheckedUpdateManyInput = {
    id_exercise?: IntFieldUpdateOperationsInput | number
    exercise_name?: StringFieldUpdateOperationsInput | string
    exercise_type?: StringFieldUpdateOperationsInput | string
    exercise_rest_time?: IntFieldUpdateOperationsInput | number
    exercise_reps?: IntFieldUpdateOperationsInput | number
    exercise_series?: IntFieldUpdateOperationsInput | number
    exercise_description?: StringFieldUpdateOperationsInput | string
    id_workout?: IntFieldUpdateOperationsInput | number
  }

  export type im_exercise_historyCreateInput = {
    exercise_history_date: Date | string
    im_exercise: im_exerciseCreateNestedOneWithoutIm_exercise_historyInput
  }

  export type im_exercise_historyUncheckedCreateInput = {
    id_exercise_history?: number
    exercise_history_date: Date | string
    id_exercise: number
  }

  export type im_exercise_historyUpdateInput = {
    exercise_history_date?: DateTimeFieldUpdateOperationsInput | Date | string
    im_exercise?: im_exerciseUpdateOneRequiredWithoutIm_exercise_historyNestedInput
  }

  export type im_exercise_historyUncheckedUpdateInput = {
    id_exercise_history?: IntFieldUpdateOperationsInput | number
    exercise_history_date?: DateTimeFieldUpdateOperationsInput | Date | string
    id_exercise?: IntFieldUpdateOperationsInput | number
  }

  export type im_exercise_historyCreateManyInput = {
    id_exercise_history?: number
    exercise_history_date: Date | string
    id_exercise: number
  }

  export type im_exercise_historyUpdateManyMutationInput = {
    exercise_history_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type im_exercise_historyUncheckedUpdateManyInput = {
    id_exercise_history?: IntFieldUpdateOperationsInput | number
    exercise_history_date?: DateTimeFieldUpdateOperationsInput | Date | string
    id_exercise?: IntFieldUpdateOperationsInput | number
  }

  export type im_foodCreateInput = {
    food_name: string
    food_type: string
    food_calories: number
    food_carbs: number
    food_prots: number
    food_fats: number
    im_recipe?: im_recipeCreateNestedManyWithoutIm_foodInput
    im_undesirable_food?: im_undesirable_foodCreateNestedManyWithoutIm_foodInput
  }

  export type im_foodUncheckedCreateInput = {
    id_food?: number
    food_name: string
    food_type: string
    food_calories: number
    food_carbs: number
    food_prots: number
    food_fats: number
    im_recipe?: im_recipeUncheckedCreateNestedManyWithoutIm_foodInput
    im_undesirable_food?: im_undesirable_foodUncheckedCreateNestedManyWithoutIm_foodInput
  }

  export type im_foodUpdateInput = {
    food_name?: StringFieldUpdateOperationsInput | string
    food_type?: StringFieldUpdateOperationsInput | string
    food_calories?: IntFieldUpdateOperationsInput | number
    food_carbs?: IntFieldUpdateOperationsInput | number
    food_prots?: IntFieldUpdateOperationsInput | number
    food_fats?: IntFieldUpdateOperationsInput | number
    im_recipe?: im_recipeUpdateManyWithoutIm_foodNestedInput
    im_undesirable_food?: im_undesirable_foodUpdateManyWithoutIm_foodNestedInput
  }

  export type im_foodUncheckedUpdateInput = {
    id_food?: IntFieldUpdateOperationsInput | number
    food_name?: StringFieldUpdateOperationsInput | string
    food_type?: StringFieldUpdateOperationsInput | string
    food_calories?: IntFieldUpdateOperationsInput | number
    food_carbs?: IntFieldUpdateOperationsInput | number
    food_prots?: IntFieldUpdateOperationsInput | number
    food_fats?: IntFieldUpdateOperationsInput | number
    im_recipe?: im_recipeUncheckedUpdateManyWithoutIm_foodNestedInput
    im_undesirable_food?: im_undesirable_foodUncheckedUpdateManyWithoutIm_foodNestedInput
  }

  export type im_foodCreateManyInput = {
    id_food?: number
    food_name: string
    food_type: string
    food_calories: number
    food_carbs: number
    food_prots: number
    food_fats: number
  }

  export type im_foodUpdateManyMutationInput = {
    food_name?: StringFieldUpdateOperationsInput | string
    food_type?: StringFieldUpdateOperationsInput | string
    food_calories?: IntFieldUpdateOperationsInput | number
    food_carbs?: IntFieldUpdateOperationsInput | number
    food_prots?: IntFieldUpdateOperationsInput | number
    food_fats?: IntFieldUpdateOperationsInput | number
  }

  export type im_foodUncheckedUpdateManyInput = {
    id_food?: IntFieldUpdateOperationsInput | number
    food_name?: StringFieldUpdateOperationsInput | string
    food_type?: StringFieldUpdateOperationsInput | string
    food_calories?: IntFieldUpdateOperationsInput | number
    food_carbs?: IntFieldUpdateOperationsInput | number
    food_prots?: IntFieldUpdateOperationsInput | number
    food_fats?: IntFieldUpdateOperationsInput | number
  }

  export type im_healthCreateInput = {
    im_user: im_userCreateNestedOneWithoutIm_healthInput
    im_health_goal?: im_health_goalCreateNestedManyWithoutIm_healthInput
  }

  export type im_healthUncheckedCreateInput = {
    id_health?: number
    id_user: number
    im_health_goal?: im_health_goalUncheckedCreateNestedManyWithoutIm_healthInput
  }

  export type im_healthUpdateInput = {
    im_user?: im_userUpdateOneRequiredWithoutIm_healthNestedInput
    im_health_goal?: im_health_goalUpdateManyWithoutIm_healthNestedInput
  }

  export type im_healthUncheckedUpdateInput = {
    id_health?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    im_health_goal?: im_health_goalUncheckedUpdateManyWithoutIm_healthNestedInput
  }

  export type im_healthCreateManyInput = {
    id_health?: number
    id_user: number
  }

  export type im_healthUpdateManyMutationInput = {

  }

  export type im_healthUncheckedUpdateManyInput = {
    id_health?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
  }

  export type im_health_goalCreateInput = {
    health_goal_steps: number
    health_goal_weight: number
    health_goal_sleep: number
    health_goal_water: number
    im_health: im_healthCreateNestedOneWithoutIm_health_goalInput
    im_health_goal_daily?: im_health_goal_dailyCreateNestedManyWithoutIm_health_goalInput
  }

  export type im_health_goalUncheckedCreateInput = {
    id_health_goal?: number
    health_goal_steps: number
    health_goal_weight: number
    health_goal_sleep: number
    health_goal_water: number
    id_health: number
    im_health_goal_daily?: im_health_goal_dailyUncheckedCreateNestedManyWithoutIm_health_goalInput
  }

  export type im_health_goalUpdateInput = {
    health_goal_steps?: IntFieldUpdateOperationsInput | number
    health_goal_weight?: IntFieldUpdateOperationsInput | number
    health_goal_sleep?: IntFieldUpdateOperationsInput | number
    health_goal_water?: IntFieldUpdateOperationsInput | number
    im_health?: im_healthUpdateOneRequiredWithoutIm_health_goalNestedInput
    im_health_goal_daily?: im_health_goal_dailyUpdateManyWithoutIm_health_goalNestedInput
  }

  export type im_health_goalUncheckedUpdateInput = {
    id_health_goal?: IntFieldUpdateOperationsInput | number
    health_goal_steps?: IntFieldUpdateOperationsInput | number
    health_goal_weight?: IntFieldUpdateOperationsInput | number
    health_goal_sleep?: IntFieldUpdateOperationsInput | number
    health_goal_water?: IntFieldUpdateOperationsInput | number
    id_health?: IntFieldUpdateOperationsInput | number
    im_health_goal_daily?: im_health_goal_dailyUncheckedUpdateManyWithoutIm_health_goalNestedInput
  }

  export type im_health_goalCreateManyInput = {
    id_health_goal?: number
    health_goal_steps: number
    health_goal_weight: number
    health_goal_sleep: number
    health_goal_water: number
    id_health: number
  }

  export type im_health_goalUpdateManyMutationInput = {
    health_goal_steps?: IntFieldUpdateOperationsInput | number
    health_goal_weight?: IntFieldUpdateOperationsInput | number
    health_goal_sleep?: IntFieldUpdateOperationsInput | number
    health_goal_water?: IntFieldUpdateOperationsInput | number
  }

  export type im_health_goalUncheckedUpdateManyInput = {
    id_health_goal?: IntFieldUpdateOperationsInput | number
    health_goal_steps?: IntFieldUpdateOperationsInput | number
    health_goal_weight?: IntFieldUpdateOperationsInput | number
    health_goal_sleep?: IntFieldUpdateOperationsInput | number
    health_goal_water?: IntFieldUpdateOperationsInput | number
    id_health?: IntFieldUpdateOperationsInput | number
  }

  export type im_health_goal_dailyCreateInput = {
    health_goal_daily_date: Date | string
    health_goal_daily_steps: number
    health_goal_daily_weight: number
    health_goal_daily_sleep: number
    health_goal_daily_water: number
    im_health_goal: im_health_goalCreateNestedOneWithoutIm_health_goal_dailyInput
    im_health_goal_daily_history?: im_health_goal_daily_historyCreateNestedManyWithoutIm_health_goal_dailyInput
  }

  export type im_health_goal_dailyUncheckedCreateInput = {
    id_health_goal_daily?: number
    health_goal_daily_date: Date | string
    health_goal_daily_steps: number
    health_goal_daily_weight: number
    health_goal_daily_sleep: number
    health_goal_daily_water: number
    id_health_goal: number
    im_health_goal_daily_history?: im_health_goal_daily_historyUncheckedCreateNestedManyWithoutIm_health_goal_dailyInput
  }

  export type im_health_goal_dailyUpdateInput = {
    health_goal_daily_date?: DateTimeFieldUpdateOperationsInput | Date | string
    health_goal_daily_steps?: IntFieldUpdateOperationsInput | number
    health_goal_daily_weight?: IntFieldUpdateOperationsInput | number
    health_goal_daily_sleep?: IntFieldUpdateOperationsInput | number
    health_goal_daily_water?: IntFieldUpdateOperationsInput | number
    im_health_goal?: im_health_goalUpdateOneRequiredWithoutIm_health_goal_dailyNestedInput
    im_health_goal_daily_history?: im_health_goal_daily_historyUpdateManyWithoutIm_health_goal_dailyNestedInput
  }

  export type im_health_goal_dailyUncheckedUpdateInput = {
    id_health_goal_daily?: IntFieldUpdateOperationsInput | number
    health_goal_daily_date?: DateTimeFieldUpdateOperationsInput | Date | string
    health_goal_daily_steps?: IntFieldUpdateOperationsInput | number
    health_goal_daily_weight?: IntFieldUpdateOperationsInput | number
    health_goal_daily_sleep?: IntFieldUpdateOperationsInput | number
    health_goal_daily_water?: IntFieldUpdateOperationsInput | number
    id_health_goal?: IntFieldUpdateOperationsInput | number
    im_health_goal_daily_history?: im_health_goal_daily_historyUncheckedUpdateManyWithoutIm_health_goal_dailyNestedInput
  }

  export type im_health_goal_dailyCreateManyInput = {
    id_health_goal_daily?: number
    health_goal_daily_date: Date | string
    health_goal_daily_steps: number
    health_goal_daily_weight: number
    health_goal_daily_sleep: number
    health_goal_daily_water: number
    id_health_goal: number
  }

  export type im_health_goal_dailyUpdateManyMutationInput = {
    health_goal_daily_date?: DateTimeFieldUpdateOperationsInput | Date | string
    health_goal_daily_steps?: IntFieldUpdateOperationsInput | number
    health_goal_daily_weight?: IntFieldUpdateOperationsInput | number
    health_goal_daily_sleep?: IntFieldUpdateOperationsInput | number
    health_goal_daily_water?: IntFieldUpdateOperationsInput | number
  }

  export type im_health_goal_dailyUncheckedUpdateManyInput = {
    id_health_goal_daily?: IntFieldUpdateOperationsInput | number
    health_goal_daily_date?: DateTimeFieldUpdateOperationsInput | Date | string
    health_goal_daily_steps?: IntFieldUpdateOperationsInput | number
    health_goal_daily_weight?: IntFieldUpdateOperationsInput | number
    health_goal_daily_sleep?: IntFieldUpdateOperationsInput | number
    health_goal_daily_water?: IntFieldUpdateOperationsInput | number
    id_health_goal?: IntFieldUpdateOperationsInput | number
  }

  export type im_health_goal_daily_historyCreateInput = {
    health_goal_daily_history_date: Date | string
    im_health_goal_daily: im_health_goal_dailyCreateNestedOneWithoutIm_health_goal_daily_historyInput
  }

  export type im_health_goal_daily_historyUncheckedCreateInput = {
    id_health_goal_daily_history?: number
    health_goal_daily_history_date: Date | string
    id_health_goal_daily: number
  }

  export type im_health_goal_daily_historyUpdateInput = {
    health_goal_daily_history_date?: DateTimeFieldUpdateOperationsInput | Date | string
    im_health_goal_daily?: im_health_goal_dailyUpdateOneRequiredWithoutIm_health_goal_daily_historyNestedInput
  }

  export type im_health_goal_daily_historyUncheckedUpdateInput = {
    id_health_goal_daily_history?: IntFieldUpdateOperationsInput | number
    health_goal_daily_history_date?: DateTimeFieldUpdateOperationsInput | Date | string
    id_health_goal_daily?: IntFieldUpdateOperationsInput | number
  }

  export type im_health_goal_daily_historyCreateManyInput = {
    id_health_goal_daily_history?: number
    health_goal_daily_history_date: Date | string
    id_health_goal_daily: number
  }

  export type im_health_goal_daily_historyUpdateManyMutationInput = {
    health_goal_daily_history_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type im_health_goal_daily_historyUncheckedUpdateManyInput = {
    id_health_goal_daily_history?: IntFieldUpdateOperationsInput | number
    health_goal_daily_history_date?: DateTimeFieldUpdateOperationsInput | Date | string
    id_health_goal_daily?: IntFieldUpdateOperationsInput | number
  }

  export type im_mealCreateInput = {
    meal_name: string
    meal_quantity: number
    meal_calories: number
    meal_carbs: number
    meal_prots: number
    meal_fats: number
    meal_description: string
    meal_length: number
    meal_image: string
    meal_difficulty: number
    meal_season: number
    im_nutrition: im_nutritionCreateNestedOneWithoutIm_mealInput
    im_recipe?: im_recipeCreateNestedManyWithoutIm_mealInput
  }

  export type im_mealUncheckedCreateInput = {
    id_meal?: number
    meal_name: string
    meal_quantity: number
    meal_calories: number
    meal_carbs: number
    meal_prots: number
    meal_fats: number
    meal_description: string
    meal_length: number
    meal_image: string
    meal_difficulty: number
    meal_season: number
    id_nutrition: number
    im_recipe?: im_recipeUncheckedCreateNestedManyWithoutIm_mealInput
  }

  export type im_mealUpdateInput = {
    meal_name?: StringFieldUpdateOperationsInput | string
    meal_quantity?: IntFieldUpdateOperationsInput | number
    meal_calories?: IntFieldUpdateOperationsInput | number
    meal_carbs?: IntFieldUpdateOperationsInput | number
    meal_prots?: IntFieldUpdateOperationsInput | number
    meal_fats?: IntFieldUpdateOperationsInput | number
    meal_description?: StringFieldUpdateOperationsInput | string
    meal_length?: IntFieldUpdateOperationsInput | number
    meal_image?: StringFieldUpdateOperationsInput | string
    meal_difficulty?: IntFieldUpdateOperationsInput | number
    meal_season?: IntFieldUpdateOperationsInput | number
    im_nutrition?: im_nutritionUpdateOneRequiredWithoutIm_mealNestedInput
    im_recipe?: im_recipeUpdateManyWithoutIm_mealNestedInput
  }

  export type im_mealUncheckedUpdateInput = {
    id_meal?: IntFieldUpdateOperationsInput | number
    meal_name?: StringFieldUpdateOperationsInput | string
    meal_quantity?: IntFieldUpdateOperationsInput | number
    meal_calories?: IntFieldUpdateOperationsInput | number
    meal_carbs?: IntFieldUpdateOperationsInput | number
    meal_prots?: IntFieldUpdateOperationsInput | number
    meal_fats?: IntFieldUpdateOperationsInput | number
    meal_description?: StringFieldUpdateOperationsInput | string
    meal_length?: IntFieldUpdateOperationsInput | number
    meal_image?: StringFieldUpdateOperationsInput | string
    meal_difficulty?: IntFieldUpdateOperationsInput | number
    meal_season?: IntFieldUpdateOperationsInput | number
    id_nutrition?: IntFieldUpdateOperationsInput | number
    im_recipe?: im_recipeUncheckedUpdateManyWithoutIm_mealNestedInput
  }

  export type im_mealCreateManyInput = {
    id_meal?: number
    meal_name: string
    meal_quantity: number
    meal_calories: number
    meal_carbs: number
    meal_prots: number
    meal_fats: number
    meal_description: string
    meal_length: number
    meal_image: string
    meal_difficulty: number
    meal_season: number
    id_nutrition: number
  }

  export type im_mealUpdateManyMutationInput = {
    meal_name?: StringFieldUpdateOperationsInput | string
    meal_quantity?: IntFieldUpdateOperationsInput | number
    meal_calories?: IntFieldUpdateOperationsInput | number
    meal_carbs?: IntFieldUpdateOperationsInput | number
    meal_prots?: IntFieldUpdateOperationsInput | number
    meal_fats?: IntFieldUpdateOperationsInput | number
    meal_description?: StringFieldUpdateOperationsInput | string
    meal_length?: IntFieldUpdateOperationsInput | number
    meal_image?: StringFieldUpdateOperationsInput | string
    meal_difficulty?: IntFieldUpdateOperationsInput | number
    meal_season?: IntFieldUpdateOperationsInput | number
  }

  export type im_mealUncheckedUpdateManyInput = {
    id_meal?: IntFieldUpdateOperationsInput | number
    meal_name?: StringFieldUpdateOperationsInput | string
    meal_quantity?: IntFieldUpdateOperationsInput | number
    meal_calories?: IntFieldUpdateOperationsInput | number
    meal_carbs?: IntFieldUpdateOperationsInput | number
    meal_prots?: IntFieldUpdateOperationsInput | number
    meal_fats?: IntFieldUpdateOperationsInput | number
    meal_description?: StringFieldUpdateOperationsInput | string
    meal_length?: IntFieldUpdateOperationsInput | number
    meal_image?: StringFieldUpdateOperationsInput | string
    meal_difficulty?: IntFieldUpdateOperationsInput | number
    meal_season?: IntFieldUpdateOperationsInput | number
    id_nutrition?: IntFieldUpdateOperationsInput | number
  }

  export type im_nutritionCreateInput = {
    nutrition_goal: number
    nutrition_goal_calories: number
    nutrition_goal_carbs: number
    nutrition_goal_prots: number
    nutrition_goal_fats: number
    im_meal?: im_mealCreateNestedManyWithoutIm_nutritionInput
    im_user: im_userCreateNestedOneWithoutIm_nutritionInput
  }

  export type im_nutritionUncheckedCreateInput = {
    id_nutrition?: number
    nutrition_goal: number
    nutrition_goal_calories: number
    nutrition_goal_carbs: number
    nutrition_goal_prots: number
    nutrition_goal_fats: number
    id_user: number
    im_meal?: im_mealUncheckedCreateNestedManyWithoutIm_nutritionInput
  }

  export type im_nutritionUpdateInput = {
    nutrition_goal?: IntFieldUpdateOperationsInput | number
    nutrition_goal_calories?: IntFieldUpdateOperationsInput | number
    nutrition_goal_carbs?: IntFieldUpdateOperationsInput | number
    nutrition_goal_prots?: IntFieldUpdateOperationsInput | number
    nutrition_goal_fats?: IntFieldUpdateOperationsInput | number
    im_meal?: im_mealUpdateManyWithoutIm_nutritionNestedInput
    im_user?: im_userUpdateOneRequiredWithoutIm_nutritionNestedInput
  }

  export type im_nutritionUncheckedUpdateInput = {
    id_nutrition?: IntFieldUpdateOperationsInput | number
    nutrition_goal?: IntFieldUpdateOperationsInput | number
    nutrition_goal_calories?: IntFieldUpdateOperationsInput | number
    nutrition_goal_carbs?: IntFieldUpdateOperationsInput | number
    nutrition_goal_prots?: IntFieldUpdateOperationsInput | number
    nutrition_goal_fats?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    im_meal?: im_mealUncheckedUpdateManyWithoutIm_nutritionNestedInput
  }

  export type im_nutritionCreateManyInput = {
    id_nutrition?: number
    nutrition_goal: number
    nutrition_goal_calories: number
    nutrition_goal_carbs: number
    nutrition_goal_prots: number
    nutrition_goal_fats: number
    id_user: number
  }

  export type im_nutritionUpdateManyMutationInput = {
    nutrition_goal?: IntFieldUpdateOperationsInput | number
    nutrition_goal_calories?: IntFieldUpdateOperationsInput | number
    nutrition_goal_carbs?: IntFieldUpdateOperationsInput | number
    nutrition_goal_prots?: IntFieldUpdateOperationsInput | number
    nutrition_goal_fats?: IntFieldUpdateOperationsInput | number
  }

  export type im_nutritionUncheckedUpdateManyInput = {
    id_nutrition?: IntFieldUpdateOperationsInput | number
    nutrition_goal?: IntFieldUpdateOperationsInput | number
    nutrition_goal_calories?: IntFieldUpdateOperationsInput | number
    nutrition_goal_carbs?: IntFieldUpdateOperationsInput | number
    nutrition_goal_prots?: IntFieldUpdateOperationsInput | number
    nutrition_goal_fats?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
  }

  export type im_recipeCreateInput = {
    im_meal: im_mealCreateNestedOneWithoutIm_recipeInput
    im_food: im_foodCreateNestedOneWithoutIm_recipeInput
  }

  export type im_recipeUncheckedCreateInput = {
    id_recipe?: number
    id_meal: number
    id_food: number
  }

  export type im_recipeUpdateInput = {
    im_meal?: im_mealUpdateOneRequiredWithoutIm_recipeNestedInput
    im_food?: im_foodUpdateOneRequiredWithoutIm_recipeNestedInput
  }

  export type im_recipeUncheckedUpdateInput = {
    id_recipe?: IntFieldUpdateOperationsInput | number
    id_meal?: IntFieldUpdateOperationsInput | number
    id_food?: IntFieldUpdateOperationsInput | number
  }

  export type im_recipeCreateManyInput = {
    id_recipe?: number
    id_meal: number
    id_food: number
  }

  export type im_recipeUpdateManyMutationInput = {

  }

  export type im_recipeUncheckedUpdateManyInput = {
    id_recipe?: IntFieldUpdateOperationsInput | number
    id_meal?: IntFieldUpdateOperationsInput | number
    id_food?: IntFieldUpdateOperationsInput | number
  }

  export type im_trainingCreateInput = {
    training_goal: string
    im_user: im_userCreateNestedOneWithoutIm_trainingInput
    im_workout?: im_workoutCreateNestedManyWithoutIm_trainingInput
  }

  export type im_trainingUncheckedCreateInput = {
    id_training?: number
    training_goal: string
    id_user: number
    im_workout?: im_workoutUncheckedCreateNestedManyWithoutIm_trainingInput
  }

  export type im_trainingUpdateInput = {
    training_goal?: StringFieldUpdateOperationsInput | string
    im_user?: im_userUpdateOneRequiredWithoutIm_trainingNestedInput
    im_workout?: im_workoutUpdateManyWithoutIm_trainingNestedInput
  }

  export type im_trainingUncheckedUpdateInput = {
    id_training?: IntFieldUpdateOperationsInput | number
    training_goal?: StringFieldUpdateOperationsInput | string
    id_user?: IntFieldUpdateOperationsInput | number
    im_workout?: im_workoutUncheckedUpdateManyWithoutIm_trainingNestedInput
  }

  export type im_trainingCreateManyInput = {
    id_training?: number
    training_goal: string
    id_user: number
  }

  export type im_trainingUpdateManyMutationInput = {
    training_goal?: StringFieldUpdateOperationsInput | string
  }

  export type im_trainingUncheckedUpdateManyInput = {
    id_training?: IntFieldUpdateOperationsInput | number
    training_goal?: StringFieldUpdateOperationsInput | string
    id_user?: IntFieldUpdateOperationsInput | number
  }

  export type im_undesirable_foodCreateInput = {
    im_user: im_userCreateNestedOneWithoutIm_undesirable_foodInput
    im_food: im_foodCreateNestedOneWithoutIm_undesirable_foodInput
  }

  export type im_undesirable_foodUncheckedCreateInput = {
    id_undesirable_food?: number
    id_food: number
    id_user: number
  }

  export type im_undesirable_foodUpdateInput = {
    im_user?: im_userUpdateOneRequiredWithoutIm_undesirable_foodNestedInput
    im_food?: im_foodUpdateOneRequiredWithoutIm_undesirable_foodNestedInput
  }

  export type im_undesirable_foodUncheckedUpdateInput = {
    id_undesirable_food?: IntFieldUpdateOperationsInput | number
    id_food?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
  }

  export type im_undesirable_foodCreateManyInput = {
    id_undesirable_food?: number
    id_food: number
    id_user: number
  }

  export type im_undesirable_foodUpdateManyMutationInput = {

  }

  export type im_undesirable_foodUncheckedUpdateManyInput = {
    id_undesirable_food?: IntFieldUpdateOperationsInput | number
    id_food?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
  }

  export type im_userCreateInput = {
    user_firstname: string
    user_name: string
    user_mail: string
    user_password: string
    user_birth_date: Date | string
    user_inscription_date: Date | string
    user_gender: number
    user_height: number
    user_weight: number
    user_age: number
    user_training_level: number
    user_nutrition_diet: number
    im_health?: im_healthCreateNestedManyWithoutIm_userInput
    im_nutrition?: im_nutritionCreateNestedManyWithoutIm_userInput
    im_training?: im_trainingCreateNestedManyWithoutIm_userInput
    im_undesirable_food?: im_undesirable_foodCreateNestedManyWithoutIm_userInput
  }

  export type im_userUncheckedCreateInput = {
    id_user?: number
    user_firstname: string
    user_name: string
    user_mail: string
    user_password: string
    user_birth_date: Date | string
    user_inscription_date: Date | string
    user_gender: number
    user_height: number
    user_weight: number
    user_age: number
    user_training_level: number
    user_nutrition_diet: number
    im_health?: im_healthUncheckedCreateNestedManyWithoutIm_userInput
    im_nutrition?: im_nutritionUncheckedCreateNestedManyWithoutIm_userInput
    im_training?: im_trainingUncheckedCreateNestedManyWithoutIm_userInput
    im_undesirable_food?: im_undesirable_foodUncheckedCreateNestedManyWithoutIm_userInput
  }

  export type im_userUpdateInput = {
    user_firstname?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_mail?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    user_birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_inscription_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_gender?: IntFieldUpdateOperationsInput | number
    user_height?: IntFieldUpdateOperationsInput | number
    user_weight?: IntFieldUpdateOperationsInput | number
    user_age?: IntFieldUpdateOperationsInput | number
    user_training_level?: IntFieldUpdateOperationsInput | number
    user_nutrition_diet?: IntFieldUpdateOperationsInput | number
    im_health?: im_healthUpdateManyWithoutIm_userNestedInput
    im_nutrition?: im_nutritionUpdateManyWithoutIm_userNestedInput
    im_training?: im_trainingUpdateManyWithoutIm_userNestedInput
    im_undesirable_food?: im_undesirable_foodUpdateManyWithoutIm_userNestedInput
  }

  export type im_userUncheckedUpdateInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    user_firstname?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_mail?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    user_birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_inscription_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_gender?: IntFieldUpdateOperationsInput | number
    user_height?: IntFieldUpdateOperationsInput | number
    user_weight?: IntFieldUpdateOperationsInput | number
    user_age?: IntFieldUpdateOperationsInput | number
    user_training_level?: IntFieldUpdateOperationsInput | number
    user_nutrition_diet?: IntFieldUpdateOperationsInput | number
    im_health?: im_healthUncheckedUpdateManyWithoutIm_userNestedInput
    im_nutrition?: im_nutritionUncheckedUpdateManyWithoutIm_userNestedInput
    im_training?: im_trainingUncheckedUpdateManyWithoutIm_userNestedInput
    im_undesirable_food?: im_undesirable_foodUncheckedUpdateManyWithoutIm_userNestedInput
  }

  export type im_userCreateManyInput = {
    id_user?: number
    user_firstname: string
    user_name: string
    user_mail: string
    user_password: string
    user_birth_date: Date | string
    user_inscription_date: Date | string
    user_gender: number
    user_height: number
    user_weight: number
    user_age: number
    user_training_level: number
    user_nutrition_diet: number
  }

  export type im_userUpdateManyMutationInput = {
    user_firstname?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_mail?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    user_birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_inscription_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_gender?: IntFieldUpdateOperationsInput | number
    user_height?: IntFieldUpdateOperationsInput | number
    user_weight?: IntFieldUpdateOperationsInput | number
    user_age?: IntFieldUpdateOperationsInput | number
    user_training_level?: IntFieldUpdateOperationsInput | number
    user_nutrition_diet?: IntFieldUpdateOperationsInput | number
  }

  export type im_userUncheckedUpdateManyInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    user_firstname?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_mail?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    user_birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_inscription_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_gender?: IntFieldUpdateOperationsInput | number
    user_height?: IntFieldUpdateOperationsInput | number
    user_weight?: IntFieldUpdateOperationsInput | number
    user_age?: IntFieldUpdateOperationsInput | number
    user_training_level?: IntFieldUpdateOperationsInput | number
    user_nutrition_diet?: IntFieldUpdateOperationsInput | number
  }

  export type im_workoutCreateInput = {
    workout_point: number
    workout_name: string
    workout_comment: string
    im_exercise?: im_exerciseCreateNestedManyWithoutIm_workoutInput
    im_training: im_trainingCreateNestedOneWithoutIm_workoutInput
  }

  export type im_workoutUncheckedCreateInput = {
    id_workout?: number
    workout_point: number
    workout_name: string
    workout_comment: string
    id_training: number
    im_exercise?: im_exerciseUncheckedCreateNestedManyWithoutIm_workoutInput
  }

  export type im_workoutUpdateInput = {
    workout_point?: IntFieldUpdateOperationsInput | number
    workout_name?: StringFieldUpdateOperationsInput | string
    workout_comment?: StringFieldUpdateOperationsInput | string
    im_exercise?: im_exerciseUpdateManyWithoutIm_workoutNestedInput
    im_training?: im_trainingUpdateOneRequiredWithoutIm_workoutNestedInput
  }

  export type im_workoutUncheckedUpdateInput = {
    id_workout?: IntFieldUpdateOperationsInput | number
    workout_point?: IntFieldUpdateOperationsInput | number
    workout_name?: StringFieldUpdateOperationsInput | string
    workout_comment?: StringFieldUpdateOperationsInput | string
    id_training?: IntFieldUpdateOperationsInput | number
    im_exercise?: im_exerciseUncheckedUpdateManyWithoutIm_workoutNestedInput
  }

  export type im_workoutCreateManyInput = {
    id_workout?: number
    workout_point: number
    workout_name: string
    workout_comment: string
    id_training: number
  }

  export type im_workoutUpdateManyMutationInput = {
    workout_point?: IntFieldUpdateOperationsInput | number
    workout_name?: StringFieldUpdateOperationsInput | string
    workout_comment?: StringFieldUpdateOperationsInput | string
  }

  export type im_workoutUncheckedUpdateManyInput = {
    id_workout?: IntFieldUpdateOperationsInput | number
    workout_point?: IntFieldUpdateOperationsInput | number
    workout_name?: StringFieldUpdateOperationsInput | string
    workout_comment?: StringFieldUpdateOperationsInput | string
    id_training?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type Im_workoutRelationFilter = {
    is?: im_workoutWhereInput
    isNot?: im_workoutWhereInput
  }

  export type Im_exercise_historyListRelationFilter = {
    every?: im_exercise_historyWhereInput
    some?: im_exercise_historyWhereInput
    none?: im_exercise_historyWhereInput
  }

  export type im_exercise_historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type im_exerciseCountOrderByAggregateInput = {
    id_exercise?: SortOrder
    exercise_name?: SortOrder
    exercise_type?: SortOrder
    exercise_rest_time?: SortOrder
    exercise_reps?: SortOrder
    exercise_series?: SortOrder
    exercise_description?: SortOrder
    id_workout?: SortOrder
  }

  export type im_exerciseAvgOrderByAggregateInput = {
    id_exercise?: SortOrder
    exercise_rest_time?: SortOrder
    exercise_reps?: SortOrder
    exercise_series?: SortOrder
    id_workout?: SortOrder
  }

  export type im_exerciseMaxOrderByAggregateInput = {
    id_exercise?: SortOrder
    exercise_name?: SortOrder
    exercise_type?: SortOrder
    exercise_rest_time?: SortOrder
    exercise_reps?: SortOrder
    exercise_series?: SortOrder
    exercise_description?: SortOrder
    id_workout?: SortOrder
  }

  export type im_exerciseMinOrderByAggregateInput = {
    id_exercise?: SortOrder
    exercise_name?: SortOrder
    exercise_type?: SortOrder
    exercise_rest_time?: SortOrder
    exercise_reps?: SortOrder
    exercise_series?: SortOrder
    exercise_description?: SortOrder
    id_workout?: SortOrder
  }

  export type im_exerciseSumOrderByAggregateInput = {
    id_exercise?: SortOrder
    exercise_rest_time?: SortOrder
    exercise_reps?: SortOrder
    exercise_series?: SortOrder
    id_workout?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type Im_exerciseRelationFilter = {
    is?: im_exerciseWhereInput
    isNot?: im_exerciseWhereInput
  }

  export type im_exercise_historyCountOrderByAggregateInput = {
    id_exercise_history?: SortOrder
    exercise_history_date?: SortOrder
    id_exercise?: SortOrder
  }

  export type im_exercise_historyAvgOrderByAggregateInput = {
    id_exercise_history?: SortOrder
    id_exercise?: SortOrder
  }

  export type im_exercise_historyMaxOrderByAggregateInput = {
    id_exercise_history?: SortOrder
    exercise_history_date?: SortOrder
    id_exercise?: SortOrder
  }

  export type im_exercise_historyMinOrderByAggregateInput = {
    id_exercise_history?: SortOrder
    exercise_history_date?: SortOrder
    id_exercise?: SortOrder
  }

  export type im_exercise_historySumOrderByAggregateInput = {
    id_exercise_history?: SortOrder
    id_exercise?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type Im_recipeListRelationFilter = {
    every?: im_recipeWhereInput
    some?: im_recipeWhereInput
    none?: im_recipeWhereInput
  }

  export type Im_undesirable_foodListRelationFilter = {
    every?: im_undesirable_foodWhereInput
    some?: im_undesirable_foodWhereInput
    none?: im_undesirable_foodWhereInput
  }

  export type im_recipeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type im_undesirable_foodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type im_foodCountOrderByAggregateInput = {
    id_food?: SortOrder
    food_name?: SortOrder
    food_type?: SortOrder
    food_calories?: SortOrder
    food_carbs?: SortOrder
    food_prots?: SortOrder
    food_fats?: SortOrder
  }

  export type im_foodAvgOrderByAggregateInput = {
    id_food?: SortOrder
    food_calories?: SortOrder
    food_carbs?: SortOrder
    food_prots?: SortOrder
    food_fats?: SortOrder
  }

  export type im_foodMaxOrderByAggregateInput = {
    id_food?: SortOrder
    food_name?: SortOrder
    food_type?: SortOrder
    food_calories?: SortOrder
    food_carbs?: SortOrder
    food_prots?: SortOrder
    food_fats?: SortOrder
  }

  export type im_foodMinOrderByAggregateInput = {
    id_food?: SortOrder
    food_name?: SortOrder
    food_type?: SortOrder
    food_calories?: SortOrder
    food_carbs?: SortOrder
    food_prots?: SortOrder
    food_fats?: SortOrder
  }

  export type im_foodSumOrderByAggregateInput = {
    id_food?: SortOrder
    food_calories?: SortOrder
    food_carbs?: SortOrder
    food_prots?: SortOrder
    food_fats?: SortOrder
  }

  export type Im_userRelationFilter = {
    is?: im_userWhereInput
    isNot?: im_userWhereInput
  }

  export type Im_health_goalListRelationFilter = {
    every?: im_health_goalWhereInput
    some?: im_health_goalWhereInput
    none?: im_health_goalWhereInput
  }

  export type im_health_goalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type im_healthCountOrderByAggregateInput = {
    id_health?: SortOrder
    id_user?: SortOrder
  }

  export type im_healthAvgOrderByAggregateInput = {
    id_health?: SortOrder
    id_user?: SortOrder
  }

  export type im_healthMaxOrderByAggregateInput = {
    id_health?: SortOrder
    id_user?: SortOrder
  }

  export type im_healthMinOrderByAggregateInput = {
    id_health?: SortOrder
    id_user?: SortOrder
  }

  export type im_healthSumOrderByAggregateInput = {
    id_health?: SortOrder
    id_user?: SortOrder
  }

  export type Im_healthRelationFilter = {
    is?: im_healthWhereInput
    isNot?: im_healthWhereInput
  }

  export type Im_health_goal_dailyListRelationFilter = {
    every?: im_health_goal_dailyWhereInput
    some?: im_health_goal_dailyWhereInput
    none?: im_health_goal_dailyWhereInput
  }

  export type im_health_goal_dailyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type im_health_goalCountOrderByAggregateInput = {
    id_health_goal?: SortOrder
    health_goal_steps?: SortOrder
    health_goal_weight?: SortOrder
    health_goal_sleep?: SortOrder
    health_goal_water?: SortOrder
    id_health?: SortOrder
  }

  export type im_health_goalAvgOrderByAggregateInput = {
    id_health_goal?: SortOrder
    health_goal_steps?: SortOrder
    health_goal_weight?: SortOrder
    health_goal_sleep?: SortOrder
    health_goal_water?: SortOrder
    id_health?: SortOrder
  }

  export type im_health_goalMaxOrderByAggregateInput = {
    id_health_goal?: SortOrder
    health_goal_steps?: SortOrder
    health_goal_weight?: SortOrder
    health_goal_sleep?: SortOrder
    health_goal_water?: SortOrder
    id_health?: SortOrder
  }

  export type im_health_goalMinOrderByAggregateInput = {
    id_health_goal?: SortOrder
    health_goal_steps?: SortOrder
    health_goal_weight?: SortOrder
    health_goal_sleep?: SortOrder
    health_goal_water?: SortOrder
    id_health?: SortOrder
  }

  export type im_health_goalSumOrderByAggregateInput = {
    id_health_goal?: SortOrder
    health_goal_steps?: SortOrder
    health_goal_weight?: SortOrder
    health_goal_sleep?: SortOrder
    health_goal_water?: SortOrder
    id_health?: SortOrder
  }

  export type Im_health_goalRelationFilter = {
    is?: im_health_goalWhereInput
    isNot?: im_health_goalWhereInput
  }

  export type Im_health_goal_daily_historyListRelationFilter = {
    every?: im_health_goal_daily_historyWhereInput
    some?: im_health_goal_daily_historyWhereInput
    none?: im_health_goal_daily_historyWhereInput
  }

  export type im_health_goal_daily_historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type im_health_goal_dailyCountOrderByAggregateInput = {
    id_health_goal_daily?: SortOrder
    health_goal_daily_date?: SortOrder
    health_goal_daily_steps?: SortOrder
    health_goal_daily_weight?: SortOrder
    health_goal_daily_sleep?: SortOrder
    health_goal_daily_water?: SortOrder
    id_health_goal?: SortOrder
  }

  export type im_health_goal_dailyAvgOrderByAggregateInput = {
    id_health_goal_daily?: SortOrder
    health_goal_daily_steps?: SortOrder
    health_goal_daily_weight?: SortOrder
    health_goal_daily_sleep?: SortOrder
    health_goal_daily_water?: SortOrder
    id_health_goal?: SortOrder
  }

  export type im_health_goal_dailyMaxOrderByAggregateInput = {
    id_health_goal_daily?: SortOrder
    health_goal_daily_date?: SortOrder
    health_goal_daily_steps?: SortOrder
    health_goal_daily_weight?: SortOrder
    health_goal_daily_sleep?: SortOrder
    health_goal_daily_water?: SortOrder
    id_health_goal?: SortOrder
  }

  export type im_health_goal_dailyMinOrderByAggregateInput = {
    id_health_goal_daily?: SortOrder
    health_goal_daily_date?: SortOrder
    health_goal_daily_steps?: SortOrder
    health_goal_daily_weight?: SortOrder
    health_goal_daily_sleep?: SortOrder
    health_goal_daily_water?: SortOrder
    id_health_goal?: SortOrder
  }

  export type im_health_goal_dailySumOrderByAggregateInput = {
    id_health_goal_daily?: SortOrder
    health_goal_daily_steps?: SortOrder
    health_goal_daily_weight?: SortOrder
    health_goal_daily_sleep?: SortOrder
    health_goal_daily_water?: SortOrder
    id_health_goal?: SortOrder
  }

  export type Im_health_goal_dailyRelationFilter = {
    is?: im_health_goal_dailyWhereInput
    isNot?: im_health_goal_dailyWhereInput
  }

  export type im_health_goal_daily_historyCountOrderByAggregateInput = {
    id_health_goal_daily_history?: SortOrder
    health_goal_daily_history_date?: SortOrder
    id_health_goal_daily?: SortOrder
  }

  export type im_health_goal_daily_historyAvgOrderByAggregateInput = {
    id_health_goal_daily_history?: SortOrder
    id_health_goal_daily?: SortOrder
  }

  export type im_health_goal_daily_historyMaxOrderByAggregateInput = {
    id_health_goal_daily_history?: SortOrder
    health_goal_daily_history_date?: SortOrder
    id_health_goal_daily?: SortOrder
  }

  export type im_health_goal_daily_historyMinOrderByAggregateInput = {
    id_health_goal_daily_history?: SortOrder
    health_goal_daily_history_date?: SortOrder
    id_health_goal_daily?: SortOrder
  }

  export type im_health_goal_daily_historySumOrderByAggregateInput = {
    id_health_goal_daily_history?: SortOrder
    id_health_goal_daily?: SortOrder
  }

  export type Im_nutritionRelationFilter = {
    is?: im_nutritionWhereInput
    isNot?: im_nutritionWhereInput
  }

  export type im_mealCountOrderByAggregateInput = {
    id_meal?: SortOrder
    meal_name?: SortOrder
    meal_quantity?: SortOrder
    meal_calories?: SortOrder
    meal_carbs?: SortOrder
    meal_prots?: SortOrder
    meal_fats?: SortOrder
    meal_description?: SortOrder
    meal_length?: SortOrder
    meal_image?: SortOrder
    meal_difficulty?: SortOrder
    meal_season?: SortOrder
    id_nutrition?: SortOrder
  }

  export type im_mealAvgOrderByAggregateInput = {
    id_meal?: SortOrder
    meal_quantity?: SortOrder
    meal_calories?: SortOrder
    meal_carbs?: SortOrder
    meal_prots?: SortOrder
    meal_fats?: SortOrder
    meal_length?: SortOrder
    meal_difficulty?: SortOrder
    meal_season?: SortOrder
    id_nutrition?: SortOrder
  }

  export type im_mealMaxOrderByAggregateInput = {
    id_meal?: SortOrder
    meal_name?: SortOrder
    meal_quantity?: SortOrder
    meal_calories?: SortOrder
    meal_carbs?: SortOrder
    meal_prots?: SortOrder
    meal_fats?: SortOrder
    meal_description?: SortOrder
    meal_length?: SortOrder
    meal_image?: SortOrder
    meal_difficulty?: SortOrder
    meal_season?: SortOrder
    id_nutrition?: SortOrder
  }

  export type im_mealMinOrderByAggregateInput = {
    id_meal?: SortOrder
    meal_name?: SortOrder
    meal_quantity?: SortOrder
    meal_calories?: SortOrder
    meal_carbs?: SortOrder
    meal_prots?: SortOrder
    meal_fats?: SortOrder
    meal_description?: SortOrder
    meal_length?: SortOrder
    meal_image?: SortOrder
    meal_difficulty?: SortOrder
    meal_season?: SortOrder
    id_nutrition?: SortOrder
  }

  export type im_mealSumOrderByAggregateInput = {
    id_meal?: SortOrder
    meal_quantity?: SortOrder
    meal_calories?: SortOrder
    meal_carbs?: SortOrder
    meal_prots?: SortOrder
    meal_fats?: SortOrder
    meal_length?: SortOrder
    meal_difficulty?: SortOrder
    meal_season?: SortOrder
    id_nutrition?: SortOrder
  }

  export type Im_mealListRelationFilter = {
    every?: im_mealWhereInput
    some?: im_mealWhereInput
    none?: im_mealWhereInput
  }

  export type im_mealOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type im_nutritionCountOrderByAggregateInput = {
    id_nutrition?: SortOrder
    nutrition_goal?: SortOrder
    nutrition_goal_calories?: SortOrder
    nutrition_goal_carbs?: SortOrder
    nutrition_goal_prots?: SortOrder
    nutrition_goal_fats?: SortOrder
    id_user?: SortOrder
  }

  export type im_nutritionAvgOrderByAggregateInput = {
    id_nutrition?: SortOrder
    nutrition_goal?: SortOrder
    nutrition_goal_calories?: SortOrder
    nutrition_goal_carbs?: SortOrder
    nutrition_goal_prots?: SortOrder
    nutrition_goal_fats?: SortOrder
    id_user?: SortOrder
  }

  export type im_nutritionMaxOrderByAggregateInput = {
    id_nutrition?: SortOrder
    nutrition_goal?: SortOrder
    nutrition_goal_calories?: SortOrder
    nutrition_goal_carbs?: SortOrder
    nutrition_goal_prots?: SortOrder
    nutrition_goal_fats?: SortOrder
    id_user?: SortOrder
  }

  export type im_nutritionMinOrderByAggregateInput = {
    id_nutrition?: SortOrder
    nutrition_goal?: SortOrder
    nutrition_goal_calories?: SortOrder
    nutrition_goal_carbs?: SortOrder
    nutrition_goal_prots?: SortOrder
    nutrition_goal_fats?: SortOrder
    id_user?: SortOrder
  }

  export type im_nutritionSumOrderByAggregateInput = {
    id_nutrition?: SortOrder
    nutrition_goal?: SortOrder
    nutrition_goal_calories?: SortOrder
    nutrition_goal_carbs?: SortOrder
    nutrition_goal_prots?: SortOrder
    nutrition_goal_fats?: SortOrder
    id_user?: SortOrder
  }

  export type Im_mealRelationFilter = {
    is?: im_mealWhereInput
    isNot?: im_mealWhereInput
  }

  export type Im_foodRelationFilter = {
    is?: im_foodWhereInput
    isNot?: im_foodWhereInput
  }

  export type im_recipeCountOrderByAggregateInput = {
    id_recipe?: SortOrder
    id_meal?: SortOrder
    id_food?: SortOrder
  }

  export type im_recipeAvgOrderByAggregateInput = {
    id_recipe?: SortOrder
    id_meal?: SortOrder
    id_food?: SortOrder
  }

  export type im_recipeMaxOrderByAggregateInput = {
    id_recipe?: SortOrder
    id_meal?: SortOrder
    id_food?: SortOrder
  }

  export type im_recipeMinOrderByAggregateInput = {
    id_recipe?: SortOrder
    id_meal?: SortOrder
    id_food?: SortOrder
  }

  export type im_recipeSumOrderByAggregateInput = {
    id_recipe?: SortOrder
    id_meal?: SortOrder
    id_food?: SortOrder
  }

  export type Im_workoutListRelationFilter = {
    every?: im_workoutWhereInput
    some?: im_workoutWhereInput
    none?: im_workoutWhereInput
  }

  export type im_workoutOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type im_trainingCountOrderByAggregateInput = {
    id_training?: SortOrder
    training_goal?: SortOrder
    id_user?: SortOrder
  }

  export type im_trainingAvgOrderByAggregateInput = {
    id_training?: SortOrder
    id_user?: SortOrder
  }

  export type im_trainingMaxOrderByAggregateInput = {
    id_training?: SortOrder
    training_goal?: SortOrder
    id_user?: SortOrder
  }

  export type im_trainingMinOrderByAggregateInput = {
    id_training?: SortOrder
    training_goal?: SortOrder
    id_user?: SortOrder
  }

  export type im_trainingSumOrderByAggregateInput = {
    id_training?: SortOrder
    id_user?: SortOrder
  }

  export type im_undesirable_foodCountOrderByAggregateInput = {
    id_undesirable_food?: SortOrder
    id_food?: SortOrder
    id_user?: SortOrder
  }

  export type im_undesirable_foodAvgOrderByAggregateInput = {
    id_undesirable_food?: SortOrder
    id_food?: SortOrder
    id_user?: SortOrder
  }

  export type im_undesirable_foodMaxOrderByAggregateInput = {
    id_undesirable_food?: SortOrder
    id_food?: SortOrder
    id_user?: SortOrder
  }

  export type im_undesirable_foodMinOrderByAggregateInput = {
    id_undesirable_food?: SortOrder
    id_food?: SortOrder
    id_user?: SortOrder
  }

  export type im_undesirable_foodSumOrderByAggregateInput = {
    id_undesirable_food?: SortOrder
    id_food?: SortOrder
    id_user?: SortOrder
  }

  export type Im_healthListRelationFilter = {
    every?: im_healthWhereInput
    some?: im_healthWhereInput
    none?: im_healthWhereInput
  }

  export type Im_nutritionListRelationFilter = {
    every?: im_nutritionWhereInput
    some?: im_nutritionWhereInput
    none?: im_nutritionWhereInput
  }

  export type Im_trainingListRelationFilter = {
    every?: im_trainingWhereInput
    some?: im_trainingWhereInput
    none?: im_trainingWhereInput
  }

  export type im_healthOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type im_nutritionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type im_trainingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type im_userCountOrderByAggregateInput = {
    id_user?: SortOrder
    user_firstname?: SortOrder
    user_name?: SortOrder
    user_mail?: SortOrder
    user_password?: SortOrder
    user_birth_date?: SortOrder
    user_inscription_date?: SortOrder
    user_gender?: SortOrder
    user_height?: SortOrder
    user_weight?: SortOrder
    user_age?: SortOrder
    user_training_level?: SortOrder
    user_nutrition_diet?: SortOrder
  }

  export type im_userAvgOrderByAggregateInput = {
    id_user?: SortOrder
    user_gender?: SortOrder
    user_height?: SortOrder
    user_weight?: SortOrder
    user_age?: SortOrder
    user_training_level?: SortOrder
    user_nutrition_diet?: SortOrder
  }

  export type im_userMaxOrderByAggregateInput = {
    id_user?: SortOrder
    user_firstname?: SortOrder
    user_name?: SortOrder
    user_mail?: SortOrder
    user_password?: SortOrder
    user_birth_date?: SortOrder
    user_inscription_date?: SortOrder
    user_gender?: SortOrder
    user_height?: SortOrder
    user_weight?: SortOrder
    user_age?: SortOrder
    user_training_level?: SortOrder
    user_nutrition_diet?: SortOrder
  }

  export type im_userMinOrderByAggregateInput = {
    id_user?: SortOrder
    user_firstname?: SortOrder
    user_name?: SortOrder
    user_mail?: SortOrder
    user_password?: SortOrder
    user_birth_date?: SortOrder
    user_inscription_date?: SortOrder
    user_gender?: SortOrder
    user_height?: SortOrder
    user_weight?: SortOrder
    user_age?: SortOrder
    user_training_level?: SortOrder
    user_nutrition_diet?: SortOrder
  }

  export type im_userSumOrderByAggregateInput = {
    id_user?: SortOrder
    user_gender?: SortOrder
    user_height?: SortOrder
    user_weight?: SortOrder
    user_age?: SortOrder
    user_training_level?: SortOrder
    user_nutrition_diet?: SortOrder
  }

  export type Im_exerciseListRelationFilter = {
    every?: im_exerciseWhereInput
    some?: im_exerciseWhereInput
    none?: im_exerciseWhereInput
  }

  export type Im_trainingRelationFilter = {
    is?: im_trainingWhereInput
    isNot?: im_trainingWhereInput
  }

  export type im_exerciseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type im_workoutCountOrderByAggregateInput = {
    id_workout?: SortOrder
    workout_point?: SortOrder
    workout_name?: SortOrder
    workout_comment?: SortOrder
    id_training?: SortOrder
  }

  export type im_workoutAvgOrderByAggregateInput = {
    id_workout?: SortOrder
    workout_point?: SortOrder
    id_training?: SortOrder
  }

  export type im_workoutMaxOrderByAggregateInput = {
    id_workout?: SortOrder
    workout_point?: SortOrder
    workout_name?: SortOrder
    workout_comment?: SortOrder
    id_training?: SortOrder
  }

  export type im_workoutMinOrderByAggregateInput = {
    id_workout?: SortOrder
    workout_point?: SortOrder
    workout_name?: SortOrder
    workout_comment?: SortOrder
    id_training?: SortOrder
  }

  export type im_workoutSumOrderByAggregateInput = {
    id_workout?: SortOrder
    workout_point?: SortOrder
    id_training?: SortOrder
  }

  export type im_workoutCreateNestedOneWithoutIm_exerciseInput = {
    create?: XOR<im_workoutCreateWithoutIm_exerciseInput, im_workoutUncheckedCreateWithoutIm_exerciseInput>
    connectOrCreate?: im_workoutCreateOrConnectWithoutIm_exerciseInput
    connect?: im_workoutWhereUniqueInput
  }

  export type im_exercise_historyCreateNestedManyWithoutIm_exerciseInput = {
    create?: XOR<im_exercise_historyCreateWithoutIm_exerciseInput, im_exercise_historyUncheckedCreateWithoutIm_exerciseInput> | im_exercise_historyCreateWithoutIm_exerciseInput[] | im_exercise_historyUncheckedCreateWithoutIm_exerciseInput[]
    connectOrCreate?: im_exercise_historyCreateOrConnectWithoutIm_exerciseInput | im_exercise_historyCreateOrConnectWithoutIm_exerciseInput[]
    createMany?: im_exercise_historyCreateManyIm_exerciseInputEnvelope
    connect?: im_exercise_historyWhereUniqueInput | im_exercise_historyWhereUniqueInput[]
  }

  export type im_exercise_historyUncheckedCreateNestedManyWithoutIm_exerciseInput = {
    create?: XOR<im_exercise_historyCreateWithoutIm_exerciseInput, im_exercise_historyUncheckedCreateWithoutIm_exerciseInput> | im_exercise_historyCreateWithoutIm_exerciseInput[] | im_exercise_historyUncheckedCreateWithoutIm_exerciseInput[]
    connectOrCreate?: im_exercise_historyCreateOrConnectWithoutIm_exerciseInput | im_exercise_historyCreateOrConnectWithoutIm_exerciseInput[]
    createMany?: im_exercise_historyCreateManyIm_exerciseInputEnvelope
    connect?: im_exercise_historyWhereUniqueInput | im_exercise_historyWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type im_workoutUpdateOneRequiredWithoutIm_exerciseNestedInput = {
    create?: XOR<im_workoutCreateWithoutIm_exerciseInput, im_workoutUncheckedCreateWithoutIm_exerciseInput>
    connectOrCreate?: im_workoutCreateOrConnectWithoutIm_exerciseInput
    upsert?: im_workoutUpsertWithoutIm_exerciseInput
    connect?: im_workoutWhereUniqueInput
    update?: XOR<XOR<im_workoutUpdateToOneWithWhereWithoutIm_exerciseInput, im_workoutUpdateWithoutIm_exerciseInput>, im_workoutUncheckedUpdateWithoutIm_exerciseInput>
  }

  export type im_exercise_historyUpdateManyWithoutIm_exerciseNestedInput = {
    create?: XOR<im_exercise_historyCreateWithoutIm_exerciseInput, im_exercise_historyUncheckedCreateWithoutIm_exerciseInput> | im_exercise_historyCreateWithoutIm_exerciseInput[] | im_exercise_historyUncheckedCreateWithoutIm_exerciseInput[]
    connectOrCreate?: im_exercise_historyCreateOrConnectWithoutIm_exerciseInput | im_exercise_historyCreateOrConnectWithoutIm_exerciseInput[]
    upsert?: im_exercise_historyUpsertWithWhereUniqueWithoutIm_exerciseInput | im_exercise_historyUpsertWithWhereUniqueWithoutIm_exerciseInput[]
    createMany?: im_exercise_historyCreateManyIm_exerciseInputEnvelope
    set?: im_exercise_historyWhereUniqueInput | im_exercise_historyWhereUniqueInput[]
    disconnect?: im_exercise_historyWhereUniqueInput | im_exercise_historyWhereUniqueInput[]
    delete?: im_exercise_historyWhereUniqueInput | im_exercise_historyWhereUniqueInput[]
    connect?: im_exercise_historyWhereUniqueInput | im_exercise_historyWhereUniqueInput[]
    update?: im_exercise_historyUpdateWithWhereUniqueWithoutIm_exerciseInput | im_exercise_historyUpdateWithWhereUniqueWithoutIm_exerciseInput[]
    updateMany?: im_exercise_historyUpdateManyWithWhereWithoutIm_exerciseInput | im_exercise_historyUpdateManyWithWhereWithoutIm_exerciseInput[]
    deleteMany?: im_exercise_historyScalarWhereInput | im_exercise_historyScalarWhereInput[]
  }

  export type im_exercise_historyUncheckedUpdateManyWithoutIm_exerciseNestedInput = {
    create?: XOR<im_exercise_historyCreateWithoutIm_exerciseInput, im_exercise_historyUncheckedCreateWithoutIm_exerciseInput> | im_exercise_historyCreateWithoutIm_exerciseInput[] | im_exercise_historyUncheckedCreateWithoutIm_exerciseInput[]
    connectOrCreate?: im_exercise_historyCreateOrConnectWithoutIm_exerciseInput | im_exercise_historyCreateOrConnectWithoutIm_exerciseInput[]
    upsert?: im_exercise_historyUpsertWithWhereUniqueWithoutIm_exerciseInput | im_exercise_historyUpsertWithWhereUniqueWithoutIm_exerciseInput[]
    createMany?: im_exercise_historyCreateManyIm_exerciseInputEnvelope
    set?: im_exercise_historyWhereUniqueInput | im_exercise_historyWhereUniqueInput[]
    disconnect?: im_exercise_historyWhereUniqueInput | im_exercise_historyWhereUniqueInput[]
    delete?: im_exercise_historyWhereUniqueInput | im_exercise_historyWhereUniqueInput[]
    connect?: im_exercise_historyWhereUniqueInput | im_exercise_historyWhereUniqueInput[]
    update?: im_exercise_historyUpdateWithWhereUniqueWithoutIm_exerciseInput | im_exercise_historyUpdateWithWhereUniqueWithoutIm_exerciseInput[]
    updateMany?: im_exercise_historyUpdateManyWithWhereWithoutIm_exerciseInput | im_exercise_historyUpdateManyWithWhereWithoutIm_exerciseInput[]
    deleteMany?: im_exercise_historyScalarWhereInput | im_exercise_historyScalarWhereInput[]
  }

  export type im_exerciseCreateNestedOneWithoutIm_exercise_historyInput = {
    create?: XOR<im_exerciseCreateWithoutIm_exercise_historyInput, im_exerciseUncheckedCreateWithoutIm_exercise_historyInput>
    connectOrCreate?: im_exerciseCreateOrConnectWithoutIm_exercise_historyInput
    connect?: im_exerciseWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type im_exerciseUpdateOneRequiredWithoutIm_exercise_historyNestedInput = {
    create?: XOR<im_exerciseCreateWithoutIm_exercise_historyInput, im_exerciseUncheckedCreateWithoutIm_exercise_historyInput>
    connectOrCreate?: im_exerciseCreateOrConnectWithoutIm_exercise_historyInput
    upsert?: im_exerciseUpsertWithoutIm_exercise_historyInput
    connect?: im_exerciseWhereUniqueInput
    update?: XOR<XOR<im_exerciseUpdateToOneWithWhereWithoutIm_exercise_historyInput, im_exerciseUpdateWithoutIm_exercise_historyInput>, im_exerciseUncheckedUpdateWithoutIm_exercise_historyInput>
  }

  export type im_recipeCreateNestedManyWithoutIm_foodInput = {
    create?: XOR<im_recipeCreateWithoutIm_foodInput, im_recipeUncheckedCreateWithoutIm_foodInput> | im_recipeCreateWithoutIm_foodInput[] | im_recipeUncheckedCreateWithoutIm_foodInput[]
    connectOrCreate?: im_recipeCreateOrConnectWithoutIm_foodInput | im_recipeCreateOrConnectWithoutIm_foodInput[]
    createMany?: im_recipeCreateManyIm_foodInputEnvelope
    connect?: im_recipeWhereUniqueInput | im_recipeWhereUniqueInput[]
  }

  export type im_undesirable_foodCreateNestedManyWithoutIm_foodInput = {
    create?: XOR<im_undesirable_foodCreateWithoutIm_foodInput, im_undesirable_foodUncheckedCreateWithoutIm_foodInput> | im_undesirable_foodCreateWithoutIm_foodInput[] | im_undesirable_foodUncheckedCreateWithoutIm_foodInput[]
    connectOrCreate?: im_undesirable_foodCreateOrConnectWithoutIm_foodInput | im_undesirable_foodCreateOrConnectWithoutIm_foodInput[]
    createMany?: im_undesirable_foodCreateManyIm_foodInputEnvelope
    connect?: im_undesirable_foodWhereUniqueInput | im_undesirable_foodWhereUniqueInput[]
  }

  export type im_recipeUncheckedCreateNestedManyWithoutIm_foodInput = {
    create?: XOR<im_recipeCreateWithoutIm_foodInput, im_recipeUncheckedCreateWithoutIm_foodInput> | im_recipeCreateWithoutIm_foodInput[] | im_recipeUncheckedCreateWithoutIm_foodInput[]
    connectOrCreate?: im_recipeCreateOrConnectWithoutIm_foodInput | im_recipeCreateOrConnectWithoutIm_foodInput[]
    createMany?: im_recipeCreateManyIm_foodInputEnvelope
    connect?: im_recipeWhereUniqueInput | im_recipeWhereUniqueInput[]
  }

  export type im_undesirable_foodUncheckedCreateNestedManyWithoutIm_foodInput = {
    create?: XOR<im_undesirable_foodCreateWithoutIm_foodInput, im_undesirable_foodUncheckedCreateWithoutIm_foodInput> | im_undesirable_foodCreateWithoutIm_foodInput[] | im_undesirable_foodUncheckedCreateWithoutIm_foodInput[]
    connectOrCreate?: im_undesirable_foodCreateOrConnectWithoutIm_foodInput | im_undesirable_foodCreateOrConnectWithoutIm_foodInput[]
    createMany?: im_undesirable_foodCreateManyIm_foodInputEnvelope
    connect?: im_undesirable_foodWhereUniqueInput | im_undesirable_foodWhereUniqueInput[]
  }

  export type im_recipeUpdateManyWithoutIm_foodNestedInput = {
    create?: XOR<im_recipeCreateWithoutIm_foodInput, im_recipeUncheckedCreateWithoutIm_foodInput> | im_recipeCreateWithoutIm_foodInput[] | im_recipeUncheckedCreateWithoutIm_foodInput[]
    connectOrCreate?: im_recipeCreateOrConnectWithoutIm_foodInput | im_recipeCreateOrConnectWithoutIm_foodInput[]
    upsert?: im_recipeUpsertWithWhereUniqueWithoutIm_foodInput | im_recipeUpsertWithWhereUniqueWithoutIm_foodInput[]
    createMany?: im_recipeCreateManyIm_foodInputEnvelope
    set?: im_recipeWhereUniqueInput | im_recipeWhereUniqueInput[]
    disconnect?: im_recipeWhereUniqueInput | im_recipeWhereUniqueInput[]
    delete?: im_recipeWhereUniqueInput | im_recipeWhereUniqueInput[]
    connect?: im_recipeWhereUniqueInput | im_recipeWhereUniqueInput[]
    update?: im_recipeUpdateWithWhereUniqueWithoutIm_foodInput | im_recipeUpdateWithWhereUniqueWithoutIm_foodInput[]
    updateMany?: im_recipeUpdateManyWithWhereWithoutIm_foodInput | im_recipeUpdateManyWithWhereWithoutIm_foodInput[]
    deleteMany?: im_recipeScalarWhereInput | im_recipeScalarWhereInput[]
  }

  export type im_undesirable_foodUpdateManyWithoutIm_foodNestedInput = {
    create?: XOR<im_undesirable_foodCreateWithoutIm_foodInput, im_undesirable_foodUncheckedCreateWithoutIm_foodInput> | im_undesirable_foodCreateWithoutIm_foodInput[] | im_undesirable_foodUncheckedCreateWithoutIm_foodInput[]
    connectOrCreate?: im_undesirable_foodCreateOrConnectWithoutIm_foodInput | im_undesirable_foodCreateOrConnectWithoutIm_foodInput[]
    upsert?: im_undesirable_foodUpsertWithWhereUniqueWithoutIm_foodInput | im_undesirable_foodUpsertWithWhereUniqueWithoutIm_foodInput[]
    createMany?: im_undesirable_foodCreateManyIm_foodInputEnvelope
    set?: im_undesirable_foodWhereUniqueInput | im_undesirable_foodWhereUniqueInput[]
    disconnect?: im_undesirable_foodWhereUniqueInput | im_undesirable_foodWhereUniqueInput[]
    delete?: im_undesirable_foodWhereUniqueInput | im_undesirable_foodWhereUniqueInput[]
    connect?: im_undesirable_foodWhereUniqueInput | im_undesirable_foodWhereUniqueInput[]
    update?: im_undesirable_foodUpdateWithWhereUniqueWithoutIm_foodInput | im_undesirable_foodUpdateWithWhereUniqueWithoutIm_foodInput[]
    updateMany?: im_undesirable_foodUpdateManyWithWhereWithoutIm_foodInput | im_undesirable_foodUpdateManyWithWhereWithoutIm_foodInput[]
    deleteMany?: im_undesirable_foodScalarWhereInput | im_undesirable_foodScalarWhereInput[]
  }

  export type im_recipeUncheckedUpdateManyWithoutIm_foodNestedInput = {
    create?: XOR<im_recipeCreateWithoutIm_foodInput, im_recipeUncheckedCreateWithoutIm_foodInput> | im_recipeCreateWithoutIm_foodInput[] | im_recipeUncheckedCreateWithoutIm_foodInput[]
    connectOrCreate?: im_recipeCreateOrConnectWithoutIm_foodInput | im_recipeCreateOrConnectWithoutIm_foodInput[]
    upsert?: im_recipeUpsertWithWhereUniqueWithoutIm_foodInput | im_recipeUpsertWithWhereUniqueWithoutIm_foodInput[]
    createMany?: im_recipeCreateManyIm_foodInputEnvelope
    set?: im_recipeWhereUniqueInput | im_recipeWhereUniqueInput[]
    disconnect?: im_recipeWhereUniqueInput | im_recipeWhereUniqueInput[]
    delete?: im_recipeWhereUniqueInput | im_recipeWhereUniqueInput[]
    connect?: im_recipeWhereUniqueInput | im_recipeWhereUniqueInput[]
    update?: im_recipeUpdateWithWhereUniqueWithoutIm_foodInput | im_recipeUpdateWithWhereUniqueWithoutIm_foodInput[]
    updateMany?: im_recipeUpdateManyWithWhereWithoutIm_foodInput | im_recipeUpdateManyWithWhereWithoutIm_foodInput[]
    deleteMany?: im_recipeScalarWhereInput | im_recipeScalarWhereInput[]
  }

  export type im_undesirable_foodUncheckedUpdateManyWithoutIm_foodNestedInput = {
    create?: XOR<im_undesirable_foodCreateWithoutIm_foodInput, im_undesirable_foodUncheckedCreateWithoutIm_foodInput> | im_undesirable_foodCreateWithoutIm_foodInput[] | im_undesirable_foodUncheckedCreateWithoutIm_foodInput[]
    connectOrCreate?: im_undesirable_foodCreateOrConnectWithoutIm_foodInput | im_undesirable_foodCreateOrConnectWithoutIm_foodInput[]
    upsert?: im_undesirable_foodUpsertWithWhereUniqueWithoutIm_foodInput | im_undesirable_foodUpsertWithWhereUniqueWithoutIm_foodInput[]
    createMany?: im_undesirable_foodCreateManyIm_foodInputEnvelope
    set?: im_undesirable_foodWhereUniqueInput | im_undesirable_foodWhereUniqueInput[]
    disconnect?: im_undesirable_foodWhereUniqueInput | im_undesirable_foodWhereUniqueInput[]
    delete?: im_undesirable_foodWhereUniqueInput | im_undesirable_foodWhereUniqueInput[]
    connect?: im_undesirable_foodWhereUniqueInput | im_undesirable_foodWhereUniqueInput[]
    update?: im_undesirable_foodUpdateWithWhereUniqueWithoutIm_foodInput | im_undesirable_foodUpdateWithWhereUniqueWithoutIm_foodInput[]
    updateMany?: im_undesirable_foodUpdateManyWithWhereWithoutIm_foodInput | im_undesirable_foodUpdateManyWithWhereWithoutIm_foodInput[]
    deleteMany?: im_undesirable_foodScalarWhereInput | im_undesirable_foodScalarWhereInput[]
  }

  export type im_userCreateNestedOneWithoutIm_healthInput = {
    create?: XOR<im_userCreateWithoutIm_healthInput, im_userUncheckedCreateWithoutIm_healthInput>
    connectOrCreate?: im_userCreateOrConnectWithoutIm_healthInput
    connect?: im_userWhereUniqueInput
  }

  export type im_health_goalCreateNestedManyWithoutIm_healthInput = {
    create?: XOR<im_health_goalCreateWithoutIm_healthInput, im_health_goalUncheckedCreateWithoutIm_healthInput> | im_health_goalCreateWithoutIm_healthInput[] | im_health_goalUncheckedCreateWithoutIm_healthInput[]
    connectOrCreate?: im_health_goalCreateOrConnectWithoutIm_healthInput | im_health_goalCreateOrConnectWithoutIm_healthInput[]
    createMany?: im_health_goalCreateManyIm_healthInputEnvelope
    connect?: im_health_goalWhereUniqueInput | im_health_goalWhereUniqueInput[]
  }

  export type im_health_goalUncheckedCreateNestedManyWithoutIm_healthInput = {
    create?: XOR<im_health_goalCreateWithoutIm_healthInput, im_health_goalUncheckedCreateWithoutIm_healthInput> | im_health_goalCreateWithoutIm_healthInput[] | im_health_goalUncheckedCreateWithoutIm_healthInput[]
    connectOrCreate?: im_health_goalCreateOrConnectWithoutIm_healthInput | im_health_goalCreateOrConnectWithoutIm_healthInput[]
    createMany?: im_health_goalCreateManyIm_healthInputEnvelope
    connect?: im_health_goalWhereUniqueInput | im_health_goalWhereUniqueInput[]
  }

  export type im_userUpdateOneRequiredWithoutIm_healthNestedInput = {
    create?: XOR<im_userCreateWithoutIm_healthInput, im_userUncheckedCreateWithoutIm_healthInput>
    connectOrCreate?: im_userCreateOrConnectWithoutIm_healthInput
    upsert?: im_userUpsertWithoutIm_healthInput
    connect?: im_userWhereUniqueInput
    update?: XOR<XOR<im_userUpdateToOneWithWhereWithoutIm_healthInput, im_userUpdateWithoutIm_healthInput>, im_userUncheckedUpdateWithoutIm_healthInput>
  }

  export type im_health_goalUpdateManyWithoutIm_healthNestedInput = {
    create?: XOR<im_health_goalCreateWithoutIm_healthInput, im_health_goalUncheckedCreateWithoutIm_healthInput> | im_health_goalCreateWithoutIm_healthInput[] | im_health_goalUncheckedCreateWithoutIm_healthInput[]
    connectOrCreate?: im_health_goalCreateOrConnectWithoutIm_healthInput | im_health_goalCreateOrConnectWithoutIm_healthInput[]
    upsert?: im_health_goalUpsertWithWhereUniqueWithoutIm_healthInput | im_health_goalUpsertWithWhereUniqueWithoutIm_healthInput[]
    createMany?: im_health_goalCreateManyIm_healthInputEnvelope
    set?: im_health_goalWhereUniqueInput | im_health_goalWhereUniqueInput[]
    disconnect?: im_health_goalWhereUniqueInput | im_health_goalWhereUniqueInput[]
    delete?: im_health_goalWhereUniqueInput | im_health_goalWhereUniqueInput[]
    connect?: im_health_goalWhereUniqueInput | im_health_goalWhereUniqueInput[]
    update?: im_health_goalUpdateWithWhereUniqueWithoutIm_healthInput | im_health_goalUpdateWithWhereUniqueWithoutIm_healthInput[]
    updateMany?: im_health_goalUpdateManyWithWhereWithoutIm_healthInput | im_health_goalUpdateManyWithWhereWithoutIm_healthInput[]
    deleteMany?: im_health_goalScalarWhereInput | im_health_goalScalarWhereInput[]
  }

  export type im_health_goalUncheckedUpdateManyWithoutIm_healthNestedInput = {
    create?: XOR<im_health_goalCreateWithoutIm_healthInput, im_health_goalUncheckedCreateWithoutIm_healthInput> | im_health_goalCreateWithoutIm_healthInput[] | im_health_goalUncheckedCreateWithoutIm_healthInput[]
    connectOrCreate?: im_health_goalCreateOrConnectWithoutIm_healthInput | im_health_goalCreateOrConnectWithoutIm_healthInput[]
    upsert?: im_health_goalUpsertWithWhereUniqueWithoutIm_healthInput | im_health_goalUpsertWithWhereUniqueWithoutIm_healthInput[]
    createMany?: im_health_goalCreateManyIm_healthInputEnvelope
    set?: im_health_goalWhereUniqueInput | im_health_goalWhereUniqueInput[]
    disconnect?: im_health_goalWhereUniqueInput | im_health_goalWhereUniqueInput[]
    delete?: im_health_goalWhereUniqueInput | im_health_goalWhereUniqueInput[]
    connect?: im_health_goalWhereUniqueInput | im_health_goalWhereUniqueInput[]
    update?: im_health_goalUpdateWithWhereUniqueWithoutIm_healthInput | im_health_goalUpdateWithWhereUniqueWithoutIm_healthInput[]
    updateMany?: im_health_goalUpdateManyWithWhereWithoutIm_healthInput | im_health_goalUpdateManyWithWhereWithoutIm_healthInput[]
    deleteMany?: im_health_goalScalarWhereInput | im_health_goalScalarWhereInput[]
  }

  export type im_healthCreateNestedOneWithoutIm_health_goalInput = {
    create?: XOR<im_healthCreateWithoutIm_health_goalInput, im_healthUncheckedCreateWithoutIm_health_goalInput>
    connectOrCreate?: im_healthCreateOrConnectWithoutIm_health_goalInput
    connect?: im_healthWhereUniqueInput
  }

  export type im_health_goal_dailyCreateNestedManyWithoutIm_health_goalInput = {
    create?: XOR<im_health_goal_dailyCreateWithoutIm_health_goalInput, im_health_goal_dailyUncheckedCreateWithoutIm_health_goalInput> | im_health_goal_dailyCreateWithoutIm_health_goalInput[] | im_health_goal_dailyUncheckedCreateWithoutIm_health_goalInput[]
    connectOrCreate?: im_health_goal_dailyCreateOrConnectWithoutIm_health_goalInput | im_health_goal_dailyCreateOrConnectWithoutIm_health_goalInput[]
    createMany?: im_health_goal_dailyCreateManyIm_health_goalInputEnvelope
    connect?: im_health_goal_dailyWhereUniqueInput | im_health_goal_dailyWhereUniqueInput[]
  }

  export type im_health_goal_dailyUncheckedCreateNestedManyWithoutIm_health_goalInput = {
    create?: XOR<im_health_goal_dailyCreateWithoutIm_health_goalInput, im_health_goal_dailyUncheckedCreateWithoutIm_health_goalInput> | im_health_goal_dailyCreateWithoutIm_health_goalInput[] | im_health_goal_dailyUncheckedCreateWithoutIm_health_goalInput[]
    connectOrCreate?: im_health_goal_dailyCreateOrConnectWithoutIm_health_goalInput | im_health_goal_dailyCreateOrConnectWithoutIm_health_goalInput[]
    createMany?: im_health_goal_dailyCreateManyIm_health_goalInputEnvelope
    connect?: im_health_goal_dailyWhereUniqueInput | im_health_goal_dailyWhereUniqueInput[]
  }

  export type im_healthUpdateOneRequiredWithoutIm_health_goalNestedInput = {
    create?: XOR<im_healthCreateWithoutIm_health_goalInput, im_healthUncheckedCreateWithoutIm_health_goalInput>
    connectOrCreate?: im_healthCreateOrConnectWithoutIm_health_goalInput
    upsert?: im_healthUpsertWithoutIm_health_goalInput
    connect?: im_healthWhereUniqueInput
    update?: XOR<XOR<im_healthUpdateToOneWithWhereWithoutIm_health_goalInput, im_healthUpdateWithoutIm_health_goalInput>, im_healthUncheckedUpdateWithoutIm_health_goalInput>
  }

  export type im_health_goal_dailyUpdateManyWithoutIm_health_goalNestedInput = {
    create?: XOR<im_health_goal_dailyCreateWithoutIm_health_goalInput, im_health_goal_dailyUncheckedCreateWithoutIm_health_goalInput> | im_health_goal_dailyCreateWithoutIm_health_goalInput[] | im_health_goal_dailyUncheckedCreateWithoutIm_health_goalInput[]
    connectOrCreate?: im_health_goal_dailyCreateOrConnectWithoutIm_health_goalInput | im_health_goal_dailyCreateOrConnectWithoutIm_health_goalInput[]
    upsert?: im_health_goal_dailyUpsertWithWhereUniqueWithoutIm_health_goalInput | im_health_goal_dailyUpsertWithWhereUniqueWithoutIm_health_goalInput[]
    createMany?: im_health_goal_dailyCreateManyIm_health_goalInputEnvelope
    set?: im_health_goal_dailyWhereUniqueInput | im_health_goal_dailyWhereUniqueInput[]
    disconnect?: im_health_goal_dailyWhereUniqueInput | im_health_goal_dailyWhereUniqueInput[]
    delete?: im_health_goal_dailyWhereUniqueInput | im_health_goal_dailyWhereUniqueInput[]
    connect?: im_health_goal_dailyWhereUniqueInput | im_health_goal_dailyWhereUniqueInput[]
    update?: im_health_goal_dailyUpdateWithWhereUniqueWithoutIm_health_goalInput | im_health_goal_dailyUpdateWithWhereUniqueWithoutIm_health_goalInput[]
    updateMany?: im_health_goal_dailyUpdateManyWithWhereWithoutIm_health_goalInput | im_health_goal_dailyUpdateManyWithWhereWithoutIm_health_goalInput[]
    deleteMany?: im_health_goal_dailyScalarWhereInput | im_health_goal_dailyScalarWhereInput[]
  }

  export type im_health_goal_dailyUncheckedUpdateManyWithoutIm_health_goalNestedInput = {
    create?: XOR<im_health_goal_dailyCreateWithoutIm_health_goalInput, im_health_goal_dailyUncheckedCreateWithoutIm_health_goalInput> | im_health_goal_dailyCreateWithoutIm_health_goalInput[] | im_health_goal_dailyUncheckedCreateWithoutIm_health_goalInput[]
    connectOrCreate?: im_health_goal_dailyCreateOrConnectWithoutIm_health_goalInput | im_health_goal_dailyCreateOrConnectWithoutIm_health_goalInput[]
    upsert?: im_health_goal_dailyUpsertWithWhereUniqueWithoutIm_health_goalInput | im_health_goal_dailyUpsertWithWhereUniqueWithoutIm_health_goalInput[]
    createMany?: im_health_goal_dailyCreateManyIm_health_goalInputEnvelope
    set?: im_health_goal_dailyWhereUniqueInput | im_health_goal_dailyWhereUniqueInput[]
    disconnect?: im_health_goal_dailyWhereUniqueInput | im_health_goal_dailyWhereUniqueInput[]
    delete?: im_health_goal_dailyWhereUniqueInput | im_health_goal_dailyWhereUniqueInput[]
    connect?: im_health_goal_dailyWhereUniqueInput | im_health_goal_dailyWhereUniqueInput[]
    update?: im_health_goal_dailyUpdateWithWhereUniqueWithoutIm_health_goalInput | im_health_goal_dailyUpdateWithWhereUniqueWithoutIm_health_goalInput[]
    updateMany?: im_health_goal_dailyUpdateManyWithWhereWithoutIm_health_goalInput | im_health_goal_dailyUpdateManyWithWhereWithoutIm_health_goalInput[]
    deleteMany?: im_health_goal_dailyScalarWhereInput | im_health_goal_dailyScalarWhereInput[]
  }

  export type im_health_goalCreateNestedOneWithoutIm_health_goal_dailyInput = {
    create?: XOR<im_health_goalCreateWithoutIm_health_goal_dailyInput, im_health_goalUncheckedCreateWithoutIm_health_goal_dailyInput>
    connectOrCreate?: im_health_goalCreateOrConnectWithoutIm_health_goal_dailyInput
    connect?: im_health_goalWhereUniqueInput
  }

  export type im_health_goal_daily_historyCreateNestedManyWithoutIm_health_goal_dailyInput = {
    create?: XOR<im_health_goal_daily_historyCreateWithoutIm_health_goal_dailyInput, im_health_goal_daily_historyUncheckedCreateWithoutIm_health_goal_dailyInput> | im_health_goal_daily_historyCreateWithoutIm_health_goal_dailyInput[] | im_health_goal_daily_historyUncheckedCreateWithoutIm_health_goal_dailyInput[]
    connectOrCreate?: im_health_goal_daily_historyCreateOrConnectWithoutIm_health_goal_dailyInput | im_health_goal_daily_historyCreateOrConnectWithoutIm_health_goal_dailyInput[]
    createMany?: im_health_goal_daily_historyCreateManyIm_health_goal_dailyInputEnvelope
    connect?: im_health_goal_daily_historyWhereUniqueInput | im_health_goal_daily_historyWhereUniqueInput[]
  }

  export type im_health_goal_daily_historyUncheckedCreateNestedManyWithoutIm_health_goal_dailyInput = {
    create?: XOR<im_health_goal_daily_historyCreateWithoutIm_health_goal_dailyInput, im_health_goal_daily_historyUncheckedCreateWithoutIm_health_goal_dailyInput> | im_health_goal_daily_historyCreateWithoutIm_health_goal_dailyInput[] | im_health_goal_daily_historyUncheckedCreateWithoutIm_health_goal_dailyInput[]
    connectOrCreate?: im_health_goal_daily_historyCreateOrConnectWithoutIm_health_goal_dailyInput | im_health_goal_daily_historyCreateOrConnectWithoutIm_health_goal_dailyInput[]
    createMany?: im_health_goal_daily_historyCreateManyIm_health_goal_dailyInputEnvelope
    connect?: im_health_goal_daily_historyWhereUniqueInput | im_health_goal_daily_historyWhereUniqueInput[]
  }

  export type im_health_goalUpdateOneRequiredWithoutIm_health_goal_dailyNestedInput = {
    create?: XOR<im_health_goalCreateWithoutIm_health_goal_dailyInput, im_health_goalUncheckedCreateWithoutIm_health_goal_dailyInput>
    connectOrCreate?: im_health_goalCreateOrConnectWithoutIm_health_goal_dailyInput
    upsert?: im_health_goalUpsertWithoutIm_health_goal_dailyInput
    connect?: im_health_goalWhereUniqueInput
    update?: XOR<XOR<im_health_goalUpdateToOneWithWhereWithoutIm_health_goal_dailyInput, im_health_goalUpdateWithoutIm_health_goal_dailyInput>, im_health_goalUncheckedUpdateWithoutIm_health_goal_dailyInput>
  }

  export type im_health_goal_daily_historyUpdateManyWithoutIm_health_goal_dailyNestedInput = {
    create?: XOR<im_health_goal_daily_historyCreateWithoutIm_health_goal_dailyInput, im_health_goal_daily_historyUncheckedCreateWithoutIm_health_goal_dailyInput> | im_health_goal_daily_historyCreateWithoutIm_health_goal_dailyInput[] | im_health_goal_daily_historyUncheckedCreateWithoutIm_health_goal_dailyInput[]
    connectOrCreate?: im_health_goal_daily_historyCreateOrConnectWithoutIm_health_goal_dailyInput | im_health_goal_daily_historyCreateOrConnectWithoutIm_health_goal_dailyInput[]
    upsert?: im_health_goal_daily_historyUpsertWithWhereUniqueWithoutIm_health_goal_dailyInput | im_health_goal_daily_historyUpsertWithWhereUniqueWithoutIm_health_goal_dailyInput[]
    createMany?: im_health_goal_daily_historyCreateManyIm_health_goal_dailyInputEnvelope
    set?: im_health_goal_daily_historyWhereUniqueInput | im_health_goal_daily_historyWhereUniqueInput[]
    disconnect?: im_health_goal_daily_historyWhereUniqueInput | im_health_goal_daily_historyWhereUniqueInput[]
    delete?: im_health_goal_daily_historyWhereUniqueInput | im_health_goal_daily_historyWhereUniqueInput[]
    connect?: im_health_goal_daily_historyWhereUniqueInput | im_health_goal_daily_historyWhereUniqueInput[]
    update?: im_health_goal_daily_historyUpdateWithWhereUniqueWithoutIm_health_goal_dailyInput | im_health_goal_daily_historyUpdateWithWhereUniqueWithoutIm_health_goal_dailyInput[]
    updateMany?: im_health_goal_daily_historyUpdateManyWithWhereWithoutIm_health_goal_dailyInput | im_health_goal_daily_historyUpdateManyWithWhereWithoutIm_health_goal_dailyInput[]
    deleteMany?: im_health_goal_daily_historyScalarWhereInput | im_health_goal_daily_historyScalarWhereInput[]
  }

  export type im_health_goal_daily_historyUncheckedUpdateManyWithoutIm_health_goal_dailyNestedInput = {
    create?: XOR<im_health_goal_daily_historyCreateWithoutIm_health_goal_dailyInput, im_health_goal_daily_historyUncheckedCreateWithoutIm_health_goal_dailyInput> | im_health_goal_daily_historyCreateWithoutIm_health_goal_dailyInput[] | im_health_goal_daily_historyUncheckedCreateWithoutIm_health_goal_dailyInput[]
    connectOrCreate?: im_health_goal_daily_historyCreateOrConnectWithoutIm_health_goal_dailyInput | im_health_goal_daily_historyCreateOrConnectWithoutIm_health_goal_dailyInput[]
    upsert?: im_health_goal_daily_historyUpsertWithWhereUniqueWithoutIm_health_goal_dailyInput | im_health_goal_daily_historyUpsertWithWhereUniqueWithoutIm_health_goal_dailyInput[]
    createMany?: im_health_goal_daily_historyCreateManyIm_health_goal_dailyInputEnvelope
    set?: im_health_goal_daily_historyWhereUniqueInput | im_health_goal_daily_historyWhereUniqueInput[]
    disconnect?: im_health_goal_daily_historyWhereUniqueInput | im_health_goal_daily_historyWhereUniqueInput[]
    delete?: im_health_goal_daily_historyWhereUniqueInput | im_health_goal_daily_historyWhereUniqueInput[]
    connect?: im_health_goal_daily_historyWhereUniqueInput | im_health_goal_daily_historyWhereUniqueInput[]
    update?: im_health_goal_daily_historyUpdateWithWhereUniqueWithoutIm_health_goal_dailyInput | im_health_goal_daily_historyUpdateWithWhereUniqueWithoutIm_health_goal_dailyInput[]
    updateMany?: im_health_goal_daily_historyUpdateManyWithWhereWithoutIm_health_goal_dailyInput | im_health_goal_daily_historyUpdateManyWithWhereWithoutIm_health_goal_dailyInput[]
    deleteMany?: im_health_goal_daily_historyScalarWhereInput | im_health_goal_daily_historyScalarWhereInput[]
  }

  export type im_health_goal_dailyCreateNestedOneWithoutIm_health_goal_daily_historyInput = {
    create?: XOR<im_health_goal_dailyCreateWithoutIm_health_goal_daily_historyInput, im_health_goal_dailyUncheckedCreateWithoutIm_health_goal_daily_historyInput>
    connectOrCreate?: im_health_goal_dailyCreateOrConnectWithoutIm_health_goal_daily_historyInput
    connect?: im_health_goal_dailyWhereUniqueInput
  }

  export type im_health_goal_dailyUpdateOneRequiredWithoutIm_health_goal_daily_historyNestedInput = {
    create?: XOR<im_health_goal_dailyCreateWithoutIm_health_goal_daily_historyInput, im_health_goal_dailyUncheckedCreateWithoutIm_health_goal_daily_historyInput>
    connectOrCreate?: im_health_goal_dailyCreateOrConnectWithoutIm_health_goal_daily_historyInput
    upsert?: im_health_goal_dailyUpsertWithoutIm_health_goal_daily_historyInput
    connect?: im_health_goal_dailyWhereUniqueInput
    update?: XOR<XOR<im_health_goal_dailyUpdateToOneWithWhereWithoutIm_health_goal_daily_historyInput, im_health_goal_dailyUpdateWithoutIm_health_goal_daily_historyInput>, im_health_goal_dailyUncheckedUpdateWithoutIm_health_goal_daily_historyInput>
  }

  export type im_nutritionCreateNestedOneWithoutIm_mealInput = {
    create?: XOR<im_nutritionCreateWithoutIm_mealInput, im_nutritionUncheckedCreateWithoutIm_mealInput>
    connectOrCreate?: im_nutritionCreateOrConnectWithoutIm_mealInput
    connect?: im_nutritionWhereUniqueInput
  }

  export type im_recipeCreateNestedManyWithoutIm_mealInput = {
    create?: XOR<im_recipeCreateWithoutIm_mealInput, im_recipeUncheckedCreateWithoutIm_mealInput> | im_recipeCreateWithoutIm_mealInput[] | im_recipeUncheckedCreateWithoutIm_mealInput[]
    connectOrCreate?: im_recipeCreateOrConnectWithoutIm_mealInput | im_recipeCreateOrConnectWithoutIm_mealInput[]
    createMany?: im_recipeCreateManyIm_mealInputEnvelope
    connect?: im_recipeWhereUniqueInput | im_recipeWhereUniqueInput[]
  }

  export type im_recipeUncheckedCreateNestedManyWithoutIm_mealInput = {
    create?: XOR<im_recipeCreateWithoutIm_mealInput, im_recipeUncheckedCreateWithoutIm_mealInput> | im_recipeCreateWithoutIm_mealInput[] | im_recipeUncheckedCreateWithoutIm_mealInput[]
    connectOrCreate?: im_recipeCreateOrConnectWithoutIm_mealInput | im_recipeCreateOrConnectWithoutIm_mealInput[]
    createMany?: im_recipeCreateManyIm_mealInputEnvelope
    connect?: im_recipeWhereUniqueInput | im_recipeWhereUniqueInput[]
  }

  export type im_nutritionUpdateOneRequiredWithoutIm_mealNestedInput = {
    create?: XOR<im_nutritionCreateWithoutIm_mealInput, im_nutritionUncheckedCreateWithoutIm_mealInput>
    connectOrCreate?: im_nutritionCreateOrConnectWithoutIm_mealInput
    upsert?: im_nutritionUpsertWithoutIm_mealInput
    connect?: im_nutritionWhereUniqueInput
    update?: XOR<XOR<im_nutritionUpdateToOneWithWhereWithoutIm_mealInput, im_nutritionUpdateWithoutIm_mealInput>, im_nutritionUncheckedUpdateWithoutIm_mealInput>
  }

  export type im_recipeUpdateManyWithoutIm_mealNestedInput = {
    create?: XOR<im_recipeCreateWithoutIm_mealInput, im_recipeUncheckedCreateWithoutIm_mealInput> | im_recipeCreateWithoutIm_mealInput[] | im_recipeUncheckedCreateWithoutIm_mealInput[]
    connectOrCreate?: im_recipeCreateOrConnectWithoutIm_mealInput | im_recipeCreateOrConnectWithoutIm_mealInput[]
    upsert?: im_recipeUpsertWithWhereUniqueWithoutIm_mealInput | im_recipeUpsertWithWhereUniqueWithoutIm_mealInput[]
    createMany?: im_recipeCreateManyIm_mealInputEnvelope
    set?: im_recipeWhereUniqueInput | im_recipeWhereUniqueInput[]
    disconnect?: im_recipeWhereUniqueInput | im_recipeWhereUniqueInput[]
    delete?: im_recipeWhereUniqueInput | im_recipeWhereUniqueInput[]
    connect?: im_recipeWhereUniqueInput | im_recipeWhereUniqueInput[]
    update?: im_recipeUpdateWithWhereUniqueWithoutIm_mealInput | im_recipeUpdateWithWhereUniqueWithoutIm_mealInput[]
    updateMany?: im_recipeUpdateManyWithWhereWithoutIm_mealInput | im_recipeUpdateManyWithWhereWithoutIm_mealInput[]
    deleteMany?: im_recipeScalarWhereInput | im_recipeScalarWhereInput[]
  }

  export type im_recipeUncheckedUpdateManyWithoutIm_mealNestedInput = {
    create?: XOR<im_recipeCreateWithoutIm_mealInput, im_recipeUncheckedCreateWithoutIm_mealInput> | im_recipeCreateWithoutIm_mealInput[] | im_recipeUncheckedCreateWithoutIm_mealInput[]
    connectOrCreate?: im_recipeCreateOrConnectWithoutIm_mealInput | im_recipeCreateOrConnectWithoutIm_mealInput[]
    upsert?: im_recipeUpsertWithWhereUniqueWithoutIm_mealInput | im_recipeUpsertWithWhereUniqueWithoutIm_mealInput[]
    createMany?: im_recipeCreateManyIm_mealInputEnvelope
    set?: im_recipeWhereUniqueInput | im_recipeWhereUniqueInput[]
    disconnect?: im_recipeWhereUniqueInput | im_recipeWhereUniqueInput[]
    delete?: im_recipeWhereUniqueInput | im_recipeWhereUniqueInput[]
    connect?: im_recipeWhereUniqueInput | im_recipeWhereUniqueInput[]
    update?: im_recipeUpdateWithWhereUniqueWithoutIm_mealInput | im_recipeUpdateWithWhereUniqueWithoutIm_mealInput[]
    updateMany?: im_recipeUpdateManyWithWhereWithoutIm_mealInput | im_recipeUpdateManyWithWhereWithoutIm_mealInput[]
    deleteMany?: im_recipeScalarWhereInput | im_recipeScalarWhereInput[]
  }

  export type im_mealCreateNestedManyWithoutIm_nutritionInput = {
    create?: XOR<im_mealCreateWithoutIm_nutritionInput, im_mealUncheckedCreateWithoutIm_nutritionInput> | im_mealCreateWithoutIm_nutritionInput[] | im_mealUncheckedCreateWithoutIm_nutritionInput[]
    connectOrCreate?: im_mealCreateOrConnectWithoutIm_nutritionInput | im_mealCreateOrConnectWithoutIm_nutritionInput[]
    createMany?: im_mealCreateManyIm_nutritionInputEnvelope
    connect?: im_mealWhereUniqueInput | im_mealWhereUniqueInput[]
  }

  export type im_userCreateNestedOneWithoutIm_nutritionInput = {
    create?: XOR<im_userCreateWithoutIm_nutritionInput, im_userUncheckedCreateWithoutIm_nutritionInput>
    connectOrCreate?: im_userCreateOrConnectWithoutIm_nutritionInput
    connect?: im_userWhereUniqueInput
  }

  export type im_mealUncheckedCreateNestedManyWithoutIm_nutritionInput = {
    create?: XOR<im_mealCreateWithoutIm_nutritionInput, im_mealUncheckedCreateWithoutIm_nutritionInput> | im_mealCreateWithoutIm_nutritionInput[] | im_mealUncheckedCreateWithoutIm_nutritionInput[]
    connectOrCreate?: im_mealCreateOrConnectWithoutIm_nutritionInput | im_mealCreateOrConnectWithoutIm_nutritionInput[]
    createMany?: im_mealCreateManyIm_nutritionInputEnvelope
    connect?: im_mealWhereUniqueInput | im_mealWhereUniqueInput[]
  }

  export type im_mealUpdateManyWithoutIm_nutritionNestedInput = {
    create?: XOR<im_mealCreateWithoutIm_nutritionInput, im_mealUncheckedCreateWithoutIm_nutritionInput> | im_mealCreateWithoutIm_nutritionInput[] | im_mealUncheckedCreateWithoutIm_nutritionInput[]
    connectOrCreate?: im_mealCreateOrConnectWithoutIm_nutritionInput | im_mealCreateOrConnectWithoutIm_nutritionInput[]
    upsert?: im_mealUpsertWithWhereUniqueWithoutIm_nutritionInput | im_mealUpsertWithWhereUniqueWithoutIm_nutritionInput[]
    createMany?: im_mealCreateManyIm_nutritionInputEnvelope
    set?: im_mealWhereUniqueInput | im_mealWhereUniqueInput[]
    disconnect?: im_mealWhereUniqueInput | im_mealWhereUniqueInput[]
    delete?: im_mealWhereUniqueInput | im_mealWhereUniqueInput[]
    connect?: im_mealWhereUniqueInput | im_mealWhereUniqueInput[]
    update?: im_mealUpdateWithWhereUniqueWithoutIm_nutritionInput | im_mealUpdateWithWhereUniqueWithoutIm_nutritionInput[]
    updateMany?: im_mealUpdateManyWithWhereWithoutIm_nutritionInput | im_mealUpdateManyWithWhereWithoutIm_nutritionInput[]
    deleteMany?: im_mealScalarWhereInput | im_mealScalarWhereInput[]
  }

  export type im_userUpdateOneRequiredWithoutIm_nutritionNestedInput = {
    create?: XOR<im_userCreateWithoutIm_nutritionInput, im_userUncheckedCreateWithoutIm_nutritionInput>
    connectOrCreate?: im_userCreateOrConnectWithoutIm_nutritionInput
    upsert?: im_userUpsertWithoutIm_nutritionInput
    connect?: im_userWhereUniqueInput
    update?: XOR<XOR<im_userUpdateToOneWithWhereWithoutIm_nutritionInput, im_userUpdateWithoutIm_nutritionInput>, im_userUncheckedUpdateWithoutIm_nutritionInput>
  }

  export type im_mealUncheckedUpdateManyWithoutIm_nutritionNestedInput = {
    create?: XOR<im_mealCreateWithoutIm_nutritionInput, im_mealUncheckedCreateWithoutIm_nutritionInput> | im_mealCreateWithoutIm_nutritionInput[] | im_mealUncheckedCreateWithoutIm_nutritionInput[]
    connectOrCreate?: im_mealCreateOrConnectWithoutIm_nutritionInput | im_mealCreateOrConnectWithoutIm_nutritionInput[]
    upsert?: im_mealUpsertWithWhereUniqueWithoutIm_nutritionInput | im_mealUpsertWithWhereUniqueWithoutIm_nutritionInput[]
    createMany?: im_mealCreateManyIm_nutritionInputEnvelope
    set?: im_mealWhereUniqueInput | im_mealWhereUniqueInput[]
    disconnect?: im_mealWhereUniqueInput | im_mealWhereUniqueInput[]
    delete?: im_mealWhereUniqueInput | im_mealWhereUniqueInput[]
    connect?: im_mealWhereUniqueInput | im_mealWhereUniqueInput[]
    update?: im_mealUpdateWithWhereUniqueWithoutIm_nutritionInput | im_mealUpdateWithWhereUniqueWithoutIm_nutritionInput[]
    updateMany?: im_mealUpdateManyWithWhereWithoutIm_nutritionInput | im_mealUpdateManyWithWhereWithoutIm_nutritionInput[]
    deleteMany?: im_mealScalarWhereInput | im_mealScalarWhereInput[]
  }

  export type im_mealCreateNestedOneWithoutIm_recipeInput = {
    create?: XOR<im_mealCreateWithoutIm_recipeInput, im_mealUncheckedCreateWithoutIm_recipeInput>
    connectOrCreate?: im_mealCreateOrConnectWithoutIm_recipeInput
    connect?: im_mealWhereUniqueInput
  }

  export type im_foodCreateNestedOneWithoutIm_recipeInput = {
    create?: XOR<im_foodCreateWithoutIm_recipeInput, im_foodUncheckedCreateWithoutIm_recipeInput>
    connectOrCreate?: im_foodCreateOrConnectWithoutIm_recipeInput
    connect?: im_foodWhereUniqueInput
  }

  export type im_mealUpdateOneRequiredWithoutIm_recipeNestedInput = {
    create?: XOR<im_mealCreateWithoutIm_recipeInput, im_mealUncheckedCreateWithoutIm_recipeInput>
    connectOrCreate?: im_mealCreateOrConnectWithoutIm_recipeInput
    upsert?: im_mealUpsertWithoutIm_recipeInput
    connect?: im_mealWhereUniqueInput
    update?: XOR<XOR<im_mealUpdateToOneWithWhereWithoutIm_recipeInput, im_mealUpdateWithoutIm_recipeInput>, im_mealUncheckedUpdateWithoutIm_recipeInput>
  }

  export type im_foodUpdateOneRequiredWithoutIm_recipeNestedInput = {
    create?: XOR<im_foodCreateWithoutIm_recipeInput, im_foodUncheckedCreateWithoutIm_recipeInput>
    connectOrCreate?: im_foodCreateOrConnectWithoutIm_recipeInput
    upsert?: im_foodUpsertWithoutIm_recipeInput
    connect?: im_foodWhereUniqueInput
    update?: XOR<XOR<im_foodUpdateToOneWithWhereWithoutIm_recipeInput, im_foodUpdateWithoutIm_recipeInput>, im_foodUncheckedUpdateWithoutIm_recipeInput>
  }

  export type im_userCreateNestedOneWithoutIm_trainingInput = {
    create?: XOR<im_userCreateWithoutIm_trainingInput, im_userUncheckedCreateWithoutIm_trainingInput>
    connectOrCreate?: im_userCreateOrConnectWithoutIm_trainingInput
    connect?: im_userWhereUniqueInput
  }

  export type im_workoutCreateNestedManyWithoutIm_trainingInput = {
    create?: XOR<im_workoutCreateWithoutIm_trainingInput, im_workoutUncheckedCreateWithoutIm_trainingInput> | im_workoutCreateWithoutIm_trainingInput[] | im_workoutUncheckedCreateWithoutIm_trainingInput[]
    connectOrCreate?: im_workoutCreateOrConnectWithoutIm_trainingInput | im_workoutCreateOrConnectWithoutIm_trainingInput[]
    createMany?: im_workoutCreateManyIm_trainingInputEnvelope
    connect?: im_workoutWhereUniqueInput | im_workoutWhereUniqueInput[]
  }

  export type im_workoutUncheckedCreateNestedManyWithoutIm_trainingInput = {
    create?: XOR<im_workoutCreateWithoutIm_trainingInput, im_workoutUncheckedCreateWithoutIm_trainingInput> | im_workoutCreateWithoutIm_trainingInput[] | im_workoutUncheckedCreateWithoutIm_trainingInput[]
    connectOrCreate?: im_workoutCreateOrConnectWithoutIm_trainingInput | im_workoutCreateOrConnectWithoutIm_trainingInput[]
    createMany?: im_workoutCreateManyIm_trainingInputEnvelope
    connect?: im_workoutWhereUniqueInput | im_workoutWhereUniqueInput[]
  }

  export type im_userUpdateOneRequiredWithoutIm_trainingNestedInput = {
    create?: XOR<im_userCreateWithoutIm_trainingInput, im_userUncheckedCreateWithoutIm_trainingInput>
    connectOrCreate?: im_userCreateOrConnectWithoutIm_trainingInput
    upsert?: im_userUpsertWithoutIm_trainingInput
    connect?: im_userWhereUniqueInput
    update?: XOR<XOR<im_userUpdateToOneWithWhereWithoutIm_trainingInput, im_userUpdateWithoutIm_trainingInput>, im_userUncheckedUpdateWithoutIm_trainingInput>
  }

  export type im_workoutUpdateManyWithoutIm_trainingNestedInput = {
    create?: XOR<im_workoutCreateWithoutIm_trainingInput, im_workoutUncheckedCreateWithoutIm_trainingInput> | im_workoutCreateWithoutIm_trainingInput[] | im_workoutUncheckedCreateWithoutIm_trainingInput[]
    connectOrCreate?: im_workoutCreateOrConnectWithoutIm_trainingInput | im_workoutCreateOrConnectWithoutIm_trainingInput[]
    upsert?: im_workoutUpsertWithWhereUniqueWithoutIm_trainingInput | im_workoutUpsertWithWhereUniqueWithoutIm_trainingInput[]
    createMany?: im_workoutCreateManyIm_trainingInputEnvelope
    set?: im_workoutWhereUniqueInput | im_workoutWhereUniqueInput[]
    disconnect?: im_workoutWhereUniqueInput | im_workoutWhereUniqueInput[]
    delete?: im_workoutWhereUniqueInput | im_workoutWhereUniqueInput[]
    connect?: im_workoutWhereUniqueInput | im_workoutWhereUniqueInput[]
    update?: im_workoutUpdateWithWhereUniqueWithoutIm_trainingInput | im_workoutUpdateWithWhereUniqueWithoutIm_trainingInput[]
    updateMany?: im_workoutUpdateManyWithWhereWithoutIm_trainingInput | im_workoutUpdateManyWithWhereWithoutIm_trainingInput[]
    deleteMany?: im_workoutScalarWhereInput | im_workoutScalarWhereInput[]
  }

  export type im_workoutUncheckedUpdateManyWithoutIm_trainingNestedInput = {
    create?: XOR<im_workoutCreateWithoutIm_trainingInput, im_workoutUncheckedCreateWithoutIm_trainingInput> | im_workoutCreateWithoutIm_trainingInput[] | im_workoutUncheckedCreateWithoutIm_trainingInput[]
    connectOrCreate?: im_workoutCreateOrConnectWithoutIm_trainingInput | im_workoutCreateOrConnectWithoutIm_trainingInput[]
    upsert?: im_workoutUpsertWithWhereUniqueWithoutIm_trainingInput | im_workoutUpsertWithWhereUniqueWithoutIm_trainingInput[]
    createMany?: im_workoutCreateManyIm_trainingInputEnvelope
    set?: im_workoutWhereUniqueInput | im_workoutWhereUniqueInput[]
    disconnect?: im_workoutWhereUniqueInput | im_workoutWhereUniqueInput[]
    delete?: im_workoutWhereUniqueInput | im_workoutWhereUniqueInput[]
    connect?: im_workoutWhereUniqueInput | im_workoutWhereUniqueInput[]
    update?: im_workoutUpdateWithWhereUniqueWithoutIm_trainingInput | im_workoutUpdateWithWhereUniqueWithoutIm_trainingInput[]
    updateMany?: im_workoutUpdateManyWithWhereWithoutIm_trainingInput | im_workoutUpdateManyWithWhereWithoutIm_trainingInput[]
    deleteMany?: im_workoutScalarWhereInput | im_workoutScalarWhereInput[]
  }

  export type im_userCreateNestedOneWithoutIm_undesirable_foodInput = {
    create?: XOR<im_userCreateWithoutIm_undesirable_foodInput, im_userUncheckedCreateWithoutIm_undesirable_foodInput>
    connectOrCreate?: im_userCreateOrConnectWithoutIm_undesirable_foodInput
    connect?: im_userWhereUniqueInput
  }

  export type im_foodCreateNestedOneWithoutIm_undesirable_foodInput = {
    create?: XOR<im_foodCreateWithoutIm_undesirable_foodInput, im_foodUncheckedCreateWithoutIm_undesirable_foodInput>
    connectOrCreate?: im_foodCreateOrConnectWithoutIm_undesirable_foodInput
    connect?: im_foodWhereUniqueInput
  }

  export type im_userUpdateOneRequiredWithoutIm_undesirable_foodNestedInput = {
    create?: XOR<im_userCreateWithoutIm_undesirable_foodInput, im_userUncheckedCreateWithoutIm_undesirable_foodInput>
    connectOrCreate?: im_userCreateOrConnectWithoutIm_undesirable_foodInput
    upsert?: im_userUpsertWithoutIm_undesirable_foodInput
    connect?: im_userWhereUniqueInput
    update?: XOR<XOR<im_userUpdateToOneWithWhereWithoutIm_undesirable_foodInput, im_userUpdateWithoutIm_undesirable_foodInput>, im_userUncheckedUpdateWithoutIm_undesirable_foodInput>
  }

  export type im_foodUpdateOneRequiredWithoutIm_undesirable_foodNestedInput = {
    create?: XOR<im_foodCreateWithoutIm_undesirable_foodInput, im_foodUncheckedCreateWithoutIm_undesirable_foodInput>
    connectOrCreate?: im_foodCreateOrConnectWithoutIm_undesirable_foodInput
    upsert?: im_foodUpsertWithoutIm_undesirable_foodInput
    connect?: im_foodWhereUniqueInput
    update?: XOR<XOR<im_foodUpdateToOneWithWhereWithoutIm_undesirable_foodInput, im_foodUpdateWithoutIm_undesirable_foodInput>, im_foodUncheckedUpdateWithoutIm_undesirable_foodInput>
  }

  export type im_healthCreateNestedManyWithoutIm_userInput = {
    create?: XOR<im_healthCreateWithoutIm_userInput, im_healthUncheckedCreateWithoutIm_userInput> | im_healthCreateWithoutIm_userInput[] | im_healthUncheckedCreateWithoutIm_userInput[]
    connectOrCreate?: im_healthCreateOrConnectWithoutIm_userInput | im_healthCreateOrConnectWithoutIm_userInput[]
    createMany?: im_healthCreateManyIm_userInputEnvelope
    connect?: im_healthWhereUniqueInput | im_healthWhereUniqueInput[]
  }

  export type im_nutritionCreateNestedManyWithoutIm_userInput = {
    create?: XOR<im_nutritionCreateWithoutIm_userInput, im_nutritionUncheckedCreateWithoutIm_userInput> | im_nutritionCreateWithoutIm_userInput[] | im_nutritionUncheckedCreateWithoutIm_userInput[]
    connectOrCreate?: im_nutritionCreateOrConnectWithoutIm_userInput | im_nutritionCreateOrConnectWithoutIm_userInput[]
    createMany?: im_nutritionCreateManyIm_userInputEnvelope
    connect?: im_nutritionWhereUniqueInput | im_nutritionWhereUniqueInput[]
  }

  export type im_trainingCreateNestedManyWithoutIm_userInput = {
    create?: XOR<im_trainingCreateWithoutIm_userInput, im_trainingUncheckedCreateWithoutIm_userInput> | im_trainingCreateWithoutIm_userInput[] | im_trainingUncheckedCreateWithoutIm_userInput[]
    connectOrCreate?: im_trainingCreateOrConnectWithoutIm_userInput | im_trainingCreateOrConnectWithoutIm_userInput[]
    createMany?: im_trainingCreateManyIm_userInputEnvelope
    connect?: im_trainingWhereUniqueInput | im_trainingWhereUniqueInput[]
  }

  export type im_undesirable_foodCreateNestedManyWithoutIm_userInput = {
    create?: XOR<im_undesirable_foodCreateWithoutIm_userInput, im_undesirable_foodUncheckedCreateWithoutIm_userInput> | im_undesirable_foodCreateWithoutIm_userInput[] | im_undesirable_foodUncheckedCreateWithoutIm_userInput[]
    connectOrCreate?: im_undesirable_foodCreateOrConnectWithoutIm_userInput | im_undesirable_foodCreateOrConnectWithoutIm_userInput[]
    createMany?: im_undesirable_foodCreateManyIm_userInputEnvelope
    connect?: im_undesirable_foodWhereUniqueInput | im_undesirable_foodWhereUniqueInput[]
  }

  export type im_healthUncheckedCreateNestedManyWithoutIm_userInput = {
    create?: XOR<im_healthCreateWithoutIm_userInput, im_healthUncheckedCreateWithoutIm_userInput> | im_healthCreateWithoutIm_userInput[] | im_healthUncheckedCreateWithoutIm_userInput[]
    connectOrCreate?: im_healthCreateOrConnectWithoutIm_userInput | im_healthCreateOrConnectWithoutIm_userInput[]
    createMany?: im_healthCreateManyIm_userInputEnvelope
    connect?: im_healthWhereUniqueInput | im_healthWhereUniqueInput[]
  }

  export type im_nutritionUncheckedCreateNestedManyWithoutIm_userInput = {
    create?: XOR<im_nutritionCreateWithoutIm_userInput, im_nutritionUncheckedCreateWithoutIm_userInput> | im_nutritionCreateWithoutIm_userInput[] | im_nutritionUncheckedCreateWithoutIm_userInput[]
    connectOrCreate?: im_nutritionCreateOrConnectWithoutIm_userInput | im_nutritionCreateOrConnectWithoutIm_userInput[]
    createMany?: im_nutritionCreateManyIm_userInputEnvelope
    connect?: im_nutritionWhereUniqueInput | im_nutritionWhereUniqueInput[]
  }

  export type im_trainingUncheckedCreateNestedManyWithoutIm_userInput = {
    create?: XOR<im_trainingCreateWithoutIm_userInput, im_trainingUncheckedCreateWithoutIm_userInput> | im_trainingCreateWithoutIm_userInput[] | im_trainingUncheckedCreateWithoutIm_userInput[]
    connectOrCreate?: im_trainingCreateOrConnectWithoutIm_userInput | im_trainingCreateOrConnectWithoutIm_userInput[]
    createMany?: im_trainingCreateManyIm_userInputEnvelope
    connect?: im_trainingWhereUniqueInput | im_trainingWhereUniqueInput[]
  }

  export type im_undesirable_foodUncheckedCreateNestedManyWithoutIm_userInput = {
    create?: XOR<im_undesirable_foodCreateWithoutIm_userInput, im_undesirable_foodUncheckedCreateWithoutIm_userInput> | im_undesirable_foodCreateWithoutIm_userInput[] | im_undesirable_foodUncheckedCreateWithoutIm_userInput[]
    connectOrCreate?: im_undesirable_foodCreateOrConnectWithoutIm_userInput | im_undesirable_foodCreateOrConnectWithoutIm_userInput[]
    createMany?: im_undesirable_foodCreateManyIm_userInputEnvelope
    connect?: im_undesirable_foodWhereUniqueInput | im_undesirable_foodWhereUniqueInput[]
  }

  export type im_healthUpdateManyWithoutIm_userNestedInput = {
    create?: XOR<im_healthCreateWithoutIm_userInput, im_healthUncheckedCreateWithoutIm_userInput> | im_healthCreateWithoutIm_userInput[] | im_healthUncheckedCreateWithoutIm_userInput[]
    connectOrCreate?: im_healthCreateOrConnectWithoutIm_userInput | im_healthCreateOrConnectWithoutIm_userInput[]
    upsert?: im_healthUpsertWithWhereUniqueWithoutIm_userInput | im_healthUpsertWithWhereUniqueWithoutIm_userInput[]
    createMany?: im_healthCreateManyIm_userInputEnvelope
    set?: im_healthWhereUniqueInput | im_healthWhereUniqueInput[]
    disconnect?: im_healthWhereUniqueInput | im_healthWhereUniqueInput[]
    delete?: im_healthWhereUniqueInput | im_healthWhereUniqueInput[]
    connect?: im_healthWhereUniqueInput | im_healthWhereUniqueInput[]
    update?: im_healthUpdateWithWhereUniqueWithoutIm_userInput | im_healthUpdateWithWhereUniqueWithoutIm_userInput[]
    updateMany?: im_healthUpdateManyWithWhereWithoutIm_userInput | im_healthUpdateManyWithWhereWithoutIm_userInput[]
    deleteMany?: im_healthScalarWhereInput | im_healthScalarWhereInput[]
  }

  export type im_nutritionUpdateManyWithoutIm_userNestedInput = {
    create?: XOR<im_nutritionCreateWithoutIm_userInput, im_nutritionUncheckedCreateWithoutIm_userInput> | im_nutritionCreateWithoutIm_userInput[] | im_nutritionUncheckedCreateWithoutIm_userInput[]
    connectOrCreate?: im_nutritionCreateOrConnectWithoutIm_userInput | im_nutritionCreateOrConnectWithoutIm_userInput[]
    upsert?: im_nutritionUpsertWithWhereUniqueWithoutIm_userInput | im_nutritionUpsertWithWhereUniqueWithoutIm_userInput[]
    createMany?: im_nutritionCreateManyIm_userInputEnvelope
    set?: im_nutritionWhereUniqueInput | im_nutritionWhereUniqueInput[]
    disconnect?: im_nutritionWhereUniqueInput | im_nutritionWhereUniqueInput[]
    delete?: im_nutritionWhereUniqueInput | im_nutritionWhereUniqueInput[]
    connect?: im_nutritionWhereUniqueInput | im_nutritionWhereUniqueInput[]
    update?: im_nutritionUpdateWithWhereUniqueWithoutIm_userInput | im_nutritionUpdateWithWhereUniqueWithoutIm_userInput[]
    updateMany?: im_nutritionUpdateManyWithWhereWithoutIm_userInput | im_nutritionUpdateManyWithWhereWithoutIm_userInput[]
    deleteMany?: im_nutritionScalarWhereInput | im_nutritionScalarWhereInput[]
  }

  export type im_trainingUpdateManyWithoutIm_userNestedInput = {
    create?: XOR<im_trainingCreateWithoutIm_userInput, im_trainingUncheckedCreateWithoutIm_userInput> | im_trainingCreateWithoutIm_userInput[] | im_trainingUncheckedCreateWithoutIm_userInput[]
    connectOrCreate?: im_trainingCreateOrConnectWithoutIm_userInput | im_trainingCreateOrConnectWithoutIm_userInput[]
    upsert?: im_trainingUpsertWithWhereUniqueWithoutIm_userInput | im_trainingUpsertWithWhereUniqueWithoutIm_userInput[]
    createMany?: im_trainingCreateManyIm_userInputEnvelope
    set?: im_trainingWhereUniqueInput | im_trainingWhereUniqueInput[]
    disconnect?: im_trainingWhereUniqueInput | im_trainingWhereUniqueInput[]
    delete?: im_trainingWhereUniqueInput | im_trainingWhereUniqueInput[]
    connect?: im_trainingWhereUniqueInput | im_trainingWhereUniqueInput[]
    update?: im_trainingUpdateWithWhereUniqueWithoutIm_userInput | im_trainingUpdateWithWhereUniqueWithoutIm_userInput[]
    updateMany?: im_trainingUpdateManyWithWhereWithoutIm_userInput | im_trainingUpdateManyWithWhereWithoutIm_userInput[]
    deleteMany?: im_trainingScalarWhereInput | im_trainingScalarWhereInput[]
  }

  export type im_undesirable_foodUpdateManyWithoutIm_userNestedInput = {
    create?: XOR<im_undesirable_foodCreateWithoutIm_userInput, im_undesirable_foodUncheckedCreateWithoutIm_userInput> | im_undesirable_foodCreateWithoutIm_userInput[] | im_undesirable_foodUncheckedCreateWithoutIm_userInput[]
    connectOrCreate?: im_undesirable_foodCreateOrConnectWithoutIm_userInput | im_undesirable_foodCreateOrConnectWithoutIm_userInput[]
    upsert?: im_undesirable_foodUpsertWithWhereUniqueWithoutIm_userInput | im_undesirable_foodUpsertWithWhereUniqueWithoutIm_userInput[]
    createMany?: im_undesirable_foodCreateManyIm_userInputEnvelope
    set?: im_undesirable_foodWhereUniqueInput | im_undesirable_foodWhereUniqueInput[]
    disconnect?: im_undesirable_foodWhereUniqueInput | im_undesirable_foodWhereUniqueInput[]
    delete?: im_undesirable_foodWhereUniqueInput | im_undesirable_foodWhereUniqueInput[]
    connect?: im_undesirable_foodWhereUniqueInput | im_undesirable_foodWhereUniqueInput[]
    update?: im_undesirable_foodUpdateWithWhereUniqueWithoutIm_userInput | im_undesirable_foodUpdateWithWhereUniqueWithoutIm_userInput[]
    updateMany?: im_undesirable_foodUpdateManyWithWhereWithoutIm_userInput | im_undesirable_foodUpdateManyWithWhereWithoutIm_userInput[]
    deleteMany?: im_undesirable_foodScalarWhereInput | im_undesirable_foodScalarWhereInput[]
  }

  export type im_healthUncheckedUpdateManyWithoutIm_userNestedInput = {
    create?: XOR<im_healthCreateWithoutIm_userInput, im_healthUncheckedCreateWithoutIm_userInput> | im_healthCreateWithoutIm_userInput[] | im_healthUncheckedCreateWithoutIm_userInput[]
    connectOrCreate?: im_healthCreateOrConnectWithoutIm_userInput | im_healthCreateOrConnectWithoutIm_userInput[]
    upsert?: im_healthUpsertWithWhereUniqueWithoutIm_userInput | im_healthUpsertWithWhereUniqueWithoutIm_userInput[]
    createMany?: im_healthCreateManyIm_userInputEnvelope
    set?: im_healthWhereUniqueInput | im_healthWhereUniqueInput[]
    disconnect?: im_healthWhereUniqueInput | im_healthWhereUniqueInput[]
    delete?: im_healthWhereUniqueInput | im_healthWhereUniqueInput[]
    connect?: im_healthWhereUniqueInput | im_healthWhereUniqueInput[]
    update?: im_healthUpdateWithWhereUniqueWithoutIm_userInput | im_healthUpdateWithWhereUniqueWithoutIm_userInput[]
    updateMany?: im_healthUpdateManyWithWhereWithoutIm_userInput | im_healthUpdateManyWithWhereWithoutIm_userInput[]
    deleteMany?: im_healthScalarWhereInput | im_healthScalarWhereInput[]
  }

  export type im_nutritionUncheckedUpdateManyWithoutIm_userNestedInput = {
    create?: XOR<im_nutritionCreateWithoutIm_userInput, im_nutritionUncheckedCreateWithoutIm_userInput> | im_nutritionCreateWithoutIm_userInput[] | im_nutritionUncheckedCreateWithoutIm_userInput[]
    connectOrCreate?: im_nutritionCreateOrConnectWithoutIm_userInput | im_nutritionCreateOrConnectWithoutIm_userInput[]
    upsert?: im_nutritionUpsertWithWhereUniqueWithoutIm_userInput | im_nutritionUpsertWithWhereUniqueWithoutIm_userInput[]
    createMany?: im_nutritionCreateManyIm_userInputEnvelope
    set?: im_nutritionWhereUniqueInput | im_nutritionWhereUniqueInput[]
    disconnect?: im_nutritionWhereUniqueInput | im_nutritionWhereUniqueInput[]
    delete?: im_nutritionWhereUniqueInput | im_nutritionWhereUniqueInput[]
    connect?: im_nutritionWhereUniqueInput | im_nutritionWhereUniqueInput[]
    update?: im_nutritionUpdateWithWhereUniqueWithoutIm_userInput | im_nutritionUpdateWithWhereUniqueWithoutIm_userInput[]
    updateMany?: im_nutritionUpdateManyWithWhereWithoutIm_userInput | im_nutritionUpdateManyWithWhereWithoutIm_userInput[]
    deleteMany?: im_nutritionScalarWhereInput | im_nutritionScalarWhereInput[]
  }

  export type im_trainingUncheckedUpdateManyWithoutIm_userNestedInput = {
    create?: XOR<im_trainingCreateWithoutIm_userInput, im_trainingUncheckedCreateWithoutIm_userInput> | im_trainingCreateWithoutIm_userInput[] | im_trainingUncheckedCreateWithoutIm_userInput[]
    connectOrCreate?: im_trainingCreateOrConnectWithoutIm_userInput | im_trainingCreateOrConnectWithoutIm_userInput[]
    upsert?: im_trainingUpsertWithWhereUniqueWithoutIm_userInput | im_trainingUpsertWithWhereUniqueWithoutIm_userInput[]
    createMany?: im_trainingCreateManyIm_userInputEnvelope
    set?: im_trainingWhereUniqueInput | im_trainingWhereUniqueInput[]
    disconnect?: im_trainingWhereUniqueInput | im_trainingWhereUniqueInput[]
    delete?: im_trainingWhereUniqueInput | im_trainingWhereUniqueInput[]
    connect?: im_trainingWhereUniqueInput | im_trainingWhereUniqueInput[]
    update?: im_trainingUpdateWithWhereUniqueWithoutIm_userInput | im_trainingUpdateWithWhereUniqueWithoutIm_userInput[]
    updateMany?: im_trainingUpdateManyWithWhereWithoutIm_userInput | im_trainingUpdateManyWithWhereWithoutIm_userInput[]
    deleteMany?: im_trainingScalarWhereInput | im_trainingScalarWhereInput[]
  }

  export type im_undesirable_foodUncheckedUpdateManyWithoutIm_userNestedInput = {
    create?: XOR<im_undesirable_foodCreateWithoutIm_userInput, im_undesirable_foodUncheckedCreateWithoutIm_userInput> | im_undesirable_foodCreateWithoutIm_userInput[] | im_undesirable_foodUncheckedCreateWithoutIm_userInput[]
    connectOrCreate?: im_undesirable_foodCreateOrConnectWithoutIm_userInput | im_undesirable_foodCreateOrConnectWithoutIm_userInput[]
    upsert?: im_undesirable_foodUpsertWithWhereUniqueWithoutIm_userInput | im_undesirable_foodUpsertWithWhereUniqueWithoutIm_userInput[]
    createMany?: im_undesirable_foodCreateManyIm_userInputEnvelope
    set?: im_undesirable_foodWhereUniqueInput | im_undesirable_foodWhereUniqueInput[]
    disconnect?: im_undesirable_foodWhereUniqueInput | im_undesirable_foodWhereUniqueInput[]
    delete?: im_undesirable_foodWhereUniqueInput | im_undesirable_foodWhereUniqueInput[]
    connect?: im_undesirable_foodWhereUniqueInput | im_undesirable_foodWhereUniqueInput[]
    update?: im_undesirable_foodUpdateWithWhereUniqueWithoutIm_userInput | im_undesirable_foodUpdateWithWhereUniqueWithoutIm_userInput[]
    updateMany?: im_undesirable_foodUpdateManyWithWhereWithoutIm_userInput | im_undesirable_foodUpdateManyWithWhereWithoutIm_userInput[]
    deleteMany?: im_undesirable_foodScalarWhereInput | im_undesirable_foodScalarWhereInput[]
  }

  export type im_exerciseCreateNestedManyWithoutIm_workoutInput = {
    create?: XOR<im_exerciseCreateWithoutIm_workoutInput, im_exerciseUncheckedCreateWithoutIm_workoutInput> | im_exerciseCreateWithoutIm_workoutInput[] | im_exerciseUncheckedCreateWithoutIm_workoutInput[]
    connectOrCreate?: im_exerciseCreateOrConnectWithoutIm_workoutInput | im_exerciseCreateOrConnectWithoutIm_workoutInput[]
    createMany?: im_exerciseCreateManyIm_workoutInputEnvelope
    connect?: im_exerciseWhereUniqueInput | im_exerciseWhereUniqueInput[]
  }

  export type im_trainingCreateNestedOneWithoutIm_workoutInput = {
    create?: XOR<im_trainingCreateWithoutIm_workoutInput, im_trainingUncheckedCreateWithoutIm_workoutInput>
    connectOrCreate?: im_trainingCreateOrConnectWithoutIm_workoutInput
    connect?: im_trainingWhereUniqueInput
  }

  export type im_exerciseUncheckedCreateNestedManyWithoutIm_workoutInput = {
    create?: XOR<im_exerciseCreateWithoutIm_workoutInput, im_exerciseUncheckedCreateWithoutIm_workoutInput> | im_exerciseCreateWithoutIm_workoutInput[] | im_exerciseUncheckedCreateWithoutIm_workoutInput[]
    connectOrCreate?: im_exerciseCreateOrConnectWithoutIm_workoutInput | im_exerciseCreateOrConnectWithoutIm_workoutInput[]
    createMany?: im_exerciseCreateManyIm_workoutInputEnvelope
    connect?: im_exerciseWhereUniqueInput | im_exerciseWhereUniqueInput[]
  }

  export type im_exerciseUpdateManyWithoutIm_workoutNestedInput = {
    create?: XOR<im_exerciseCreateWithoutIm_workoutInput, im_exerciseUncheckedCreateWithoutIm_workoutInput> | im_exerciseCreateWithoutIm_workoutInput[] | im_exerciseUncheckedCreateWithoutIm_workoutInput[]
    connectOrCreate?: im_exerciseCreateOrConnectWithoutIm_workoutInput | im_exerciseCreateOrConnectWithoutIm_workoutInput[]
    upsert?: im_exerciseUpsertWithWhereUniqueWithoutIm_workoutInput | im_exerciseUpsertWithWhereUniqueWithoutIm_workoutInput[]
    createMany?: im_exerciseCreateManyIm_workoutInputEnvelope
    set?: im_exerciseWhereUniqueInput | im_exerciseWhereUniqueInput[]
    disconnect?: im_exerciseWhereUniqueInput | im_exerciseWhereUniqueInput[]
    delete?: im_exerciseWhereUniqueInput | im_exerciseWhereUniqueInput[]
    connect?: im_exerciseWhereUniqueInput | im_exerciseWhereUniqueInput[]
    update?: im_exerciseUpdateWithWhereUniqueWithoutIm_workoutInput | im_exerciseUpdateWithWhereUniqueWithoutIm_workoutInput[]
    updateMany?: im_exerciseUpdateManyWithWhereWithoutIm_workoutInput | im_exerciseUpdateManyWithWhereWithoutIm_workoutInput[]
    deleteMany?: im_exerciseScalarWhereInput | im_exerciseScalarWhereInput[]
  }

  export type im_trainingUpdateOneRequiredWithoutIm_workoutNestedInput = {
    create?: XOR<im_trainingCreateWithoutIm_workoutInput, im_trainingUncheckedCreateWithoutIm_workoutInput>
    connectOrCreate?: im_trainingCreateOrConnectWithoutIm_workoutInput
    upsert?: im_trainingUpsertWithoutIm_workoutInput
    connect?: im_trainingWhereUniqueInput
    update?: XOR<XOR<im_trainingUpdateToOneWithWhereWithoutIm_workoutInput, im_trainingUpdateWithoutIm_workoutInput>, im_trainingUncheckedUpdateWithoutIm_workoutInput>
  }

  export type im_exerciseUncheckedUpdateManyWithoutIm_workoutNestedInput = {
    create?: XOR<im_exerciseCreateWithoutIm_workoutInput, im_exerciseUncheckedCreateWithoutIm_workoutInput> | im_exerciseCreateWithoutIm_workoutInput[] | im_exerciseUncheckedCreateWithoutIm_workoutInput[]
    connectOrCreate?: im_exerciseCreateOrConnectWithoutIm_workoutInput | im_exerciseCreateOrConnectWithoutIm_workoutInput[]
    upsert?: im_exerciseUpsertWithWhereUniqueWithoutIm_workoutInput | im_exerciseUpsertWithWhereUniqueWithoutIm_workoutInput[]
    createMany?: im_exerciseCreateManyIm_workoutInputEnvelope
    set?: im_exerciseWhereUniqueInput | im_exerciseWhereUniqueInput[]
    disconnect?: im_exerciseWhereUniqueInput | im_exerciseWhereUniqueInput[]
    delete?: im_exerciseWhereUniqueInput | im_exerciseWhereUniqueInput[]
    connect?: im_exerciseWhereUniqueInput | im_exerciseWhereUniqueInput[]
    update?: im_exerciseUpdateWithWhereUniqueWithoutIm_workoutInput | im_exerciseUpdateWithWhereUniqueWithoutIm_workoutInput[]
    updateMany?: im_exerciseUpdateManyWithWhereWithoutIm_workoutInput | im_exerciseUpdateManyWithWhereWithoutIm_workoutInput[]
    deleteMany?: im_exerciseScalarWhereInput | im_exerciseScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type im_workoutCreateWithoutIm_exerciseInput = {
    workout_point: number
    workout_name: string
    workout_comment: string
    im_training: im_trainingCreateNestedOneWithoutIm_workoutInput
  }

  export type im_workoutUncheckedCreateWithoutIm_exerciseInput = {
    id_workout?: number
    workout_point: number
    workout_name: string
    workout_comment: string
    id_training: number
  }

  export type im_workoutCreateOrConnectWithoutIm_exerciseInput = {
    where: im_workoutWhereUniqueInput
    create: XOR<im_workoutCreateWithoutIm_exerciseInput, im_workoutUncheckedCreateWithoutIm_exerciseInput>
  }

  export type im_exercise_historyCreateWithoutIm_exerciseInput = {
    exercise_history_date: Date | string
  }

  export type im_exercise_historyUncheckedCreateWithoutIm_exerciseInput = {
    id_exercise_history?: number
    exercise_history_date: Date | string
  }

  export type im_exercise_historyCreateOrConnectWithoutIm_exerciseInput = {
    where: im_exercise_historyWhereUniqueInput
    create: XOR<im_exercise_historyCreateWithoutIm_exerciseInput, im_exercise_historyUncheckedCreateWithoutIm_exerciseInput>
  }

  export type im_exercise_historyCreateManyIm_exerciseInputEnvelope = {
    data: im_exercise_historyCreateManyIm_exerciseInput | im_exercise_historyCreateManyIm_exerciseInput[]
    skipDuplicates?: boolean
  }

  export type im_workoutUpsertWithoutIm_exerciseInput = {
    update: XOR<im_workoutUpdateWithoutIm_exerciseInput, im_workoutUncheckedUpdateWithoutIm_exerciseInput>
    create: XOR<im_workoutCreateWithoutIm_exerciseInput, im_workoutUncheckedCreateWithoutIm_exerciseInput>
    where?: im_workoutWhereInput
  }

  export type im_workoutUpdateToOneWithWhereWithoutIm_exerciseInput = {
    where?: im_workoutWhereInput
    data: XOR<im_workoutUpdateWithoutIm_exerciseInput, im_workoutUncheckedUpdateWithoutIm_exerciseInput>
  }

  export type im_workoutUpdateWithoutIm_exerciseInput = {
    workout_point?: IntFieldUpdateOperationsInput | number
    workout_name?: StringFieldUpdateOperationsInput | string
    workout_comment?: StringFieldUpdateOperationsInput | string
    im_training?: im_trainingUpdateOneRequiredWithoutIm_workoutNestedInput
  }

  export type im_workoutUncheckedUpdateWithoutIm_exerciseInput = {
    id_workout?: IntFieldUpdateOperationsInput | number
    workout_point?: IntFieldUpdateOperationsInput | number
    workout_name?: StringFieldUpdateOperationsInput | string
    workout_comment?: StringFieldUpdateOperationsInput | string
    id_training?: IntFieldUpdateOperationsInput | number
  }

  export type im_exercise_historyUpsertWithWhereUniqueWithoutIm_exerciseInput = {
    where: im_exercise_historyWhereUniqueInput
    update: XOR<im_exercise_historyUpdateWithoutIm_exerciseInput, im_exercise_historyUncheckedUpdateWithoutIm_exerciseInput>
    create: XOR<im_exercise_historyCreateWithoutIm_exerciseInput, im_exercise_historyUncheckedCreateWithoutIm_exerciseInput>
  }

  export type im_exercise_historyUpdateWithWhereUniqueWithoutIm_exerciseInput = {
    where: im_exercise_historyWhereUniqueInput
    data: XOR<im_exercise_historyUpdateWithoutIm_exerciseInput, im_exercise_historyUncheckedUpdateWithoutIm_exerciseInput>
  }

  export type im_exercise_historyUpdateManyWithWhereWithoutIm_exerciseInput = {
    where: im_exercise_historyScalarWhereInput
    data: XOR<im_exercise_historyUpdateManyMutationInput, im_exercise_historyUncheckedUpdateManyWithoutIm_exerciseInput>
  }

  export type im_exercise_historyScalarWhereInput = {
    AND?: im_exercise_historyScalarWhereInput | im_exercise_historyScalarWhereInput[]
    OR?: im_exercise_historyScalarWhereInput[]
    NOT?: im_exercise_historyScalarWhereInput | im_exercise_historyScalarWhereInput[]
    id_exercise_history?: IntFilter<"im_exercise_history"> | number
    exercise_history_date?: DateTimeFilter<"im_exercise_history"> | Date | string
    id_exercise?: IntFilter<"im_exercise_history"> | number
  }

  export type im_exerciseCreateWithoutIm_exercise_historyInput = {
    exercise_name: string
    exercise_type: string
    exercise_rest_time: number
    exercise_reps: number
    exercise_series: number
    exercise_description: string
    im_workout: im_workoutCreateNestedOneWithoutIm_exerciseInput
  }

  export type im_exerciseUncheckedCreateWithoutIm_exercise_historyInput = {
    id_exercise?: number
    exercise_name: string
    exercise_type: string
    exercise_rest_time: number
    exercise_reps: number
    exercise_series: number
    exercise_description: string
    id_workout: number
  }

  export type im_exerciseCreateOrConnectWithoutIm_exercise_historyInput = {
    where: im_exerciseWhereUniqueInput
    create: XOR<im_exerciseCreateWithoutIm_exercise_historyInput, im_exerciseUncheckedCreateWithoutIm_exercise_historyInput>
  }

  export type im_exerciseUpsertWithoutIm_exercise_historyInput = {
    update: XOR<im_exerciseUpdateWithoutIm_exercise_historyInput, im_exerciseUncheckedUpdateWithoutIm_exercise_historyInput>
    create: XOR<im_exerciseCreateWithoutIm_exercise_historyInput, im_exerciseUncheckedCreateWithoutIm_exercise_historyInput>
    where?: im_exerciseWhereInput
  }

  export type im_exerciseUpdateToOneWithWhereWithoutIm_exercise_historyInput = {
    where?: im_exerciseWhereInput
    data: XOR<im_exerciseUpdateWithoutIm_exercise_historyInput, im_exerciseUncheckedUpdateWithoutIm_exercise_historyInput>
  }

  export type im_exerciseUpdateWithoutIm_exercise_historyInput = {
    exercise_name?: StringFieldUpdateOperationsInput | string
    exercise_type?: StringFieldUpdateOperationsInput | string
    exercise_rest_time?: IntFieldUpdateOperationsInput | number
    exercise_reps?: IntFieldUpdateOperationsInput | number
    exercise_series?: IntFieldUpdateOperationsInput | number
    exercise_description?: StringFieldUpdateOperationsInput | string
    im_workout?: im_workoutUpdateOneRequiredWithoutIm_exerciseNestedInput
  }

  export type im_exerciseUncheckedUpdateWithoutIm_exercise_historyInput = {
    id_exercise?: IntFieldUpdateOperationsInput | number
    exercise_name?: StringFieldUpdateOperationsInput | string
    exercise_type?: StringFieldUpdateOperationsInput | string
    exercise_rest_time?: IntFieldUpdateOperationsInput | number
    exercise_reps?: IntFieldUpdateOperationsInput | number
    exercise_series?: IntFieldUpdateOperationsInput | number
    exercise_description?: StringFieldUpdateOperationsInput | string
    id_workout?: IntFieldUpdateOperationsInput | number
  }

  export type im_recipeCreateWithoutIm_foodInput = {
    im_meal: im_mealCreateNestedOneWithoutIm_recipeInput
  }

  export type im_recipeUncheckedCreateWithoutIm_foodInput = {
    id_recipe?: number
    id_meal: number
  }

  export type im_recipeCreateOrConnectWithoutIm_foodInput = {
    where: im_recipeWhereUniqueInput
    create: XOR<im_recipeCreateWithoutIm_foodInput, im_recipeUncheckedCreateWithoutIm_foodInput>
  }

  export type im_recipeCreateManyIm_foodInputEnvelope = {
    data: im_recipeCreateManyIm_foodInput | im_recipeCreateManyIm_foodInput[]
    skipDuplicates?: boolean
  }

  export type im_undesirable_foodCreateWithoutIm_foodInput = {
    im_user: im_userCreateNestedOneWithoutIm_undesirable_foodInput
  }

  export type im_undesirable_foodUncheckedCreateWithoutIm_foodInput = {
    id_undesirable_food?: number
    id_user: number
  }

  export type im_undesirable_foodCreateOrConnectWithoutIm_foodInput = {
    where: im_undesirable_foodWhereUniqueInput
    create: XOR<im_undesirable_foodCreateWithoutIm_foodInput, im_undesirable_foodUncheckedCreateWithoutIm_foodInput>
  }

  export type im_undesirable_foodCreateManyIm_foodInputEnvelope = {
    data: im_undesirable_foodCreateManyIm_foodInput | im_undesirable_foodCreateManyIm_foodInput[]
    skipDuplicates?: boolean
  }

  export type im_recipeUpsertWithWhereUniqueWithoutIm_foodInput = {
    where: im_recipeWhereUniqueInput
    update: XOR<im_recipeUpdateWithoutIm_foodInput, im_recipeUncheckedUpdateWithoutIm_foodInput>
    create: XOR<im_recipeCreateWithoutIm_foodInput, im_recipeUncheckedCreateWithoutIm_foodInput>
  }

  export type im_recipeUpdateWithWhereUniqueWithoutIm_foodInput = {
    where: im_recipeWhereUniqueInput
    data: XOR<im_recipeUpdateWithoutIm_foodInput, im_recipeUncheckedUpdateWithoutIm_foodInput>
  }

  export type im_recipeUpdateManyWithWhereWithoutIm_foodInput = {
    where: im_recipeScalarWhereInput
    data: XOR<im_recipeUpdateManyMutationInput, im_recipeUncheckedUpdateManyWithoutIm_foodInput>
  }

  export type im_recipeScalarWhereInput = {
    AND?: im_recipeScalarWhereInput | im_recipeScalarWhereInput[]
    OR?: im_recipeScalarWhereInput[]
    NOT?: im_recipeScalarWhereInput | im_recipeScalarWhereInput[]
    id_recipe?: IntFilter<"im_recipe"> | number
    id_meal?: IntFilter<"im_recipe"> | number
    id_food?: IntFilter<"im_recipe"> | number
  }

  export type im_undesirable_foodUpsertWithWhereUniqueWithoutIm_foodInput = {
    where: im_undesirable_foodWhereUniqueInput
    update: XOR<im_undesirable_foodUpdateWithoutIm_foodInput, im_undesirable_foodUncheckedUpdateWithoutIm_foodInput>
    create: XOR<im_undesirable_foodCreateWithoutIm_foodInput, im_undesirable_foodUncheckedCreateWithoutIm_foodInput>
  }

  export type im_undesirable_foodUpdateWithWhereUniqueWithoutIm_foodInput = {
    where: im_undesirable_foodWhereUniqueInput
    data: XOR<im_undesirable_foodUpdateWithoutIm_foodInput, im_undesirable_foodUncheckedUpdateWithoutIm_foodInput>
  }

  export type im_undesirable_foodUpdateManyWithWhereWithoutIm_foodInput = {
    where: im_undesirable_foodScalarWhereInput
    data: XOR<im_undesirable_foodUpdateManyMutationInput, im_undesirable_foodUncheckedUpdateManyWithoutIm_foodInput>
  }

  export type im_undesirable_foodScalarWhereInput = {
    AND?: im_undesirable_foodScalarWhereInput | im_undesirable_foodScalarWhereInput[]
    OR?: im_undesirable_foodScalarWhereInput[]
    NOT?: im_undesirable_foodScalarWhereInput | im_undesirable_foodScalarWhereInput[]
    id_undesirable_food?: IntFilter<"im_undesirable_food"> | number
    id_food?: IntFilter<"im_undesirable_food"> | number
    id_user?: IntFilter<"im_undesirable_food"> | number
  }

  export type im_userCreateWithoutIm_healthInput = {
    user_firstname: string
    user_name: string
    user_mail: string
    user_password: string
    user_birth_date: Date | string
    user_inscription_date: Date | string
    user_gender: number
    user_height: number
    user_weight: number
    user_age: number
    user_training_level: number
    user_nutrition_diet: number
    im_nutrition?: im_nutritionCreateNestedManyWithoutIm_userInput
    im_training?: im_trainingCreateNestedManyWithoutIm_userInput
    im_undesirable_food?: im_undesirable_foodCreateNestedManyWithoutIm_userInput
  }

  export type im_userUncheckedCreateWithoutIm_healthInput = {
    id_user?: number
    user_firstname: string
    user_name: string
    user_mail: string
    user_password: string
    user_birth_date: Date | string
    user_inscription_date: Date | string
    user_gender: number
    user_height: number
    user_weight: number
    user_age: number
    user_training_level: number
    user_nutrition_diet: number
    im_nutrition?: im_nutritionUncheckedCreateNestedManyWithoutIm_userInput
    im_training?: im_trainingUncheckedCreateNestedManyWithoutIm_userInput
    im_undesirable_food?: im_undesirable_foodUncheckedCreateNestedManyWithoutIm_userInput
  }

  export type im_userCreateOrConnectWithoutIm_healthInput = {
    where: im_userWhereUniqueInput
    create: XOR<im_userCreateWithoutIm_healthInput, im_userUncheckedCreateWithoutIm_healthInput>
  }

  export type im_health_goalCreateWithoutIm_healthInput = {
    health_goal_steps: number
    health_goal_weight: number
    health_goal_sleep: number
    health_goal_water: number
    im_health_goal_daily?: im_health_goal_dailyCreateNestedManyWithoutIm_health_goalInput
  }

  export type im_health_goalUncheckedCreateWithoutIm_healthInput = {
    id_health_goal?: number
    health_goal_steps: number
    health_goal_weight: number
    health_goal_sleep: number
    health_goal_water: number
    im_health_goal_daily?: im_health_goal_dailyUncheckedCreateNestedManyWithoutIm_health_goalInput
  }

  export type im_health_goalCreateOrConnectWithoutIm_healthInput = {
    where: im_health_goalWhereUniqueInput
    create: XOR<im_health_goalCreateWithoutIm_healthInput, im_health_goalUncheckedCreateWithoutIm_healthInput>
  }

  export type im_health_goalCreateManyIm_healthInputEnvelope = {
    data: im_health_goalCreateManyIm_healthInput | im_health_goalCreateManyIm_healthInput[]
    skipDuplicates?: boolean
  }

  export type im_userUpsertWithoutIm_healthInput = {
    update: XOR<im_userUpdateWithoutIm_healthInput, im_userUncheckedUpdateWithoutIm_healthInput>
    create: XOR<im_userCreateWithoutIm_healthInput, im_userUncheckedCreateWithoutIm_healthInput>
    where?: im_userWhereInput
  }

  export type im_userUpdateToOneWithWhereWithoutIm_healthInput = {
    where?: im_userWhereInput
    data: XOR<im_userUpdateWithoutIm_healthInput, im_userUncheckedUpdateWithoutIm_healthInput>
  }

  export type im_userUpdateWithoutIm_healthInput = {
    user_firstname?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_mail?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    user_birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_inscription_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_gender?: IntFieldUpdateOperationsInput | number
    user_height?: IntFieldUpdateOperationsInput | number
    user_weight?: IntFieldUpdateOperationsInput | number
    user_age?: IntFieldUpdateOperationsInput | number
    user_training_level?: IntFieldUpdateOperationsInput | number
    user_nutrition_diet?: IntFieldUpdateOperationsInput | number
    im_nutrition?: im_nutritionUpdateManyWithoutIm_userNestedInput
    im_training?: im_trainingUpdateManyWithoutIm_userNestedInput
    im_undesirable_food?: im_undesirable_foodUpdateManyWithoutIm_userNestedInput
  }

  export type im_userUncheckedUpdateWithoutIm_healthInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    user_firstname?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_mail?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    user_birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_inscription_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_gender?: IntFieldUpdateOperationsInput | number
    user_height?: IntFieldUpdateOperationsInput | number
    user_weight?: IntFieldUpdateOperationsInput | number
    user_age?: IntFieldUpdateOperationsInput | number
    user_training_level?: IntFieldUpdateOperationsInput | number
    user_nutrition_diet?: IntFieldUpdateOperationsInput | number
    im_nutrition?: im_nutritionUncheckedUpdateManyWithoutIm_userNestedInput
    im_training?: im_trainingUncheckedUpdateManyWithoutIm_userNestedInput
    im_undesirable_food?: im_undesirable_foodUncheckedUpdateManyWithoutIm_userNestedInput
  }

  export type im_health_goalUpsertWithWhereUniqueWithoutIm_healthInput = {
    where: im_health_goalWhereUniqueInput
    update: XOR<im_health_goalUpdateWithoutIm_healthInput, im_health_goalUncheckedUpdateWithoutIm_healthInput>
    create: XOR<im_health_goalCreateWithoutIm_healthInput, im_health_goalUncheckedCreateWithoutIm_healthInput>
  }

  export type im_health_goalUpdateWithWhereUniqueWithoutIm_healthInput = {
    where: im_health_goalWhereUniqueInput
    data: XOR<im_health_goalUpdateWithoutIm_healthInput, im_health_goalUncheckedUpdateWithoutIm_healthInput>
  }

  export type im_health_goalUpdateManyWithWhereWithoutIm_healthInput = {
    where: im_health_goalScalarWhereInput
    data: XOR<im_health_goalUpdateManyMutationInput, im_health_goalUncheckedUpdateManyWithoutIm_healthInput>
  }

  export type im_health_goalScalarWhereInput = {
    AND?: im_health_goalScalarWhereInput | im_health_goalScalarWhereInput[]
    OR?: im_health_goalScalarWhereInput[]
    NOT?: im_health_goalScalarWhereInput | im_health_goalScalarWhereInput[]
    id_health_goal?: IntFilter<"im_health_goal"> | number
    health_goal_steps?: IntFilter<"im_health_goal"> | number
    health_goal_weight?: IntFilter<"im_health_goal"> | number
    health_goal_sleep?: IntFilter<"im_health_goal"> | number
    health_goal_water?: IntFilter<"im_health_goal"> | number
    id_health?: IntFilter<"im_health_goal"> | number
  }

  export type im_healthCreateWithoutIm_health_goalInput = {
    im_user: im_userCreateNestedOneWithoutIm_healthInput
  }

  export type im_healthUncheckedCreateWithoutIm_health_goalInput = {
    id_health?: number
    id_user: number
  }

  export type im_healthCreateOrConnectWithoutIm_health_goalInput = {
    where: im_healthWhereUniqueInput
    create: XOR<im_healthCreateWithoutIm_health_goalInput, im_healthUncheckedCreateWithoutIm_health_goalInput>
  }

  export type im_health_goal_dailyCreateWithoutIm_health_goalInput = {
    health_goal_daily_date: Date | string
    health_goal_daily_steps: number
    health_goal_daily_weight: number
    health_goal_daily_sleep: number
    health_goal_daily_water: number
    im_health_goal_daily_history?: im_health_goal_daily_historyCreateNestedManyWithoutIm_health_goal_dailyInput
  }

  export type im_health_goal_dailyUncheckedCreateWithoutIm_health_goalInput = {
    id_health_goal_daily?: number
    health_goal_daily_date: Date | string
    health_goal_daily_steps: number
    health_goal_daily_weight: number
    health_goal_daily_sleep: number
    health_goal_daily_water: number
    im_health_goal_daily_history?: im_health_goal_daily_historyUncheckedCreateNestedManyWithoutIm_health_goal_dailyInput
  }

  export type im_health_goal_dailyCreateOrConnectWithoutIm_health_goalInput = {
    where: im_health_goal_dailyWhereUniqueInput
    create: XOR<im_health_goal_dailyCreateWithoutIm_health_goalInput, im_health_goal_dailyUncheckedCreateWithoutIm_health_goalInput>
  }

  export type im_health_goal_dailyCreateManyIm_health_goalInputEnvelope = {
    data: im_health_goal_dailyCreateManyIm_health_goalInput | im_health_goal_dailyCreateManyIm_health_goalInput[]
    skipDuplicates?: boolean
  }

  export type im_healthUpsertWithoutIm_health_goalInput = {
    update: XOR<im_healthUpdateWithoutIm_health_goalInput, im_healthUncheckedUpdateWithoutIm_health_goalInput>
    create: XOR<im_healthCreateWithoutIm_health_goalInput, im_healthUncheckedCreateWithoutIm_health_goalInput>
    where?: im_healthWhereInput
  }

  export type im_healthUpdateToOneWithWhereWithoutIm_health_goalInput = {
    where?: im_healthWhereInput
    data: XOR<im_healthUpdateWithoutIm_health_goalInput, im_healthUncheckedUpdateWithoutIm_health_goalInput>
  }

  export type im_healthUpdateWithoutIm_health_goalInput = {
    im_user?: im_userUpdateOneRequiredWithoutIm_healthNestedInput
  }

  export type im_healthUncheckedUpdateWithoutIm_health_goalInput = {
    id_health?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
  }

  export type im_health_goal_dailyUpsertWithWhereUniqueWithoutIm_health_goalInput = {
    where: im_health_goal_dailyWhereUniqueInput
    update: XOR<im_health_goal_dailyUpdateWithoutIm_health_goalInput, im_health_goal_dailyUncheckedUpdateWithoutIm_health_goalInput>
    create: XOR<im_health_goal_dailyCreateWithoutIm_health_goalInput, im_health_goal_dailyUncheckedCreateWithoutIm_health_goalInput>
  }

  export type im_health_goal_dailyUpdateWithWhereUniqueWithoutIm_health_goalInput = {
    where: im_health_goal_dailyWhereUniqueInput
    data: XOR<im_health_goal_dailyUpdateWithoutIm_health_goalInput, im_health_goal_dailyUncheckedUpdateWithoutIm_health_goalInput>
  }

  export type im_health_goal_dailyUpdateManyWithWhereWithoutIm_health_goalInput = {
    where: im_health_goal_dailyScalarWhereInput
    data: XOR<im_health_goal_dailyUpdateManyMutationInput, im_health_goal_dailyUncheckedUpdateManyWithoutIm_health_goalInput>
  }

  export type im_health_goal_dailyScalarWhereInput = {
    AND?: im_health_goal_dailyScalarWhereInput | im_health_goal_dailyScalarWhereInput[]
    OR?: im_health_goal_dailyScalarWhereInput[]
    NOT?: im_health_goal_dailyScalarWhereInput | im_health_goal_dailyScalarWhereInput[]
    id_health_goal_daily?: IntFilter<"im_health_goal_daily"> | number
    health_goal_daily_date?: DateTimeFilter<"im_health_goal_daily"> | Date | string
    health_goal_daily_steps?: IntFilter<"im_health_goal_daily"> | number
    health_goal_daily_weight?: IntFilter<"im_health_goal_daily"> | number
    health_goal_daily_sleep?: IntFilter<"im_health_goal_daily"> | number
    health_goal_daily_water?: IntFilter<"im_health_goal_daily"> | number
    id_health_goal?: IntFilter<"im_health_goal_daily"> | number
  }

  export type im_health_goalCreateWithoutIm_health_goal_dailyInput = {
    health_goal_steps: number
    health_goal_weight: number
    health_goal_sleep: number
    health_goal_water: number
    im_health: im_healthCreateNestedOneWithoutIm_health_goalInput
  }

  export type im_health_goalUncheckedCreateWithoutIm_health_goal_dailyInput = {
    id_health_goal?: number
    health_goal_steps: number
    health_goal_weight: number
    health_goal_sleep: number
    health_goal_water: number
    id_health: number
  }

  export type im_health_goalCreateOrConnectWithoutIm_health_goal_dailyInput = {
    where: im_health_goalWhereUniqueInput
    create: XOR<im_health_goalCreateWithoutIm_health_goal_dailyInput, im_health_goalUncheckedCreateWithoutIm_health_goal_dailyInput>
  }

  export type im_health_goal_daily_historyCreateWithoutIm_health_goal_dailyInput = {
    health_goal_daily_history_date: Date | string
  }

  export type im_health_goal_daily_historyUncheckedCreateWithoutIm_health_goal_dailyInput = {
    id_health_goal_daily_history?: number
    health_goal_daily_history_date: Date | string
  }

  export type im_health_goal_daily_historyCreateOrConnectWithoutIm_health_goal_dailyInput = {
    where: im_health_goal_daily_historyWhereUniqueInput
    create: XOR<im_health_goal_daily_historyCreateWithoutIm_health_goal_dailyInput, im_health_goal_daily_historyUncheckedCreateWithoutIm_health_goal_dailyInput>
  }

  export type im_health_goal_daily_historyCreateManyIm_health_goal_dailyInputEnvelope = {
    data: im_health_goal_daily_historyCreateManyIm_health_goal_dailyInput | im_health_goal_daily_historyCreateManyIm_health_goal_dailyInput[]
    skipDuplicates?: boolean
  }

  export type im_health_goalUpsertWithoutIm_health_goal_dailyInput = {
    update: XOR<im_health_goalUpdateWithoutIm_health_goal_dailyInput, im_health_goalUncheckedUpdateWithoutIm_health_goal_dailyInput>
    create: XOR<im_health_goalCreateWithoutIm_health_goal_dailyInput, im_health_goalUncheckedCreateWithoutIm_health_goal_dailyInput>
    where?: im_health_goalWhereInput
  }

  export type im_health_goalUpdateToOneWithWhereWithoutIm_health_goal_dailyInput = {
    where?: im_health_goalWhereInput
    data: XOR<im_health_goalUpdateWithoutIm_health_goal_dailyInput, im_health_goalUncheckedUpdateWithoutIm_health_goal_dailyInput>
  }

  export type im_health_goalUpdateWithoutIm_health_goal_dailyInput = {
    health_goal_steps?: IntFieldUpdateOperationsInput | number
    health_goal_weight?: IntFieldUpdateOperationsInput | number
    health_goal_sleep?: IntFieldUpdateOperationsInput | number
    health_goal_water?: IntFieldUpdateOperationsInput | number
    im_health?: im_healthUpdateOneRequiredWithoutIm_health_goalNestedInput
  }

  export type im_health_goalUncheckedUpdateWithoutIm_health_goal_dailyInput = {
    id_health_goal?: IntFieldUpdateOperationsInput | number
    health_goal_steps?: IntFieldUpdateOperationsInput | number
    health_goal_weight?: IntFieldUpdateOperationsInput | number
    health_goal_sleep?: IntFieldUpdateOperationsInput | number
    health_goal_water?: IntFieldUpdateOperationsInput | number
    id_health?: IntFieldUpdateOperationsInput | number
  }

  export type im_health_goal_daily_historyUpsertWithWhereUniqueWithoutIm_health_goal_dailyInput = {
    where: im_health_goal_daily_historyWhereUniqueInput
    update: XOR<im_health_goal_daily_historyUpdateWithoutIm_health_goal_dailyInput, im_health_goal_daily_historyUncheckedUpdateWithoutIm_health_goal_dailyInput>
    create: XOR<im_health_goal_daily_historyCreateWithoutIm_health_goal_dailyInput, im_health_goal_daily_historyUncheckedCreateWithoutIm_health_goal_dailyInput>
  }

  export type im_health_goal_daily_historyUpdateWithWhereUniqueWithoutIm_health_goal_dailyInput = {
    where: im_health_goal_daily_historyWhereUniqueInput
    data: XOR<im_health_goal_daily_historyUpdateWithoutIm_health_goal_dailyInput, im_health_goal_daily_historyUncheckedUpdateWithoutIm_health_goal_dailyInput>
  }

  export type im_health_goal_daily_historyUpdateManyWithWhereWithoutIm_health_goal_dailyInput = {
    where: im_health_goal_daily_historyScalarWhereInput
    data: XOR<im_health_goal_daily_historyUpdateManyMutationInput, im_health_goal_daily_historyUncheckedUpdateManyWithoutIm_health_goal_dailyInput>
  }

  export type im_health_goal_daily_historyScalarWhereInput = {
    AND?: im_health_goal_daily_historyScalarWhereInput | im_health_goal_daily_historyScalarWhereInput[]
    OR?: im_health_goal_daily_historyScalarWhereInput[]
    NOT?: im_health_goal_daily_historyScalarWhereInput | im_health_goal_daily_historyScalarWhereInput[]
    id_health_goal_daily_history?: IntFilter<"im_health_goal_daily_history"> | number
    health_goal_daily_history_date?: DateTimeFilter<"im_health_goal_daily_history"> | Date | string
    id_health_goal_daily?: IntFilter<"im_health_goal_daily_history"> | number
  }

  export type im_health_goal_dailyCreateWithoutIm_health_goal_daily_historyInput = {
    health_goal_daily_date: Date | string
    health_goal_daily_steps: number
    health_goal_daily_weight: number
    health_goal_daily_sleep: number
    health_goal_daily_water: number
    im_health_goal: im_health_goalCreateNestedOneWithoutIm_health_goal_dailyInput
  }

  export type im_health_goal_dailyUncheckedCreateWithoutIm_health_goal_daily_historyInput = {
    id_health_goal_daily?: number
    health_goal_daily_date: Date | string
    health_goal_daily_steps: number
    health_goal_daily_weight: number
    health_goal_daily_sleep: number
    health_goal_daily_water: number
    id_health_goal: number
  }

  export type im_health_goal_dailyCreateOrConnectWithoutIm_health_goal_daily_historyInput = {
    where: im_health_goal_dailyWhereUniqueInput
    create: XOR<im_health_goal_dailyCreateWithoutIm_health_goal_daily_historyInput, im_health_goal_dailyUncheckedCreateWithoutIm_health_goal_daily_historyInput>
  }

  export type im_health_goal_dailyUpsertWithoutIm_health_goal_daily_historyInput = {
    update: XOR<im_health_goal_dailyUpdateWithoutIm_health_goal_daily_historyInput, im_health_goal_dailyUncheckedUpdateWithoutIm_health_goal_daily_historyInput>
    create: XOR<im_health_goal_dailyCreateWithoutIm_health_goal_daily_historyInput, im_health_goal_dailyUncheckedCreateWithoutIm_health_goal_daily_historyInput>
    where?: im_health_goal_dailyWhereInput
  }

  export type im_health_goal_dailyUpdateToOneWithWhereWithoutIm_health_goal_daily_historyInput = {
    where?: im_health_goal_dailyWhereInput
    data: XOR<im_health_goal_dailyUpdateWithoutIm_health_goal_daily_historyInput, im_health_goal_dailyUncheckedUpdateWithoutIm_health_goal_daily_historyInput>
  }

  export type im_health_goal_dailyUpdateWithoutIm_health_goal_daily_historyInput = {
    health_goal_daily_date?: DateTimeFieldUpdateOperationsInput | Date | string
    health_goal_daily_steps?: IntFieldUpdateOperationsInput | number
    health_goal_daily_weight?: IntFieldUpdateOperationsInput | number
    health_goal_daily_sleep?: IntFieldUpdateOperationsInput | number
    health_goal_daily_water?: IntFieldUpdateOperationsInput | number
    im_health_goal?: im_health_goalUpdateOneRequiredWithoutIm_health_goal_dailyNestedInput
  }

  export type im_health_goal_dailyUncheckedUpdateWithoutIm_health_goal_daily_historyInput = {
    id_health_goal_daily?: IntFieldUpdateOperationsInput | number
    health_goal_daily_date?: DateTimeFieldUpdateOperationsInput | Date | string
    health_goal_daily_steps?: IntFieldUpdateOperationsInput | number
    health_goal_daily_weight?: IntFieldUpdateOperationsInput | number
    health_goal_daily_sleep?: IntFieldUpdateOperationsInput | number
    health_goal_daily_water?: IntFieldUpdateOperationsInput | number
    id_health_goal?: IntFieldUpdateOperationsInput | number
  }

  export type im_nutritionCreateWithoutIm_mealInput = {
    nutrition_goal: number
    nutrition_goal_calories: number
    nutrition_goal_carbs: number
    nutrition_goal_prots: number
    nutrition_goal_fats: number
    im_user: im_userCreateNestedOneWithoutIm_nutritionInput
  }

  export type im_nutritionUncheckedCreateWithoutIm_mealInput = {
    id_nutrition?: number
    nutrition_goal: number
    nutrition_goal_calories: number
    nutrition_goal_carbs: number
    nutrition_goal_prots: number
    nutrition_goal_fats: number
    id_user: number
  }

  export type im_nutritionCreateOrConnectWithoutIm_mealInput = {
    where: im_nutritionWhereUniqueInput
    create: XOR<im_nutritionCreateWithoutIm_mealInput, im_nutritionUncheckedCreateWithoutIm_mealInput>
  }

  export type im_recipeCreateWithoutIm_mealInput = {
    im_food: im_foodCreateNestedOneWithoutIm_recipeInput
  }

  export type im_recipeUncheckedCreateWithoutIm_mealInput = {
    id_recipe?: number
    id_food: number
  }

  export type im_recipeCreateOrConnectWithoutIm_mealInput = {
    where: im_recipeWhereUniqueInput
    create: XOR<im_recipeCreateWithoutIm_mealInput, im_recipeUncheckedCreateWithoutIm_mealInput>
  }

  export type im_recipeCreateManyIm_mealInputEnvelope = {
    data: im_recipeCreateManyIm_mealInput | im_recipeCreateManyIm_mealInput[]
    skipDuplicates?: boolean
  }

  export type im_nutritionUpsertWithoutIm_mealInput = {
    update: XOR<im_nutritionUpdateWithoutIm_mealInput, im_nutritionUncheckedUpdateWithoutIm_mealInput>
    create: XOR<im_nutritionCreateWithoutIm_mealInput, im_nutritionUncheckedCreateWithoutIm_mealInput>
    where?: im_nutritionWhereInput
  }

  export type im_nutritionUpdateToOneWithWhereWithoutIm_mealInput = {
    where?: im_nutritionWhereInput
    data: XOR<im_nutritionUpdateWithoutIm_mealInput, im_nutritionUncheckedUpdateWithoutIm_mealInput>
  }

  export type im_nutritionUpdateWithoutIm_mealInput = {
    nutrition_goal?: IntFieldUpdateOperationsInput | number
    nutrition_goal_calories?: IntFieldUpdateOperationsInput | number
    nutrition_goal_carbs?: IntFieldUpdateOperationsInput | number
    nutrition_goal_prots?: IntFieldUpdateOperationsInput | number
    nutrition_goal_fats?: IntFieldUpdateOperationsInput | number
    im_user?: im_userUpdateOneRequiredWithoutIm_nutritionNestedInput
  }

  export type im_nutritionUncheckedUpdateWithoutIm_mealInput = {
    id_nutrition?: IntFieldUpdateOperationsInput | number
    nutrition_goal?: IntFieldUpdateOperationsInput | number
    nutrition_goal_calories?: IntFieldUpdateOperationsInput | number
    nutrition_goal_carbs?: IntFieldUpdateOperationsInput | number
    nutrition_goal_prots?: IntFieldUpdateOperationsInput | number
    nutrition_goal_fats?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
  }

  export type im_recipeUpsertWithWhereUniqueWithoutIm_mealInput = {
    where: im_recipeWhereUniqueInput
    update: XOR<im_recipeUpdateWithoutIm_mealInput, im_recipeUncheckedUpdateWithoutIm_mealInput>
    create: XOR<im_recipeCreateWithoutIm_mealInput, im_recipeUncheckedCreateWithoutIm_mealInput>
  }

  export type im_recipeUpdateWithWhereUniqueWithoutIm_mealInput = {
    where: im_recipeWhereUniqueInput
    data: XOR<im_recipeUpdateWithoutIm_mealInput, im_recipeUncheckedUpdateWithoutIm_mealInput>
  }

  export type im_recipeUpdateManyWithWhereWithoutIm_mealInput = {
    where: im_recipeScalarWhereInput
    data: XOR<im_recipeUpdateManyMutationInput, im_recipeUncheckedUpdateManyWithoutIm_mealInput>
  }

  export type im_mealCreateWithoutIm_nutritionInput = {
    meal_name: string
    meal_quantity: number
    meal_calories: number
    meal_carbs: number
    meal_prots: number
    meal_fats: number
    meal_description: string
    meal_length: number
    meal_image: string
    meal_difficulty: number
    meal_season: number
    im_recipe?: im_recipeCreateNestedManyWithoutIm_mealInput
  }

  export type im_mealUncheckedCreateWithoutIm_nutritionInput = {
    id_meal?: number
    meal_name: string
    meal_quantity: number
    meal_calories: number
    meal_carbs: number
    meal_prots: number
    meal_fats: number
    meal_description: string
    meal_length: number
    meal_image: string
    meal_difficulty: number
    meal_season: number
    im_recipe?: im_recipeUncheckedCreateNestedManyWithoutIm_mealInput
  }

  export type im_mealCreateOrConnectWithoutIm_nutritionInput = {
    where: im_mealWhereUniqueInput
    create: XOR<im_mealCreateWithoutIm_nutritionInput, im_mealUncheckedCreateWithoutIm_nutritionInput>
  }

  export type im_mealCreateManyIm_nutritionInputEnvelope = {
    data: im_mealCreateManyIm_nutritionInput | im_mealCreateManyIm_nutritionInput[]
    skipDuplicates?: boolean
  }

  export type im_userCreateWithoutIm_nutritionInput = {
    user_firstname: string
    user_name: string
    user_mail: string
    user_password: string
    user_birth_date: Date | string
    user_inscription_date: Date | string
    user_gender: number
    user_height: number
    user_weight: number
    user_age: number
    user_training_level: number
    user_nutrition_diet: number
    im_health?: im_healthCreateNestedManyWithoutIm_userInput
    im_training?: im_trainingCreateNestedManyWithoutIm_userInput
    im_undesirable_food?: im_undesirable_foodCreateNestedManyWithoutIm_userInput
  }

  export type im_userUncheckedCreateWithoutIm_nutritionInput = {
    id_user?: number
    user_firstname: string
    user_name: string
    user_mail: string
    user_password: string
    user_birth_date: Date | string
    user_inscription_date: Date | string
    user_gender: number
    user_height: number
    user_weight: number
    user_age: number
    user_training_level: number
    user_nutrition_diet: number
    im_health?: im_healthUncheckedCreateNestedManyWithoutIm_userInput
    im_training?: im_trainingUncheckedCreateNestedManyWithoutIm_userInput
    im_undesirable_food?: im_undesirable_foodUncheckedCreateNestedManyWithoutIm_userInput
  }

  export type im_userCreateOrConnectWithoutIm_nutritionInput = {
    where: im_userWhereUniqueInput
    create: XOR<im_userCreateWithoutIm_nutritionInput, im_userUncheckedCreateWithoutIm_nutritionInput>
  }

  export type im_mealUpsertWithWhereUniqueWithoutIm_nutritionInput = {
    where: im_mealWhereUniqueInput
    update: XOR<im_mealUpdateWithoutIm_nutritionInput, im_mealUncheckedUpdateWithoutIm_nutritionInput>
    create: XOR<im_mealCreateWithoutIm_nutritionInput, im_mealUncheckedCreateWithoutIm_nutritionInput>
  }

  export type im_mealUpdateWithWhereUniqueWithoutIm_nutritionInput = {
    where: im_mealWhereUniqueInput
    data: XOR<im_mealUpdateWithoutIm_nutritionInput, im_mealUncheckedUpdateWithoutIm_nutritionInput>
  }

  export type im_mealUpdateManyWithWhereWithoutIm_nutritionInput = {
    where: im_mealScalarWhereInput
    data: XOR<im_mealUpdateManyMutationInput, im_mealUncheckedUpdateManyWithoutIm_nutritionInput>
  }

  export type im_mealScalarWhereInput = {
    AND?: im_mealScalarWhereInput | im_mealScalarWhereInput[]
    OR?: im_mealScalarWhereInput[]
    NOT?: im_mealScalarWhereInput | im_mealScalarWhereInput[]
    id_meal?: IntFilter<"im_meal"> | number
    meal_name?: StringFilter<"im_meal"> | string
    meal_quantity?: IntFilter<"im_meal"> | number
    meal_calories?: IntFilter<"im_meal"> | number
    meal_carbs?: IntFilter<"im_meal"> | number
    meal_prots?: IntFilter<"im_meal"> | number
    meal_fats?: IntFilter<"im_meal"> | number
    meal_description?: StringFilter<"im_meal"> | string
    meal_length?: IntFilter<"im_meal"> | number
    meal_image?: StringFilter<"im_meal"> | string
    meal_difficulty?: IntFilter<"im_meal"> | number
    meal_season?: IntFilter<"im_meal"> | number
    id_nutrition?: IntFilter<"im_meal"> | number
  }

  export type im_userUpsertWithoutIm_nutritionInput = {
    update: XOR<im_userUpdateWithoutIm_nutritionInput, im_userUncheckedUpdateWithoutIm_nutritionInput>
    create: XOR<im_userCreateWithoutIm_nutritionInput, im_userUncheckedCreateWithoutIm_nutritionInput>
    where?: im_userWhereInput
  }

  export type im_userUpdateToOneWithWhereWithoutIm_nutritionInput = {
    where?: im_userWhereInput
    data: XOR<im_userUpdateWithoutIm_nutritionInput, im_userUncheckedUpdateWithoutIm_nutritionInput>
  }

  export type im_userUpdateWithoutIm_nutritionInput = {
    user_firstname?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_mail?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    user_birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_inscription_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_gender?: IntFieldUpdateOperationsInput | number
    user_height?: IntFieldUpdateOperationsInput | number
    user_weight?: IntFieldUpdateOperationsInput | number
    user_age?: IntFieldUpdateOperationsInput | number
    user_training_level?: IntFieldUpdateOperationsInput | number
    user_nutrition_diet?: IntFieldUpdateOperationsInput | number
    im_health?: im_healthUpdateManyWithoutIm_userNestedInput
    im_training?: im_trainingUpdateManyWithoutIm_userNestedInput
    im_undesirable_food?: im_undesirable_foodUpdateManyWithoutIm_userNestedInput
  }

  export type im_userUncheckedUpdateWithoutIm_nutritionInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    user_firstname?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_mail?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    user_birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_inscription_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_gender?: IntFieldUpdateOperationsInput | number
    user_height?: IntFieldUpdateOperationsInput | number
    user_weight?: IntFieldUpdateOperationsInput | number
    user_age?: IntFieldUpdateOperationsInput | number
    user_training_level?: IntFieldUpdateOperationsInput | number
    user_nutrition_diet?: IntFieldUpdateOperationsInput | number
    im_health?: im_healthUncheckedUpdateManyWithoutIm_userNestedInput
    im_training?: im_trainingUncheckedUpdateManyWithoutIm_userNestedInput
    im_undesirable_food?: im_undesirable_foodUncheckedUpdateManyWithoutIm_userNestedInput
  }

  export type im_mealCreateWithoutIm_recipeInput = {
    meal_name: string
    meal_quantity: number
    meal_calories: number
    meal_carbs: number
    meal_prots: number
    meal_fats: number
    meal_description: string
    meal_length: number
    meal_image: string
    meal_difficulty: number
    meal_season: number
    im_nutrition: im_nutritionCreateNestedOneWithoutIm_mealInput
  }

  export type im_mealUncheckedCreateWithoutIm_recipeInput = {
    id_meal?: number
    meal_name: string
    meal_quantity: number
    meal_calories: number
    meal_carbs: number
    meal_prots: number
    meal_fats: number
    meal_description: string
    meal_length: number
    meal_image: string
    meal_difficulty: number
    meal_season: number
    id_nutrition: number
  }

  export type im_mealCreateOrConnectWithoutIm_recipeInput = {
    where: im_mealWhereUniqueInput
    create: XOR<im_mealCreateWithoutIm_recipeInput, im_mealUncheckedCreateWithoutIm_recipeInput>
  }

  export type im_foodCreateWithoutIm_recipeInput = {
    food_name: string
    food_type: string
    food_calories: number
    food_carbs: number
    food_prots: number
    food_fats: number
    im_undesirable_food?: im_undesirable_foodCreateNestedManyWithoutIm_foodInput
  }

  export type im_foodUncheckedCreateWithoutIm_recipeInput = {
    id_food?: number
    food_name: string
    food_type: string
    food_calories: number
    food_carbs: number
    food_prots: number
    food_fats: number
    im_undesirable_food?: im_undesirable_foodUncheckedCreateNestedManyWithoutIm_foodInput
  }

  export type im_foodCreateOrConnectWithoutIm_recipeInput = {
    where: im_foodWhereUniqueInput
    create: XOR<im_foodCreateWithoutIm_recipeInput, im_foodUncheckedCreateWithoutIm_recipeInput>
  }

  export type im_mealUpsertWithoutIm_recipeInput = {
    update: XOR<im_mealUpdateWithoutIm_recipeInput, im_mealUncheckedUpdateWithoutIm_recipeInput>
    create: XOR<im_mealCreateWithoutIm_recipeInput, im_mealUncheckedCreateWithoutIm_recipeInput>
    where?: im_mealWhereInput
  }

  export type im_mealUpdateToOneWithWhereWithoutIm_recipeInput = {
    where?: im_mealWhereInput
    data: XOR<im_mealUpdateWithoutIm_recipeInput, im_mealUncheckedUpdateWithoutIm_recipeInput>
  }

  export type im_mealUpdateWithoutIm_recipeInput = {
    meal_name?: StringFieldUpdateOperationsInput | string
    meal_quantity?: IntFieldUpdateOperationsInput | number
    meal_calories?: IntFieldUpdateOperationsInput | number
    meal_carbs?: IntFieldUpdateOperationsInput | number
    meal_prots?: IntFieldUpdateOperationsInput | number
    meal_fats?: IntFieldUpdateOperationsInput | number
    meal_description?: StringFieldUpdateOperationsInput | string
    meal_length?: IntFieldUpdateOperationsInput | number
    meal_image?: StringFieldUpdateOperationsInput | string
    meal_difficulty?: IntFieldUpdateOperationsInput | number
    meal_season?: IntFieldUpdateOperationsInput | number
    im_nutrition?: im_nutritionUpdateOneRequiredWithoutIm_mealNestedInput
  }

  export type im_mealUncheckedUpdateWithoutIm_recipeInput = {
    id_meal?: IntFieldUpdateOperationsInput | number
    meal_name?: StringFieldUpdateOperationsInput | string
    meal_quantity?: IntFieldUpdateOperationsInput | number
    meal_calories?: IntFieldUpdateOperationsInput | number
    meal_carbs?: IntFieldUpdateOperationsInput | number
    meal_prots?: IntFieldUpdateOperationsInput | number
    meal_fats?: IntFieldUpdateOperationsInput | number
    meal_description?: StringFieldUpdateOperationsInput | string
    meal_length?: IntFieldUpdateOperationsInput | number
    meal_image?: StringFieldUpdateOperationsInput | string
    meal_difficulty?: IntFieldUpdateOperationsInput | number
    meal_season?: IntFieldUpdateOperationsInput | number
    id_nutrition?: IntFieldUpdateOperationsInput | number
  }

  export type im_foodUpsertWithoutIm_recipeInput = {
    update: XOR<im_foodUpdateWithoutIm_recipeInput, im_foodUncheckedUpdateWithoutIm_recipeInput>
    create: XOR<im_foodCreateWithoutIm_recipeInput, im_foodUncheckedCreateWithoutIm_recipeInput>
    where?: im_foodWhereInput
  }

  export type im_foodUpdateToOneWithWhereWithoutIm_recipeInput = {
    where?: im_foodWhereInput
    data: XOR<im_foodUpdateWithoutIm_recipeInput, im_foodUncheckedUpdateWithoutIm_recipeInput>
  }

  export type im_foodUpdateWithoutIm_recipeInput = {
    food_name?: StringFieldUpdateOperationsInput | string
    food_type?: StringFieldUpdateOperationsInput | string
    food_calories?: IntFieldUpdateOperationsInput | number
    food_carbs?: IntFieldUpdateOperationsInput | number
    food_prots?: IntFieldUpdateOperationsInput | number
    food_fats?: IntFieldUpdateOperationsInput | number
    im_undesirable_food?: im_undesirable_foodUpdateManyWithoutIm_foodNestedInput
  }

  export type im_foodUncheckedUpdateWithoutIm_recipeInput = {
    id_food?: IntFieldUpdateOperationsInput | number
    food_name?: StringFieldUpdateOperationsInput | string
    food_type?: StringFieldUpdateOperationsInput | string
    food_calories?: IntFieldUpdateOperationsInput | number
    food_carbs?: IntFieldUpdateOperationsInput | number
    food_prots?: IntFieldUpdateOperationsInput | number
    food_fats?: IntFieldUpdateOperationsInput | number
    im_undesirable_food?: im_undesirable_foodUncheckedUpdateManyWithoutIm_foodNestedInput
  }

  export type im_userCreateWithoutIm_trainingInput = {
    user_firstname: string
    user_name: string
    user_mail: string
    user_password: string
    user_birth_date: Date | string
    user_inscription_date: Date | string
    user_gender: number
    user_height: number
    user_weight: number
    user_age: number
    user_training_level: number
    user_nutrition_diet: number
    im_health?: im_healthCreateNestedManyWithoutIm_userInput
    im_nutrition?: im_nutritionCreateNestedManyWithoutIm_userInput
    im_undesirable_food?: im_undesirable_foodCreateNestedManyWithoutIm_userInput
  }

  export type im_userUncheckedCreateWithoutIm_trainingInput = {
    id_user?: number
    user_firstname: string
    user_name: string
    user_mail: string
    user_password: string
    user_birth_date: Date | string
    user_inscription_date: Date | string
    user_gender: number
    user_height: number
    user_weight: number
    user_age: number
    user_training_level: number
    user_nutrition_diet: number
    im_health?: im_healthUncheckedCreateNestedManyWithoutIm_userInput
    im_nutrition?: im_nutritionUncheckedCreateNestedManyWithoutIm_userInput
    im_undesirable_food?: im_undesirable_foodUncheckedCreateNestedManyWithoutIm_userInput
  }

  export type im_userCreateOrConnectWithoutIm_trainingInput = {
    where: im_userWhereUniqueInput
    create: XOR<im_userCreateWithoutIm_trainingInput, im_userUncheckedCreateWithoutIm_trainingInput>
  }

  export type im_workoutCreateWithoutIm_trainingInput = {
    workout_point: number
    workout_name: string
    workout_comment: string
    im_exercise?: im_exerciseCreateNestedManyWithoutIm_workoutInput
  }

  export type im_workoutUncheckedCreateWithoutIm_trainingInput = {
    id_workout?: number
    workout_point: number
    workout_name: string
    workout_comment: string
    im_exercise?: im_exerciseUncheckedCreateNestedManyWithoutIm_workoutInput
  }

  export type im_workoutCreateOrConnectWithoutIm_trainingInput = {
    where: im_workoutWhereUniqueInput
    create: XOR<im_workoutCreateWithoutIm_trainingInput, im_workoutUncheckedCreateWithoutIm_trainingInput>
  }

  export type im_workoutCreateManyIm_trainingInputEnvelope = {
    data: im_workoutCreateManyIm_trainingInput | im_workoutCreateManyIm_trainingInput[]
    skipDuplicates?: boolean
  }

  export type im_userUpsertWithoutIm_trainingInput = {
    update: XOR<im_userUpdateWithoutIm_trainingInput, im_userUncheckedUpdateWithoutIm_trainingInput>
    create: XOR<im_userCreateWithoutIm_trainingInput, im_userUncheckedCreateWithoutIm_trainingInput>
    where?: im_userWhereInput
  }

  export type im_userUpdateToOneWithWhereWithoutIm_trainingInput = {
    where?: im_userWhereInput
    data: XOR<im_userUpdateWithoutIm_trainingInput, im_userUncheckedUpdateWithoutIm_trainingInput>
  }

  export type im_userUpdateWithoutIm_trainingInput = {
    user_firstname?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_mail?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    user_birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_inscription_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_gender?: IntFieldUpdateOperationsInput | number
    user_height?: IntFieldUpdateOperationsInput | number
    user_weight?: IntFieldUpdateOperationsInput | number
    user_age?: IntFieldUpdateOperationsInput | number
    user_training_level?: IntFieldUpdateOperationsInput | number
    user_nutrition_diet?: IntFieldUpdateOperationsInput | number
    im_health?: im_healthUpdateManyWithoutIm_userNestedInput
    im_nutrition?: im_nutritionUpdateManyWithoutIm_userNestedInput
    im_undesirable_food?: im_undesirable_foodUpdateManyWithoutIm_userNestedInput
  }

  export type im_userUncheckedUpdateWithoutIm_trainingInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    user_firstname?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_mail?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    user_birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_inscription_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_gender?: IntFieldUpdateOperationsInput | number
    user_height?: IntFieldUpdateOperationsInput | number
    user_weight?: IntFieldUpdateOperationsInput | number
    user_age?: IntFieldUpdateOperationsInput | number
    user_training_level?: IntFieldUpdateOperationsInput | number
    user_nutrition_diet?: IntFieldUpdateOperationsInput | number
    im_health?: im_healthUncheckedUpdateManyWithoutIm_userNestedInput
    im_nutrition?: im_nutritionUncheckedUpdateManyWithoutIm_userNestedInput
    im_undesirable_food?: im_undesirable_foodUncheckedUpdateManyWithoutIm_userNestedInput
  }

  export type im_workoutUpsertWithWhereUniqueWithoutIm_trainingInput = {
    where: im_workoutWhereUniqueInput
    update: XOR<im_workoutUpdateWithoutIm_trainingInput, im_workoutUncheckedUpdateWithoutIm_trainingInput>
    create: XOR<im_workoutCreateWithoutIm_trainingInput, im_workoutUncheckedCreateWithoutIm_trainingInput>
  }

  export type im_workoutUpdateWithWhereUniqueWithoutIm_trainingInput = {
    where: im_workoutWhereUniqueInput
    data: XOR<im_workoutUpdateWithoutIm_trainingInput, im_workoutUncheckedUpdateWithoutIm_trainingInput>
  }

  export type im_workoutUpdateManyWithWhereWithoutIm_trainingInput = {
    where: im_workoutScalarWhereInput
    data: XOR<im_workoutUpdateManyMutationInput, im_workoutUncheckedUpdateManyWithoutIm_trainingInput>
  }

  export type im_workoutScalarWhereInput = {
    AND?: im_workoutScalarWhereInput | im_workoutScalarWhereInput[]
    OR?: im_workoutScalarWhereInput[]
    NOT?: im_workoutScalarWhereInput | im_workoutScalarWhereInput[]
    id_workout?: IntFilter<"im_workout"> | number
    workout_point?: IntFilter<"im_workout"> | number
    workout_name?: StringFilter<"im_workout"> | string
    workout_comment?: StringFilter<"im_workout"> | string
    id_training?: IntFilter<"im_workout"> | number
  }

  export type im_userCreateWithoutIm_undesirable_foodInput = {
    user_firstname: string
    user_name: string
    user_mail: string
    user_password: string
    user_birth_date: Date | string
    user_inscription_date: Date | string
    user_gender: number
    user_height: number
    user_weight: number
    user_age: number
    user_training_level: number
    user_nutrition_diet: number
    im_health?: im_healthCreateNestedManyWithoutIm_userInput
    im_nutrition?: im_nutritionCreateNestedManyWithoutIm_userInput
    im_training?: im_trainingCreateNestedManyWithoutIm_userInput
  }

  export type im_userUncheckedCreateWithoutIm_undesirable_foodInput = {
    id_user?: number
    user_firstname: string
    user_name: string
    user_mail: string
    user_password: string
    user_birth_date: Date | string
    user_inscription_date: Date | string
    user_gender: number
    user_height: number
    user_weight: number
    user_age: number
    user_training_level: number
    user_nutrition_diet: number
    im_health?: im_healthUncheckedCreateNestedManyWithoutIm_userInput
    im_nutrition?: im_nutritionUncheckedCreateNestedManyWithoutIm_userInput
    im_training?: im_trainingUncheckedCreateNestedManyWithoutIm_userInput
  }

  export type im_userCreateOrConnectWithoutIm_undesirable_foodInput = {
    where: im_userWhereUniqueInput
    create: XOR<im_userCreateWithoutIm_undesirable_foodInput, im_userUncheckedCreateWithoutIm_undesirable_foodInput>
  }

  export type im_foodCreateWithoutIm_undesirable_foodInput = {
    food_name: string
    food_type: string
    food_calories: number
    food_carbs: number
    food_prots: number
    food_fats: number
    im_recipe?: im_recipeCreateNestedManyWithoutIm_foodInput
  }

  export type im_foodUncheckedCreateWithoutIm_undesirable_foodInput = {
    id_food?: number
    food_name: string
    food_type: string
    food_calories: number
    food_carbs: number
    food_prots: number
    food_fats: number
    im_recipe?: im_recipeUncheckedCreateNestedManyWithoutIm_foodInput
  }

  export type im_foodCreateOrConnectWithoutIm_undesirable_foodInput = {
    where: im_foodWhereUniqueInput
    create: XOR<im_foodCreateWithoutIm_undesirable_foodInput, im_foodUncheckedCreateWithoutIm_undesirable_foodInput>
  }

  export type im_userUpsertWithoutIm_undesirable_foodInput = {
    update: XOR<im_userUpdateWithoutIm_undesirable_foodInput, im_userUncheckedUpdateWithoutIm_undesirable_foodInput>
    create: XOR<im_userCreateWithoutIm_undesirable_foodInput, im_userUncheckedCreateWithoutIm_undesirable_foodInput>
    where?: im_userWhereInput
  }

  export type im_userUpdateToOneWithWhereWithoutIm_undesirable_foodInput = {
    where?: im_userWhereInput
    data: XOR<im_userUpdateWithoutIm_undesirable_foodInput, im_userUncheckedUpdateWithoutIm_undesirable_foodInput>
  }

  export type im_userUpdateWithoutIm_undesirable_foodInput = {
    user_firstname?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_mail?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    user_birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_inscription_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_gender?: IntFieldUpdateOperationsInput | number
    user_height?: IntFieldUpdateOperationsInput | number
    user_weight?: IntFieldUpdateOperationsInput | number
    user_age?: IntFieldUpdateOperationsInput | number
    user_training_level?: IntFieldUpdateOperationsInput | number
    user_nutrition_diet?: IntFieldUpdateOperationsInput | number
    im_health?: im_healthUpdateManyWithoutIm_userNestedInput
    im_nutrition?: im_nutritionUpdateManyWithoutIm_userNestedInput
    im_training?: im_trainingUpdateManyWithoutIm_userNestedInput
  }

  export type im_userUncheckedUpdateWithoutIm_undesirable_foodInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    user_firstname?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_mail?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    user_birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_inscription_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_gender?: IntFieldUpdateOperationsInput | number
    user_height?: IntFieldUpdateOperationsInput | number
    user_weight?: IntFieldUpdateOperationsInput | number
    user_age?: IntFieldUpdateOperationsInput | number
    user_training_level?: IntFieldUpdateOperationsInput | number
    user_nutrition_diet?: IntFieldUpdateOperationsInput | number
    im_health?: im_healthUncheckedUpdateManyWithoutIm_userNestedInput
    im_nutrition?: im_nutritionUncheckedUpdateManyWithoutIm_userNestedInput
    im_training?: im_trainingUncheckedUpdateManyWithoutIm_userNestedInput
  }

  export type im_foodUpsertWithoutIm_undesirable_foodInput = {
    update: XOR<im_foodUpdateWithoutIm_undesirable_foodInput, im_foodUncheckedUpdateWithoutIm_undesirable_foodInput>
    create: XOR<im_foodCreateWithoutIm_undesirable_foodInput, im_foodUncheckedCreateWithoutIm_undesirable_foodInput>
    where?: im_foodWhereInput
  }

  export type im_foodUpdateToOneWithWhereWithoutIm_undesirable_foodInput = {
    where?: im_foodWhereInput
    data: XOR<im_foodUpdateWithoutIm_undesirable_foodInput, im_foodUncheckedUpdateWithoutIm_undesirable_foodInput>
  }

  export type im_foodUpdateWithoutIm_undesirable_foodInput = {
    food_name?: StringFieldUpdateOperationsInput | string
    food_type?: StringFieldUpdateOperationsInput | string
    food_calories?: IntFieldUpdateOperationsInput | number
    food_carbs?: IntFieldUpdateOperationsInput | number
    food_prots?: IntFieldUpdateOperationsInput | number
    food_fats?: IntFieldUpdateOperationsInput | number
    im_recipe?: im_recipeUpdateManyWithoutIm_foodNestedInput
  }

  export type im_foodUncheckedUpdateWithoutIm_undesirable_foodInput = {
    id_food?: IntFieldUpdateOperationsInput | number
    food_name?: StringFieldUpdateOperationsInput | string
    food_type?: StringFieldUpdateOperationsInput | string
    food_calories?: IntFieldUpdateOperationsInput | number
    food_carbs?: IntFieldUpdateOperationsInput | number
    food_prots?: IntFieldUpdateOperationsInput | number
    food_fats?: IntFieldUpdateOperationsInput | number
    im_recipe?: im_recipeUncheckedUpdateManyWithoutIm_foodNestedInput
  }

  export type im_healthCreateWithoutIm_userInput = {
    im_health_goal?: im_health_goalCreateNestedManyWithoutIm_healthInput
  }

  export type im_healthUncheckedCreateWithoutIm_userInput = {
    id_health?: number
    im_health_goal?: im_health_goalUncheckedCreateNestedManyWithoutIm_healthInput
  }

  export type im_healthCreateOrConnectWithoutIm_userInput = {
    where: im_healthWhereUniqueInput
    create: XOR<im_healthCreateWithoutIm_userInput, im_healthUncheckedCreateWithoutIm_userInput>
  }

  export type im_healthCreateManyIm_userInputEnvelope = {
    data: im_healthCreateManyIm_userInput | im_healthCreateManyIm_userInput[]
    skipDuplicates?: boolean
  }

  export type im_nutritionCreateWithoutIm_userInput = {
    nutrition_goal: number
    nutrition_goal_calories: number
    nutrition_goal_carbs: number
    nutrition_goal_prots: number
    nutrition_goal_fats: number
    im_meal?: im_mealCreateNestedManyWithoutIm_nutritionInput
  }

  export type im_nutritionUncheckedCreateWithoutIm_userInput = {
    id_nutrition?: number
    nutrition_goal: number
    nutrition_goal_calories: number
    nutrition_goal_carbs: number
    nutrition_goal_prots: number
    nutrition_goal_fats: number
    im_meal?: im_mealUncheckedCreateNestedManyWithoutIm_nutritionInput
  }

  export type im_nutritionCreateOrConnectWithoutIm_userInput = {
    where: im_nutritionWhereUniqueInput
    create: XOR<im_nutritionCreateWithoutIm_userInput, im_nutritionUncheckedCreateWithoutIm_userInput>
  }

  export type im_nutritionCreateManyIm_userInputEnvelope = {
    data: im_nutritionCreateManyIm_userInput | im_nutritionCreateManyIm_userInput[]
    skipDuplicates?: boolean
  }

  export type im_trainingCreateWithoutIm_userInput = {
    training_goal: string
    im_workout?: im_workoutCreateNestedManyWithoutIm_trainingInput
  }

  export type im_trainingUncheckedCreateWithoutIm_userInput = {
    id_training?: number
    training_goal: string
    im_workout?: im_workoutUncheckedCreateNestedManyWithoutIm_trainingInput
  }

  export type im_trainingCreateOrConnectWithoutIm_userInput = {
    where: im_trainingWhereUniqueInput
    create: XOR<im_trainingCreateWithoutIm_userInput, im_trainingUncheckedCreateWithoutIm_userInput>
  }

  export type im_trainingCreateManyIm_userInputEnvelope = {
    data: im_trainingCreateManyIm_userInput | im_trainingCreateManyIm_userInput[]
    skipDuplicates?: boolean
  }

  export type im_undesirable_foodCreateWithoutIm_userInput = {
    im_food: im_foodCreateNestedOneWithoutIm_undesirable_foodInput
  }

  export type im_undesirable_foodUncheckedCreateWithoutIm_userInput = {
    id_undesirable_food?: number
    id_food: number
  }

  export type im_undesirable_foodCreateOrConnectWithoutIm_userInput = {
    where: im_undesirable_foodWhereUniqueInput
    create: XOR<im_undesirable_foodCreateWithoutIm_userInput, im_undesirable_foodUncheckedCreateWithoutIm_userInput>
  }

  export type im_undesirable_foodCreateManyIm_userInputEnvelope = {
    data: im_undesirable_foodCreateManyIm_userInput | im_undesirable_foodCreateManyIm_userInput[]
    skipDuplicates?: boolean
  }

  export type im_healthUpsertWithWhereUniqueWithoutIm_userInput = {
    where: im_healthWhereUniqueInput
    update: XOR<im_healthUpdateWithoutIm_userInput, im_healthUncheckedUpdateWithoutIm_userInput>
    create: XOR<im_healthCreateWithoutIm_userInput, im_healthUncheckedCreateWithoutIm_userInput>
  }

  export type im_healthUpdateWithWhereUniqueWithoutIm_userInput = {
    where: im_healthWhereUniqueInput
    data: XOR<im_healthUpdateWithoutIm_userInput, im_healthUncheckedUpdateWithoutIm_userInput>
  }

  export type im_healthUpdateManyWithWhereWithoutIm_userInput = {
    where: im_healthScalarWhereInput
    data: XOR<im_healthUpdateManyMutationInput, im_healthUncheckedUpdateManyWithoutIm_userInput>
  }

  export type im_healthScalarWhereInput = {
    AND?: im_healthScalarWhereInput | im_healthScalarWhereInput[]
    OR?: im_healthScalarWhereInput[]
    NOT?: im_healthScalarWhereInput | im_healthScalarWhereInput[]
    id_health?: IntFilter<"im_health"> | number
    id_user?: IntFilter<"im_health"> | number
  }

  export type im_nutritionUpsertWithWhereUniqueWithoutIm_userInput = {
    where: im_nutritionWhereUniqueInput
    update: XOR<im_nutritionUpdateWithoutIm_userInput, im_nutritionUncheckedUpdateWithoutIm_userInput>
    create: XOR<im_nutritionCreateWithoutIm_userInput, im_nutritionUncheckedCreateWithoutIm_userInput>
  }

  export type im_nutritionUpdateWithWhereUniqueWithoutIm_userInput = {
    where: im_nutritionWhereUniqueInput
    data: XOR<im_nutritionUpdateWithoutIm_userInput, im_nutritionUncheckedUpdateWithoutIm_userInput>
  }

  export type im_nutritionUpdateManyWithWhereWithoutIm_userInput = {
    where: im_nutritionScalarWhereInput
    data: XOR<im_nutritionUpdateManyMutationInput, im_nutritionUncheckedUpdateManyWithoutIm_userInput>
  }

  export type im_nutritionScalarWhereInput = {
    AND?: im_nutritionScalarWhereInput | im_nutritionScalarWhereInput[]
    OR?: im_nutritionScalarWhereInput[]
    NOT?: im_nutritionScalarWhereInput | im_nutritionScalarWhereInput[]
    id_nutrition?: IntFilter<"im_nutrition"> | number
    nutrition_goal?: IntFilter<"im_nutrition"> | number
    nutrition_goal_calories?: IntFilter<"im_nutrition"> | number
    nutrition_goal_carbs?: IntFilter<"im_nutrition"> | number
    nutrition_goal_prots?: IntFilter<"im_nutrition"> | number
    nutrition_goal_fats?: IntFilter<"im_nutrition"> | number
    id_user?: IntFilter<"im_nutrition"> | number
  }

  export type im_trainingUpsertWithWhereUniqueWithoutIm_userInput = {
    where: im_trainingWhereUniqueInput
    update: XOR<im_trainingUpdateWithoutIm_userInput, im_trainingUncheckedUpdateWithoutIm_userInput>
    create: XOR<im_trainingCreateWithoutIm_userInput, im_trainingUncheckedCreateWithoutIm_userInput>
  }

  export type im_trainingUpdateWithWhereUniqueWithoutIm_userInput = {
    where: im_trainingWhereUniqueInput
    data: XOR<im_trainingUpdateWithoutIm_userInput, im_trainingUncheckedUpdateWithoutIm_userInput>
  }

  export type im_trainingUpdateManyWithWhereWithoutIm_userInput = {
    where: im_trainingScalarWhereInput
    data: XOR<im_trainingUpdateManyMutationInput, im_trainingUncheckedUpdateManyWithoutIm_userInput>
  }

  export type im_trainingScalarWhereInput = {
    AND?: im_trainingScalarWhereInput | im_trainingScalarWhereInput[]
    OR?: im_trainingScalarWhereInput[]
    NOT?: im_trainingScalarWhereInput | im_trainingScalarWhereInput[]
    id_training?: IntFilter<"im_training"> | number
    training_goal?: StringFilter<"im_training"> | string
    id_user?: IntFilter<"im_training"> | number
  }

  export type im_undesirable_foodUpsertWithWhereUniqueWithoutIm_userInput = {
    where: im_undesirable_foodWhereUniqueInput
    update: XOR<im_undesirable_foodUpdateWithoutIm_userInput, im_undesirable_foodUncheckedUpdateWithoutIm_userInput>
    create: XOR<im_undesirable_foodCreateWithoutIm_userInput, im_undesirable_foodUncheckedCreateWithoutIm_userInput>
  }

  export type im_undesirable_foodUpdateWithWhereUniqueWithoutIm_userInput = {
    where: im_undesirable_foodWhereUniqueInput
    data: XOR<im_undesirable_foodUpdateWithoutIm_userInput, im_undesirable_foodUncheckedUpdateWithoutIm_userInput>
  }

  export type im_undesirable_foodUpdateManyWithWhereWithoutIm_userInput = {
    where: im_undesirable_foodScalarWhereInput
    data: XOR<im_undesirable_foodUpdateManyMutationInput, im_undesirable_foodUncheckedUpdateManyWithoutIm_userInput>
  }

  export type im_exerciseCreateWithoutIm_workoutInput = {
    exercise_name: string
    exercise_type: string
    exercise_rest_time: number
    exercise_reps: number
    exercise_series: number
    exercise_description: string
    im_exercise_history?: im_exercise_historyCreateNestedManyWithoutIm_exerciseInput
  }

  export type im_exerciseUncheckedCreateWithoutIm_workoutInput = {
    id_exercise?: number
    exercise_name: string
    exercise_type: string
    exercise_rest_time: number
    exercise_reps: number
    exercise_series: number
    exercise_description: string
    im_exercise_history?: im_exercise_historyUncheckedCreateNestedManyWithoutIm_exerciseInput
  }

  export type im_exerciseCreateOrConnectWithoutIm_workoutInput = {
    where: im_exerciseWhereUniqueInput
    create: XOR<im_exerciseCreateWithoutIm_workoutInput, im_exerciseUncheckedCreateWithoutIm_workoutInput>
  }

  export type im_exerciseCreateManyIm_workoutInputEnvelope = {
    data: im_exerciseCreateManyIm_workoutInput | im_exerciseCreateManyIm_workoutInput[]
    skipDuplicates?: boolean
  }

  export type im_trainingCreateWithoutIm_workoutInput = {
    training_goal: string
    im_user: im_userCreateNestedOneWithoutIm_trainingInput
  }

  export type im_trainingUncheckedCreateWithoutIm_workoutInput = {
    id_training?: number
    training_goal: string
    id_user: number
  }

  export type im_trainingCreateOrConnectWithoutIm_workoutInput = {
    where: im_trainingWhereUniqueInput
    create: XOR<im_trainingCreateWithoutIm_workoutInput, im_trainingUncheckedCreateWithoutIm_workoutInput>
  }

  export type im_exerciseUpsertWithWhereUniqueWithoutIm_workoutInput = {
    where: im_exerciseWhereUniqueInput
    update: XOR<im_exerciseUpdateWithoutIm_workoutInput, im_exerciseUncheckedUpdateWithoutIm_workoutInput>
    create: XOR<im_exerciseCreateWithoutIm_workoutInput, im_exerciseUncheckedCreateWithoutIm_workoutInput>
  }

  export type im_exerciseUpdateWithWhereUniqueWithoutIm_workoutInput = {
    where: im_exerciseWhereUniqueInput
    data: XOR<im_exerciseUpdateWithoutIm_workoutInput, im_exerciseUncheckedUpdateWithoutIm_workoutInput>
  }

  export type im_exerciseUpdateManyWithWhereWithoutIm_workoutInput = {
    where: im_exerciseScalarWhereInput
    data: XOR<im_exerciseUpdateManyMutationInput, im_exerciseUncheckedUpdateManyWithoutIm_workoutInput>
  }

  export type im_exerciseScalarWhereInput = {
    AND?: im_exerciseScalarWhereInput | im_exerciseScalarWhereInput[]
    OR?: im_exerciseScalarWhereInput[]
    NOT?: im_exerciseScalarWhereInput | im_exerciseScalarWhereInput[]
    id_exercise?: IntFilter<"im_exercise"> | number
    exercise_name?: StringFilter<"im_exercise"> | string
    exercise_type?: StringFilter<"im_exercise"> | string
    exercise_rest_time?: IntFilter<"im_exercise"> | number
    exercise_reps?: IntFilter<"im_exercise"> | number
    exercise_series?: IntFilter<"im_exercise"> | number
    exercise_description?: StringFilter<"im_exercise"> | string
    id_workout?: IntFilter<"im_exercise"> | number
  }

  export type im_trainingUpsertWithoutIm_workoutInput = {
    update: XOR<im_trainingUpdateWithoutIm_workoutInput, im_trainingUncheckedUpdateWithoutIm_workoutInput>
    create: XOR<im_trainingCreateWithoutIm_workoutInput, im_trainingUncheckedCreateWithoutIm_workoutInput>
    where?: im_trainingWhereInput
  }

  export type im_trainingUpdateToOneWithWhereWithoutIm_workoutInput = {
    where?: im_trainingWhereInput
    data: XOR<im_trainingUpdateWithoutIm_workoutInput, im_trainingUncheckedUpdateWithoutIm_workoutInput>
  }

  export type im_trainingUpdateWithoutIm_workoutInput = {
    training_goal?: StringFieldUpdateOperationsInput | string
    im_user?: im_userUpdateOneRequiredWithoutIm_trainingNestedInput
  }

  export type im_trainingUncheckedUpdateWithoutIm_workoutInput = {
    id_training?: IntFieldUpdateOperationsInput | number
    training_goal?: StringFieldUpdateOperationsInput | string
    id_user?: IntFieldUpdateOperationsInput | number
  }

  export type im_exercise_historyCreateManyIm_exerciseInput = {
    id_exercise_history?: number
    exercise_history_date: Date | string
  }

  export type im_exercise_historyUpdateWithoutIm_exerciseInput = {
    exercise_history_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type im_exercise_historyUncheckedUpdateWithoutIm_exerciseInput = {
    id_exercise_history?: IntFieldUpdateOperationsInput | number
    exercise_history_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type im_exercise_historyUncheckedUpdateManyWithoutIm_exerciseInput = {
    id_exercise_history?: IntFieldUpdateOperationsInput | number
    exercise_history_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type im_recipeCreateManyIm_foodInput = {
    id_recipe?: number
    id_meal: number
  }

  export type im_undesirable_foodCreateManyIm_foodInput = {
    id_undesirable_food?: number
    id_user: number
  }

  export type im_recipeUpdateWithoutIm_foodInput = {
    im_meal?: im_mealUpdateOneRequiredWithoutIm_recipeNestedInput
  }

  export type im_recipeUncheckedUpdateWithoutIm_foodInput = {
    id_recipe?: IntFieldUpdateOperationsInput | number
    id_meal?: IntFieldUpdateOperationsInput | number
  }

  export type im_recipeUncheckedUpdateManyWithoutIm_foodInput = {
    id_recipe?: IntFieldUpdateOperationsInput | number
    id_meal?: IntFieldUpdateOperationsInput | number
  }

  export type im_undesirable_foodUpdateWithoutIm_foodInput = {
    im_user?: im_userUpdateOneRequiredWithoutIm_undesirable_foodNestedInput
  }

  export type im_undesirable_foodUncheckedUpdateWithoutIm_foodInput = {
    id_undesirable_food?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
  }

  export type im_undesirable_foodUncheckedUpdateManyWithoutIm_foodInput = {
    id_undesirable_food?: IntFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
  }

  export type im_health_goalCreateManyIm_healthInput = {
    id_health_goal?: number
    health_goal_steps: number
    health_goal_weight: number
    health_goal_sleep: number
    health_goal_water: number
  }

  export type im_health_goalUpdateWithoutIm_healthInput = {
    health_goal_steps?: IntFieldUpdateOperationsInput | number
    health_goal_weight?: IntFieldUpdateOperationsInput | number
    health_goal_sleep?: IntFieldUpdateOperationsInput | number
    health_goal_water?: IntFieldUpdateOperationsInput | number
    im_health_goal_daily?: im_health_goal_dailyUpdateManyWithoutIm_health_goalNestedInput
  }

  export type im_health_goalUncheckedUpdateWithoutIm_healthInput = {
    id_health_goal?: IntFieldUpdateOperationsInput | number
    health_goal_steps?: IntFieldUpdateOperationsInput | number
    health_goal_weight?: IntFieldUpdateOperationsInput | number
    health_goal_sleep?: IntFieldUpdateOperationsInput | number
    health_goal_water?: IntFieldUpdateOperationsInput | number
    im_health_goal_daily?: im_health_goal_dailyUncheckedUpdateManyWithoutIm_health_goalNestedInput
  }

  export type im_health_goalUncheckedUpdateManyWithoutIm_healthInput = {
    id_health_goal?: IntFieldUpdateOperationsInput | number
    health_goal_steps?: IntFieldUpdateOperationsInput | number
    health_goal_weight?: IntFieldUpdateOperationsInput | number
    health_goal_sleep?: IntFieldUpdateOperationsInput | number
    health_goal_water?: IntFieldUpdateOperationsInput | number
  }

  export type im_health_goal_dailyCreateManyIm_health_goalInput = {
    id_health_goal_daily?: number
    health_goal_daily_date: Date | string
    health_goal_daily_steps: number
    health_goal_daily_weight: number
    health_goal_daily_sleep: number
    health_goal_daily_water: number
  }

  export type im_health_goal_dailyUpdateWithoutIm_health_goalInput = {
    health_goal_daily_date?: DateTimeFieldUpdateOperationsInput | Date | string
    health_goal_daily_steps?: IntFieldUpdateOperationsInput | number
    health_goal_daily_weight?: IntFieldUpdateOperationsInput | number
    health_goal_daily_sleep?: IntFieldUpdateOperationsInput | number
    health_goal_daily_water?: IntFieldUpdateOperationsInput | number
    im_health_goal_daily_history?: im_health_goal_daily_historyUpdateManyWithoutIm_health_goal_dailyNestedInput
  }

  export type im_health_goal_dailyUncheckedUpdateWithoutIm_health_goalInput = {
    id_health_goal_daily?: IntFieldUpdateOperationsInput | number
    health_goal_daily_date?: DateTimeFieldUpdateOperationsInput | Date | string
    health_goal_daily_steps?: IntFieldUpdateOperationsInput | number
    health_goal_daily_weight?: IntFieldUpdateOperationsInput | number
    health_goal_daily_sleep?: IntFieldUpdateOperationsInput | number
    health_goal_daily_water?: IntFieldUpdateOperationsInput | number
    im_health_goal_daily_history?: im_health_goal_daily_historyUncheckedUpdateManyWithoutIm_health_goal_dailyNestedInput
  }

  export type im_health_goal_dailyUncheckedUpdateManyWithoutIm_health_goalInput = {
    id_health_goal_daily?: IntFieldUpdateOperationsInput | number
    health_goal_daily_date?: DateTimeFieldUpdateOperationsInput | Date | string
    health_goal_daily_steps?: IntFieldUpdateOperationsInput | number
    health_goal_daily_weight?: IntFieldUpdateOperationsInput | number
    health_goal_daily_sleep?: IntFieldUpdateOperationsInput | number
    health_goal_daily_water?: IntFieldUpdateOperationsInput | number
  }

  export type im_health_goal_daily_historyCreateManyIm_health_goal_dailyInput = {
    id_health_goal_daily_history?: number
    health_goal_daily_history_date: Date | string
  }

  export type im_health_goal_daily_historyUpdateWithoutIm_health_goal_dailyInput = {
    health_goal_daily_history_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type im_health_goal_daily_historyUncheckedUpdateWithoutIm_health_goal_dailyInput = {
    id_health_goal_daily_history?: IntFieldUpdateOperationsInput | number
    health_goal_daily_history_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type im_health_goal_daily_historyUncheckedUpdateManyWithoutIm_health_goal_dailyInput = {
    id_health_goal_daily_history?: IntFieldUpdateOperationsInput | number
    health_goal_daily_history_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type im_recipeCreateManyIm_mealInput = {
    id_recipe?: number
    id_food: number
  }

  export type im_recipeUpdateWithoutIm_mealInput = {
    im_food?: im_foodUpdateOneRequiredWithoutIm_recipeNestedInput
  }

  export type im_recipeUncheckedUpdateWithoutIm_mealInput = {
    id_recipe?: IntFieldUpdateOperationsInput | number
    id_food?: IntFieldUpdateOperationsInput | number
  }

  export type im_recipeUncheckedUpdateManyWithoutIm_mealInput = {
    id_recipe?: IntFieldUpdateOperationsInput | number
    id_food?: IntFieldUpdateOperationsInput | number
  }

  export type im_mealCreateManyIm_nutritionInput = {
    id_meal?: number
    meal_name: string
    meal_quantity: number
    meal_calories: number
    meal_carbs: number
    meal_prots: number
    meal_fats: number
    meal_description: string
    meal_length: number
    meal_image: string
    meal_difficulty: number
    meal_season: number
  }

  export type im_mealUpdateWithoutIm_nutritionInput = {
    meal_name?: StringFieldUpdateOperationsInput | string
    meal_quantity?: IntFieldUpdateOperationsInput | number
    meal_calories?: IntFieldUpdateOperationsInput | number
    meal_carbs?: IntFieldUpdateOperationsInput | number
    meal_prots?: IntFieldUpdateOperationsInput | number
    meal_fats?: IntFieldUpdateOperationsInput | number
    meal_description?: StringFieldUpdateOperationsInput | string
    meal_length?: IntFieldUpdateOperationsInput | number
    meal_image?: StringFieldUpdateOperationsInput | string
    meal_difficulty?: IntFieldUpdateOperationsInput | number
    meal_season?: IntFieldUpdateOperationsInput | number
    im_recipe?: im_recipeUpdateManyWithoutIm_mealNestedInput
  }

  export type im_mealUncheckedUpdateWithoutIm_nutritionInput = {
    id_meal?: IntFieldUpdateOperationsInput | number
    meal_name?: StringFieldUpdateOperationsInput | string
    meal_quantity?: IntFieldUpdateOperationsInput | number
    meal_calories?: IntFieldUpdateOperationsInput | number
    meal_carbs?: IntFieldUpdateOperationsInput | number
    meal_prots?: IntFieldUpdateOperationsInput | number
    meal_fats?: IntFieldUpdateOperationsInput | number
    meal_description?: StringFieldUpdateOperationsInput | string
    meal_length?: IntFieldUpdateOperationsInput | number
    meal_image?: StringFieldUpdateOperationsInput | string
    meal_difficulty?: IntFieldUpdateOperationsInput | number
    meal_season?: IntFieldUpdateOperationsInput | number
    im_recipe?: im_recipeUncheckedUpdateManyWithoutIm_mealNestedInput
  }

  export type im_mealUncheckedUpdateManyWithoutIm_nutritionInput = {
    id_meal?: IntFieldUpdateOperationsInput | number
    meal_name?: StringFieldUpdateOperationsInput | string
    meal_quantity?: IntFieldUpdateOperationsInput | number
    meal_calories?: IntFieldUpdateOperationsInput | number
    meal_carbs?: IntFieldUpdateOperationsInput | number
    meal_prots?: IntFieldUpdateOperationsInput | number
    meal_fats?: IntFieldUpdateOperationsInput | number
    meal_description?: StringFieldUpdateOperationsInput | string
    meal_length?: IntFieldUpdateOperationsInput | number
    meal_image?: StringFieldUpdateOperationsInput | string
    meal_difficulty?: IntFieldUpdateOperationsInput | number
    meal_season?: IntFieldUpdateOperationsInput | number
  }

  export type im_workoutCreateManyIm_trainingInput = {
    id_workout?: number
    workout_point: number
    workout_name: string
    workout_comment: string
  }

  export type im_workoutUpdateWithoutIm_trainingInput = {
    workout_point?: IntFieldUpdateOperationsInput | number
    workout_name?: StringFieldUpdateOperationsInput | string
    workout_comment?: StringFieldUpdateOperationsInput | string
    im_exercise?: im_exerciseUpdateManyWithoutIm_workoutNestedInput
  }

  export type im_workoutUncheckedUpdateWithoutIm_trainingInput = {
    id_workout?: IntFieldUpdateOperationsInput | number
    workout_point?: IntFieldUpdateOperationsInput | number
    workout_name?: StringFieldUpdateOperationsInput | string
    workout_comment?: StringFieldUpdateOperationsInput | string
    im_exercise?: im_exerciseUncheckedUpdateManyWithoutIm_workoutNestedInput
  }

  export type im_workoutUncheckedUpdateManyWithoutIm_trainingInput = {
    id_workout?: IntFieldUpdateOperationsInput | number
    workout_point?: IntFieldUpdateOperationsInput | number
    workout_name?: StringFieldUpdateOperationsInput | string
    workout_comment?: StringFieldUpdateOperationsInput | string
  }

  export type im_healthCreateManyIm_userInput = {
    id_health?: number
  }

  export type im_nutritionCreateManyIm_userInput = {
    id_nutrition?: number
    nutrition_goal: number
    nutrition_goal_calories: number
    nutrition_goal_carbs: number
    nutrition_goal_prots: number
    nutrition_goal_fats: number
  }

  export type im_trainingCreateManyIm_userInput = {
    id_training?: number
    training_goal: string
  }

  export type im_undesirable_foodCreateManyIm_userInput = {
    id_undesirable_food?: number
    id_food: number
  }

  export type im_healthUpdateWithoutIm_userInput = {
    im_health_goal?: im_health_goalUpdateManyWithoutIm_healthNestedInput
  }

  export type im_healthUncheckedUpdateWithoutIm_userInput = {
    id_health?: IntFieldUpdateOperationsInput | number
    im_health_goal?: im_health_goalUncheckedUpdateManyWithoutIm_healthNestedInput
  }

  export type im_healthUncheckedUpdateManyWithoutIm_userInput = {
    id_health?: IntFieldUpdateOperationsInput | number
  }

  export type im_nutritionUpdateWithoutIm_userInput = {
    nutrition_goal?: IntFieldUpdateOperationsInput | number
    nutrition_goal_calories?: IntFieldUpdateOperationsInput | number
    nutrition_goal_carbs?: IntFieldUpdateOperationsInput | number
    nutrition_goal_prots?: IntFieldUpdateOperationsInput | number
    nutrition_goal_fats?: IntFieldUpdateOperationsInput | number
    im_meal?: im_mealUpdateManyWithoutIm_nutritionNestedInput
  }

  export type im_nutritionUncheckedUpdateWithoutIm_userInput = {
    id_nutrition?: IntFieldUpdateOperationsInput | number
    nutrition_goal?: IntFieldUpdateOperationsInput | number
    nutrition_goal_calories?: IntFieldUpdateOperationsInput | number
    nutrition_goal_carbs?: IntFieldUpdateOperationsInput | number
    nutrition_goal_prots?: IntFieldUpdateOperationsInput | number
    nutrition_goal_fats?: IntFieldUpdateOperationsInput | number
    im_meal?: im_mealUncheckedUpdateManyWithoutIm_nutritionNestedInput
  }

  export type im_nutritionUncheckedUpdateManyWithoutIm_userInput = {
    id_nutrition?: IntFieldUpdateOperationsInput | number
    nutrition_goal?: IntFieldUpdateOperationsInput | number
    nutrition_goal_calories?: IntFieldUpdateOperationsInput | number
    nutrition_goal_carbs?: IntFieldUpdateOperationsInput | number
    nutrition_goal_prots?: IntFieldUpdateOperationsInput | number
    nutrition_goal_fats?: IntFieldUpdateOperationsInput | number
  }

  export type im_trainingUpdateWithoutIm_userInput = {
    training_goal?: StringFieldUpdateOperationsInput | string
    im_workout?: im_workoutUpdateManyWithoutIm_trainingNestedInput
  }

  export type im_trainingUncheckedUpdateWithoutIm_userInput = {
    id_training?: IntFieldUpdateOperationsInput | number
    training_goal?: StringFieldUpdateOperationsInput | string
    im_workout?: im_workoutUncheckedUpdateManyWithoutIm_trainingNestedInput
  }

  export type im_trainingUncheckedUpdateManyWithoutIm_userInput = {
    id_training?: IntFieldUpdateOperationsInput | number
    training_goal?: StringFieldUpdateOperationsInput | string
  }

  export type im_undesirable_foodUpdateWithoutIm_userInput = {
    im_food?: im_foodUpdateOneRequiredWithoutIm_undesirable_foodNestedInput
  }

  export type im_undesirable_foodUncheckedUpdateWithoutIm_userInput = {
    id_undesirable_food?: IntFieldUpdateOperationsInput | number
    id_food?: IntFieldUpdateOperationsInput | number
  }

  export type im_undesirable_foodUncheckedUpdateManyWithoutIm_userInput = {
    id_undesirable_food?: IntFieldUpdateOperationsInput | number
    id_food?: IntFieldUpdateOperationsInput | number
  }

  export type im_exerciseCreateManyIm_workoutInput = {
    id_exercise?: number
    exercise_name: string
    exercise_type: string
    exercise_rest_time: number
    exercise_reps: number
    exercise_series: number
    exercise_description: string
  }

  export type im_exerciseUpdateWithoutIm_workoutInput = {
    exercise_name?: StringFieldUpdateOperationsInput | string
    exercise_type?: StringFieldUpdateOperationsInput | string
    exercise_rest_time?: IntFieldUpdateOperationsInput | number
    exercise_reps?: IntFieldUpdateOperationsInput | number
    exercise_series?: IntFieldUpdateOperationsInput | number
    exercise_description?: StringFieldUpdateOperationsInput | string
    im_exercise_history?: im_exercise_historyUpdateManyWithoutIm_exerciseNestedInput
  }

  export type im_exerciseUncheckedUpdateWithoutIm_workoutInput = {
    id_exercise?: IntFieldUpdateOperationsInput | number
    exercise_name?: StringFieldUpdateOperationsInput | string
    exercise_type?: StringFieldUpdateOperationsInput | string
    exercise_rest_time?: IntFieldUpdateOperationsInput | number
    exercise_reps?: IntFieldUpdateOperationsInput | number
    exercise_series?: IntFieldUpdateOperationsInput | number
    exercise_description?: StringFieldUpdateOperationsInput | string
    im_exercise_history?: im_exercise_historyUncheckedUpdateManyWithoutIm_exerciseNestedInput
  }

  export type im_exerciseUncheckedUpdateManyWithoutIm_workoutInput = {
    id_exercise?: IntFieldUpdateOperationsInput | number
    exercise_name?: StringFieldUpdateOperationsInput | string
    exercise_type?: StringFieldUpdateOperationsInput | string
    exercise_rest_time?: IntFieldUpdateOperationsInput | number
    exercise_reps?: IntFieldUpdateOperationsInput | number
    exercise_series?: IntFieldUpdateOperationsInput | number
    exercise_description?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use Im_exerciseCountOutputTypeDefaultArgs instead
     */
    export type Im_exerciseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Im_exerciseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Im_foodCountOutputTypeDefaultArgs instead
     */
    export type Im_foodCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Im_foodCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Im_healthCountOutputTypeDefaultArgs instead
     */
    export type Im_healthCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Im_healthCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Im_health_goalCountOutputTypeDefaultArgs instead
     */
    export type Im_health_goalCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Im_health_goalCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Im_health_goal_dailyCountOutputTypeDefaultArgs instead
     */
    export type Im_health_goal_dailyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Im_health_goal_dailyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Im_mealCountOutputTypeDefaultArgs instead
     */
    export type Im_mealCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Im_mealCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Im_nutritionCountOutputTypeDefaultArgs instead
     */
    export type Im_nutritionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Im_nutritionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Im_trainingCountOutputTypeDefaultArgs instead
     */
    export type Im_trainingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Im_trainingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Im_userCountOutputTypeDefaultArgs instead
     */
    export type Im_userCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Im_userCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Im_workoutCountOutputTypeDefaultArgs instead
     */
    export type Im_workoutCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Im_workoutCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use im_exerciseDefaultArgs instead
     */
    export type im_exerciseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = im_exerciseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use im_exercise_historyDefaultArgs instead
     */
    export type im_exercise_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = im_exercise_historyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use im_foodDefaultArgs instead
     */
    export type im_foodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = im_foodDefaultArgs<ExtArgs>
    /**
     * @deprecated Use im_healthDefaultArgs instead
     */
    export type im_healthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = im_healthDefaultArgs<ExtArgs>
    /**
     * @deprecated Use im_health_goalDefaultArgs instead
     */
    export type im_health_goalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = im_health_goalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use im_health_goal_dailyDefaultArgs instead
     */
    export type im_health_goal_dailyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = im_health_goal_dailyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use im_health_goal_daily_historyDefaultArgs instead
     */
    export type im_health_goal_daily_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = im_health_goal_daily_historyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use im_mealDefaultArgs instead
     */
    export type im_mealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = im_mealDefaultArgs<ExtArgs>
    /**
     * @deprecated Use im_nutritionDefaultArgs instead
     */
    export type im_nutritionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = im_nutritionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use im_recipeDefaultArgs instead
     */
    export type im_recipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = im_recipeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use im_trainingDefaultArgs instead
     */
    export type im_trainingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = im_trainingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use im_undesirable_foodDefaultArgs instead
     */
    export type im_undesirable_foodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = im_undesirable_foodDefaultArgs<ExtArgs>
    /**
     * @deprecated Use im_userDefaultArgs instead
     */
    export type im_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = im_userDefaultArgs<ExtArgs>
    /**
     * @deprecated Use im_workoutDefaultArgs instead
     */
    export type im_workoutArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = im_workoutDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}